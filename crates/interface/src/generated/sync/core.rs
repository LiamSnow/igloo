// Generated by `wit-bindgen` 0.52.0. DO NOT EDIT!
// Options used:
//   * additional derives ["PartialEq", "serde::Serialize", "serde::Deserialize"]
//   * with "igloo:lib/id@0.1.0" = "crate::generated::shared::igloo::lib::id"
//   * with "igloo:lib/compound@0.1.0" = "crate::generated::shared::igloo::lib::compound"
//   * with "igloo:lib/component@0.1.0" = "crate::generated::shared::igloo::lib::component"
//   * generate_unused_types
//   * async: -all
#[allow(unfulfilled_lint_expectations, unused_imports)]
use crate::generated::shared::igloo::lib::id as __with_name0;
#[allow(unfulfilled_lint_expectations, unused_imports)]
use crate::generated::shared::igloo::lib::compound as __with_name1;
#[allow(unfulfilled_lint_expectations, unused_imports)]
use crate::generated::shared::igloo::lib::component as __with_name2;
#[allow(dead_code, clippy::all)]
pub mod igloo {
  pub mod lib {

    #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
    pub mod core_to_extension_sp {
      #[used]
      #[doc(hidden)]
      static __FORCE_SECTION_REF: fn() =
      super::super::super::__link_custom_section_describing_imports;
      
      use super::super::super::_rt;
      pub type DeviceId = super::super::super::__with_name0::DeviceId;
      pub type EntityIndex = super::super::super::__with_name0::EntityIndex;
      pub type Component = super::super::super::__with_name2::Component;
      #[allow(unused_unsafe, clippy::all)]
      /// Igloo core request to put a component on the given device and entity.
      /// The change will not be applied to the device tree until the extension
      /// confirms by sending a `put-component` back
      /// (usually after response from the physical hardware device)
      ///
      /// The extension _should_ hint to the core whether the operation will
      /// succeed by returning either `Ok` or `Err`
      #[allow(async_fn_in_trait)]
      pub fn put_component(device_id: DeviceId,entity_index: EntityIndex,component: &Component,) -> Result<(),_rt::String>{
        unsafe {
          let mut cleanup_list = _rt::Vec::new();

          #[cfg_attr(target_pointer_width="64", repr(align(8)))]
          #[cfg_attr(target_pointer_width="32", repr(align(4)))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 3*::core::mem::size_of::<*const u8>()]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 3*::core::mem::size_of::<*const u8>()]);
          let super::super::super::__with_name0::DeviceId{ packed:packed0, } = device_id;
          let super::super::super::__with_name0::EntityIndex{ inner:inner1, } = entity_index;
          use super::super::super::__with_name2::Component as V16;
          let (result17_0,result17_1,result17_2,result17_3,) = match component {
            V16::Integer(e) => (0i32, ::core::mem::MaybeUninit::new(_rt::as_i64(e) as u64), 0i64, 0i64),
            V16::Float(e) => (1i32, ::core::mem::MaybeUninit::new((_rt::as_f64(e)).to_bits() as i64 as u64), 0i64, 0i64),
            V16::String(e) => {
              let vec2 = e;
              let ptr2 = vec2.as_ptr().cast::<u8>();
              let len2 = vec2.len();

              (2i32, {
                let mut t = ::core::mem::MaybeUninit::<u64>::uninit();
                t.as_mut_ptr().cast::<*mut u8>().write(ptr2.cast_mut());
                t
              }, len2 as i64, 0i64)
            },
            V16::Bool(e) => (3i32, ::core::mem::MaybeUninit::new(i64::from(match e { true => 1, false => 0 }) as u64), 0i64, 0i64),
            V16::Color(e) => {
              let super::super::super::__with_name1::IglooColor{ r:r3, g:g3, b:b3, } = e;

              (4i32, ::core::mem::MaybeUninit::new((_rt::as_f64(r3)).to_bits() as i64 as u64), (_rt::as_f64(g3)).to_bits() as i64, (_rt::as_f64(b3)).to_bits() as i64)
            },
            V16::Date(e) => {
              let super::super::super::__with_name1::IglooDate{ year:year4, month:month4, day:day4, } = e;

              (5i32, ::core::mem::MaybeUninit::new(i64::from(_rt::as_i32(year4)) as u64), i64::from(_rt::as_i32(month4)), i64::from(_rt::as_i32(day4)))
            },
            V16::Time(e) => {
              let super::super::super::__with_name1::IglooTime{ hour:hour5, minute:minute5, second:second5, } = e;

              (6i32, ::core::mem::MaybeUninit::new(i64::from(_rt::as_i32(hour5)) as u64), i64::from(_rt::as_i32(minute5)), i64::from(_rt::as_i32(second5)))
            },
            V16::IntegerList(e) => {
              let vec6 = e;
              let ptr6 = vec6.as_ptr().cast::<u8>();
              let len6 = vec6.len();

              (7i32, {
                let mut t = ::core::mem::MaybeUninit::<u64>::uninit();
                t.as_mut_ptr().cast::<*mut u8>().write(ptr6.cast_mut());
                t
              }, len6 as i64, 0i64)
            },
            V16::FloatList(e) => {
              let vec7 = e;
              let ptr7 = vec7.as_ptr().cast::<u8>();
              let len7 = vec7.len();

              (8i32, {
                let mut t = ::core::mem::MaybeUninit::<u64>::uninit();
                t.as_mut_ptr().cast::<*mut u8>().write(ptr7.cast_mut());
                t
              }, len7 as i64, 0i64)
            },
            V16::StringList(e) => {
              let vec9 = e;
              let len9 = vec9.len();
              let layout9 = _rt::alloc::Layout::from_size_align(vec9.len() * (2*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>()).unwrap();
              let (result9, _cleanup9) = wit_bindgen::rt::Cleanup::new(layout9);cleanup_list.extend(_cleanup9);
              for (i, e) in vec9.into_iter().enumerate() {
                let base = result9.add(i * (2*::core::mem::size_of::<*const u8>()));
                {
                  let vec8 = e;
                  let ptr8 = vec8.as_ptr().cast::<u8>();
                  let len8 = vec8.len();
                  *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len8;
                  *base.add(0).cast::<*mut u8>() = ptr8.cast_mut();
                }
              }

              (9i32, {
                let mut t = ::core::mem::MaybeUninit::<u64>::uninit();
                t.as_mut_ptr().cast::<*mut u8>().write(result9);
                t
              }, len9 as i64, 0i64)
            },
            V16::BooleanList(e) => {
              let vec10 = e;
              let len10 = vec10.len();
              let layout10 = _rt::alloc::Layout::from_size_align(vec10.len() * 1, 1).unwrap();
              let (result10, _cleanup10) = wit_bindgen::rt::Cleanup::new(layout10);cleanup_list.extend(_cleanup10);
              for (i, e) in vec10.into_iter().enumerate() {
                let base = result10.add(i * 1);
                {
                  *base.add(0).cast::<u8>() = (match e { true => 1, false => 0 }) as u8;
                }
              }

              (10i32, {
                let mut t = ::core::mem::MaybeUninit::<u64>::uninit();
                t.as_mut_ptr().cast::<*mut u8>().write(result10);
                t
              }, len10 as i64, 0i64)
            },
            V16::ColorList(e) => {
              let vec11 = e;
              let ptr11 = vec11.as_ptr().cast::<u8>();
              let len11 = vec11.len();

              (11i32, {
                let mut t = ::core::mem::MaybeUninit::<u64>::uninit();
                t.as_mut_ptr().cast::<*mut u8>().write(ptr11.cast_mut());
                t
              }, len11 as i64, 0i64)
            },
            V16::DateList(e) => {
              let vec12 = e;
              let ptr12 = vec12.as_ptr().cast::<u8>();
              let len12 = vec12.len();

              (12i32, {
                let mut t = ::core::mem::MaybeUninit::<u64>::uninit();
                t.as_mut_ptr().cast::<*mut u8>().write(ptr12.cast_mut());
                t
              }, len12 as i64, 0i64)
            },
            V16::TimeList(e) => {
              let vec13 = e;
              let ptr13 = vec13.as_ptr().cast::<u8>();
              let len13 = vec13.len();

              (13i32, {
                let mut t = ::core::mem::MaybeUninit::<u64>::uninit();
                t.as_mut_ptr().cast::<*mut u8>().write(ptr13.cast_mut());
                t
              }, len13 as i64, 0i64)
            },
            V16::Trigger=> {
              (14i32, ::core::mem::MaybeUninit::<u64>::zeroed(), 0i64, 0i64)
            }
            V16::Timestamp(e) => (15i32, ::core::mem::MaybeUninit::new(_rt::as_i64(e) as u64), 0i64, 0i64),
            V16::Duration(e) => (16i32, ::core::mem::MaybeUninit::new(_rt::as_i64(e) as u64), 0i64, 0i64),
            V16::Weekday(e) => (17i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
            V16::Light=> {
              (18i32, ::core::mem::MaybeUninit::<u64>::zeroed(), 0i64, 0i64)
            }
            V16::Switch(e) => (19i32, ::core::mem::MaybeUninit::new(i64::from(match e { true => 1, false => 0 }) as u64), 0i64, 0i64),
            V16::Dimmer(e) => (20i32, ::core::mem::MaybeUninit::new((_rt::as_f64(e)).to_bits() as i64 as u64), 0i64, 0i64),
            V16::Switch(e) => (21i32, ::core::mem::MaybeUninit::new(i64::from(match e { true => 1, false => 0 }) as u64), 0i64, 0i64),
            V16::ColorMode(e) => (22i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
            V16::ColorTemperature(e) => (23i32, ::core::mem::MaybeUninit::new(_rt::as_i64(e) as u64), 0i64, 0i64),
            V16::Volume(e) => (24i32, ::core::mem::MaybeUninit::new((_rt::as_f64(e)).to_bits() as i64 as u64), 0i64, 0i64),
            V16::Muted(e) => (25i32, ::core::mem::MaybeUninit::new(i64::from(match e { true => 1, false => 0 }) as u64), 0i64, 0i64),
            V16::Config=> {
              (26i32, ::core::mem::MaybeUninit::<u64>::zeroed(), 0i64, 0i64)
            }
            V16::Diagnostic=> {
              (27i32, ::core::mem::MaybeUninit::<u64>::zeroed(), 0i64, 0i64)
            }
            V16::Siren=> {
              (28i32, ::core::mem::MaybeUninit::<u64>::zeroed(), 0i64, 0i64)
            }
            V16::Sensor=> {
              (29i32, ::core::mem::MaybeUninit::<u64>::zeroed(), 0i64, 0i64)
            }
            V16::Icon(e) => {
              let vec14 = e;
              let ptr14 = vec14.as_ptr().cast::<u8>();
              let len14 = vec14.len();

              (30i32, {
                let mut t = ::core::mem::MaybeUninit::<u64>::uninit();
                t.as_mut_ptr().cast::<*mut u8>().write(ptr14.cast_mut());
                t
              }, len14 as i64, 0i64)
            },
            V16::AccuracyDecimals(e) => (31i32, ::core::mem::MaybeUninit::new(_rt::as_i64(e) as u64), 0i64, 0i64),
            V16::DeviceClass(e) => {
              let vec15 = e;
              let ptr15 = vec15.as_ptr().cast::<u8>();
              let len15 = vec15.len();

              (32i32, {
                let mut t = ::core::mem::MaybeUninit::<u64>::uninit();
                t.as_mut_ptr().cast::<*mut u8>().write(ptr15.cast_mut());
                t
              }, len15 as i64, 0i64)
            },
            V16::SensorStateClass(e) => (33i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
            V16::UnitApparentPower(e) => (34i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
            V16::UnitPower(e) => (35i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
            V16::UnitReactivePower(e) => (36i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
            V16::UnitEnergy(e) => (37i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
            V16::UnitElectricCurrent(e) => (38i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
            V16::UnitElectricPotential(e) => (39i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
            V16::UnitDegree(e) => (40i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
            V16::UnitCurrency(e) => (41i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
            V16::UnitTemperature(e) => (42i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
            V16::UnitTime(e) => (43i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
            V16::UnitLength(e) => (44i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
            V16::UnitFrequency(e) => (45i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
            V16::UnitPressure(e) => (46i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
            V16::UnitSoundPressure(e) => (47i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
            V16::UnitVolume(e) => (48i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
            V16::UnitVolumeFlowRate(e) => (49i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
            V16::UnitArea(e) => (50i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
            V16::UnitMass(e) => (51i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
            V16::UnitConductivity(e) => (52i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
            V16::UnitLight(e) => (53i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
            V16::UnitUvIndex(e) => (54i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
            V16::UnitPercentage(e) => (55i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
            V16::UnitIrradiation(e) => (56i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
            V16::UnitConcentration(e) => (57i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
            V16::UnitSpeed(e) => (58i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
            V16::UnitData(e) => (59i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
            V16::UnitDataRate(e) => (60i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
            V16::FanOscillation(e) => (61i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
            V16::FanDirection(e) => (62i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
            V16::FanSpeed(e) => (63i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
            V16::ClimateMode(e) => (64i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
            V16::LockState(e) => (65i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
            V16::MediaState(e) => (66i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
            V16::Cover=> {
              (67i32, ::core::mem::MaybeUninit::<u64>::zeroed(), 0i64, 0i64)
            }
            V16::CoverState(e) => (68i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
            V16::Position(e) => (69i32, ::core::mem::MaybeUninit::new((_rt::as_f64(e)).to_bits() as i64 as u64), 0i64, 0i64),
            V16::Tilt(e) => (70i32, ::core::mem::MaybeUninit::new((_rt::as_f64(e)).to_bits() as i64 as u64), 0i64, 0i64),
            V16::Valve=> {
              (71i32, ::core::mem::MaybeUninit::<u64>::zeroed(), 0i64, 0i64)
            }
            V16::ValveState(e) => (72i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
            V16::AlarmState(e) => (73i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
          };
          let ptr18 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "igloo:lib/core-to-extension-sp@0.1.0")]
          unsafe extern "C" {
            #[link_name = "put-component"]
            fn wit_import19(_: i64, _: i64, _: i32, _: ::core::mem::MaybeUninit::<u64>, _: i64, _: i64, _: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn wit_import19(_: i64, _: i64, _: i32, _: ::core::mem::MaybeUninit::<u64>, _: i64, _: i64, _: *mut u8, ) { unreachable!() }
          wit_import19(_rt::as_i64(packed0), _rt::as_i64(inner1), result17_0, result17_1, result17_2, result17_3, ptr18);
          let l20 = i32::from(*ptr18.add(0).cast::<u8>());
          let result24 = match l20 {
            0 => {
              let e = ();
              Ok(e)
            }
            1 => {
              let e = {
                let l21 = *ptr18.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                let l22 = *ptr18.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>();
                let len23 = l22;
                let bytes23 = _rt::Vec::from_raw_parts(l21.cast(), len23, len23);

                _rt::string_lift(bytes23)
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          };
          result24
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Igloo has deleted device,
      /// extension must cleanup its `Device` reference
      #[allow(async_fn_in_trait)]
      pub fn delete_device(device_id: DeviceId,) -> Result<(),_rt::String>{
        unsafe {

          #[cfg_attr(target_pointer_width="64", repr(align(8)))]
          #[cfg_attr(target_pointer_width="32", repr(align(4)))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 3*::core::mem::size_of::<*const u8>()]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 3*::core::mem::size_of::<*const u8>()]);
          let super::super::super::__with_name0::DeviceId{ packed:packed0, } = device_id;
          let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "igloo:lib/core-to-extension-sp@0.1.0")]
          unsafe extern "C" {
            #[link_name = "delete-device"]
            fn wit_import2(_: i64, _: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn wit_import2(_: i64, _: *mut u8, ) { unreachable!() }
          wit_import2(_rt::as_i64(packed0), ptr1);
          let l3 = i32::from(*ptr1.add(0).cast::<u8>());
          let result7 = match l3 {
            0 => {
              let e = ();
              Ok(e)
            }
            1 => {
              let e = {
                let l4 = *ptr1.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                let l5 = *ptr1.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>();
                let len6 = l5;
                let bytes6 = _rt::Vec::from_raw_parts(l4.cast(), len6, len6);

                _rt::string_lift(bytes6)
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          };
          result7
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Custom function defined by extension
      #[allow(async_fn_in_trait)]
      pub fn custom(name: &str,params: &str,) -> Result<(),_rt::String>{
        unsafe {

          #[cfg_attr(target_pointer_width="64", repr(align(8)))]
          #[cfg_attr(target_pointer_width="32", repr(align(4)))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 3*::core::mem::size_of::<*const u8>()]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 3*::core::mem::size_of::<*const u8>()]);
          let vec0 = name;
          let ptr0 = vec0.as_ptr().cast::<u8>();
          let len0 = vec0.len();
          let vec1 = params;
          let ptr1 = vec1.as_ptr().cast::<u8>();
          let len1 = vec1.len();
          let ptr2 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "igloo:lib/core-to-extension-sp@0.1.0")]
          unsafe extern "C" {
            #[link_name = "custom"]
            fn wit_import3(_: *mut u8, _: usize, _: *mut u8, _: usize, _: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn wit_import3(_: *mut u8, _: usize, _: *mut u8, _: usize, _: *mut u8, ) { unreachable!() }
          wit_import3(ptr0.cast_mut(), len0, ptr1.cast_mut(), len1, ptr2);
          let l4 = i32::from(*ptr2.add(0).cast::<u8>());
          let result8 = match l4 {
            0 => {
              let e = ();
              Ok(e)
            }
            1 => {
              let e = {
                let l5 = *ptr2.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                let l6 = *ptr2.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>();
                let len7 = l6;
                let bytes7 = _rt::Vec::from_raw_parts(l5.cast(), len7, len7);

                _rt::string_lift(bytes7)
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          };
          result8
        }
      }

    }


    #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
    pub mod core_to_extension_mp {
      #[used]
      #[doc(hidden)]
      static __FORCE_SECTION_REF: fn() =
      super::super::super::__link_custom_section_describing_imports;
      
      use super::super::super::_rt;
      pub type EntityIndex = super::super::super::__with_name0::EntityIndex;
      pub type Component = super::super::super::__with_name2::Component;
      #[allow(unused_unsafe, clippy::all)]
      /// Igloo core request to put a component on the given entity.
      /// The change will not be applied to the device tree until the extension
      /// confirms by sending a `put-component` back
      /// (usually after response from the physical hardware device)
      ///
      /// The extension _should_ hint to the core whether the operation will
      /// succeed by returning either `Ok` or `Err`
      #[allow(async_fn_in_trait)]
      pub fn put_component(entity_index: EntityIndex,component: &Component,) -> Result<(),_rt::String>{
        unsafe {
          let mut cleanup_list = _rt::Vec::new();

          #[cfg_attr(target_pointer_width="64", repr(align(8)))]
          #[cfg_attr(target_pointer_width="32", repr(align(4)))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 3*::core::mem::size_of::<*const u8>()]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 3*::core::mem::size_of::<*const u8>()]);
          let super::super::super::__with_name0::EntityIndex{ inner:inner0, } = entity_index;
          use super::super::super::__with_name2::Component as V15;
          let (result16_0,result16_1,result16_2,result16_3,) = match component {
            V15::Integer(e) => (0i32, ::core::mem::MaybeUninit::new(_rt::as_i64(e) as u64), 0i64, 0i64),
            V15::Float(e) => (1i32, ::core::mem::MaybeUninit::new((_rt::as_f64(e)).to_bits() as i64 as u64), 0i64, 0i64),
            V15::String(e) => {
              let vec1 = e;
              let ptr1 = vec1.as_ptr().cast::<u8>();
              let len1 = vec1.len();

              (2i32, {
                let mut t = ::core::mem::MaybeUninit::<u64>::uninit();
                t.as_mut_ptr().cast::<*mut u8>().write(ptr1.cast_mut());
                t
              }, len1 as i64, 0i64)
            },
            V15::Bool(e) => (3i32, ::core::mem::MaybeUninit::new(i64::from(match e { true => 1, false => 0 }) as u64), 0i64, 0i64),
            V15::Color(e) => {
              let super::super::super::__with_name1::IglooColor{ r:r2, g:g2, b:b2, } = e;

              (4i32, ::core::mem::MaybeUninit::new((_rt::as_f64(r2)).to_bits() as i64 as u64), (_rt::as_f64(g2)).to_bits() as i64, (_rt::as_f64(b2)).to_bits() as i64)
            },
            V15::Date(e) => {
              let super::super::super::__with_name1::IglooDate{ year:year3, month:month3, day:day3, } = e;

              (5i32, ::core::mem::MaybeUninit::new(i64::from(_rt::as_i32(year3)) as u64), i64::from(_rt::as_i32(month3)), i64::from(_rt::as_i32(day3)))
            },
            V15::Time(e) => {
              let super::super::super::__with_name1::IglooTime{ hour:hour4, minute:minute4, second:second4, } = e;

              (6i32, ::core::mem::MaybeUninit::new(i64::from(_rt::as_i32(hour4)) as u64), i64::from(_rt::as_i32(minute4)), i64::from(_rt::as_i32(second4)))
            },
            V15::IntegerList(e) => {
              let vec5 = e;
              let ptr5 = vec5.as_ptr().cast::<u8>();
              let len5 = vec5.len();

              (7i32, {
                let mut t = ::core::mem::MaybeUninit::<u64>::uninit();
                t.as_mut_ptr().cast::<*mut u8>().write(ptr5.cast_mut());
                t
              }, len5 as i64, 0i64)
            },
            V15::FloatList(e) => {
              let vec6 = e;
              let ptr6 = vec6.as_ptr().cast::<u8>();
              let len6 = vec6.len();

              (8i32, {
                let mut t = ::core::mem::MaybeUninit::<u64>::uninit();
                t.as_mut_ptr().cast::<*mut u8>().write(ptr6.cast_mut());
                t
              }, len6 as i64, 0i64)
            },
            V15::StringList(e) => {
              let vec8 = e;
              let len8 = vec8.len();
              let layout8 = _rt::alloc::Layout::from_size_align(vec8.len() * (2*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>()).unwrap();
              let (result8, _cleanup8) = wit_bindgen::rt::Cleanup::new(layout8);cleanup_list.extend(_cleanup8);
              for (i, e) in vec8.into_iter().enumerate() {
                let base = result8.add(i * (2*::core::mem::size_of::<*const u8>()));
                {
                  let vec7 = e;
                  let ptr7 = vec7.as_ptr().cast::<u8>();
                  let len7 = vec7.len();
                  *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len7;
                  *base.add(0).cast::<*mut u8>() = ptr7.cast_mut();
                }
              }

              (9i32, {
                let mut t = ::core::mem::MaybeUninit::<u64>::uninit();
                t.as_mut_ptr().cast::<*mut u8>().write(result8);
                t
              }, len8 as i64, 0i64)
            },
            V15::BooleanList(e) => {
              let vec9 = e;
              let len9 = vec9.len();
              let layout9 = _rt::alloc::Layout::from_size_align(vec9.len() * 1, 1).unwrap();
              let (result9, _cleanup9) = wit_bindgen::rt::Cleanup::new(layout9);cleanup_list.extend(_cleanup9);
              for (i, e) in vec9.into_iter().enumerate() {
                let base = result9.add(i * 1);
                {
                  *base.add(0).cast::<u8>() = (match e { true => 1, false => 0 }) as u8;
                }
              }

              (10i32, {
                let mut t = ::core::mem::MaybeUninit::<u64>::uninit();
                t.as_mut_ptr().cast::<*mut u8>().write(result9);
                t
              }, len9 as i64, 0i64)
            },
            V15::ColorList(e) => {
              let vec10 = e;
              let ptr10 = vec10.as_ptr().cast::<u8>();
              let len10 = vec10.len();

              (11i32, {
                let mut t = ::core::mem::MaybeUninit::<u64>::uninit();
                t.as_mut_ptr().cast::<*mut u8>().write(ptr10.cast_mut());
                t
              }, len10 as i64, 0i64)
            },
            V15::DateList(e) => {
              let vec11 = e;
              let ptr11 = vec11.as_ptr().cast::<u8>();
              let len11 = vec11.len();

              (12i32, {
                let mut t = ::core::mem::MaybeUninit::<u64>::uninit();
                t.as_mut_ptr().cast::<*mut u8>().write(ptr11.cast_mut());
                t
              }, len11 as i64, 0i64)
            },
            V15::TimeList(e) => {
              let vec12 = e;
              let ptr12 = vec12.as_ptr().cast::<u8>();
              let len12 = vec12.len();

              (13i32, {
                let mut t = ::core::mem::MaybeUninit::<u64>::uninit();
                t.as_mut_ptr().cast::<*mut u8>().write(ptr12.cast_mut());
                t
              }, len12 as i64, 0i64)
            },
            V15::Trigger=> {
              (14i32, ::core::mem::MaybeUninit::<u64>::zeroed(), 0i64, 0i64)
            }
            V15::Timestamp(e) => (15i32, ::core::mem::MaybeUninit::new(_rt::as_i64(e) as u64), 0i64, 0i64),
            V15::Duration(e) => (16i32, ::core::mem::MaybeUninit::new(_rt::as_i64(e) as u64), 0i64, 0i64),
            V15::Weekday(e) => (17i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
            V15::Light=> {
              (18i32, ::core::mem::MaybeUninit::<u64>::zeroed(), 0i64, 0i64)
            }
            V15::Switch(e) => (19i32, ::core::mem::MaybeUninit::new(i64::from(match e { true => 1, false => 0 }) as u64), 0i64, 0i64),
            V15::Dimmer(e) => (20i32, ::core::mem::MaybeUninit::new((_rt::as_f64(e)).to_bits() as i64 as u64), 0i64, 0i64),
            V15::Switch(e) => (21i32, ::core::mem::MaybeUninit::new(i64::from(match e { true => 1, false => 0 }) as u64), 0i64, 0i64),
            V15::ColorMode(e) => (22i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
            V15::ColorTemperature(e) => (23i32, ::core::mem::MaybeUninit::new(_rt::as_i64(e) as u64), 0i64, 0i64),
            V15::Volume(e) => (24i32, ::core::mem::MaybeUninit::new((_rt::as_f64(e)).to_bits() as i64 as u64), 0i64, 0i64),
            V15::Muted(e) => (25i32, ::core::mem::MaybeUninit::new(i64::from(match e { true => 1, false => 0 }) as u64), 0i64, 0i64),
            V15::Config=> {
              (26i32, ::core::mem::MaybeUninit::<u64>::zeroed(), 0i64, 0i64)
            }
            V15::Diagnostic=> {
              (27i32, ::core::mem::MaybeUninit::<u64>::zeroed(), 0i64, 0i64)
            }
            V15::Siren=> {
              (28i32, ::core::mem::MaybeUninit::<u64>::zeroed(), 0i64, 0i64)
            }
            V15::Sensor=> {
              (29i32, ::core::mem::MaybeUninit::<u64>::zeroed(), 0i64, 0i64)
            }
            V15::Icon(e) => {
              let vec13 = e;
              let ptr13 = vec13.as_ptr().cast::<u8>();
              let len13 = vec13.len();

              (30i32, {
                let mut t = ::core::mem::MaybeUninit::<u64>::uninit();
                t.as_mut_ptr().cast::<*mut u8>().write(ptr13.cast_mut());
                t
              }, len13 as i64, 0i64)
            },
            V15::AccuracyDecimals(e) => (31i32, ::core::mem::MaybeUninit::new(_rt::as_i64(e) as u64), 0i64, 0i64),
            V15::DeviceClass(e) => {
              let vec14 = e;
              let ptr14 = vec14.as_ptr().cast::<u8>();
              let len14 = vec14.len();

              (32i32, {
                let mut t = ::core::mem::MaybeUninit::<u64>::uninit();
                t.as_mut_ptr().cast::<*mut u8>().write(ptr14.cast_mut());
                t
              }, len14 as i64, 0i64)
            },
            V15::SensorStateClass(e) => (33i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
            V15::UnitApparentPower(e) => (34i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
            V15::UnitPower(e) => (35i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
            V15::UnitReactivePower(e) => (36i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
            V15::UnitEnergy(e) => (37i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
            V15::UnitElectricCurrent(e) => (38i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
            V15::UnitElectricPotential(e) => (39i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
            V15::UnitDegree(e) => (40i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
            V15::UnitCurrency(e) => (41i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
            V15::UnitTemperature(e) => (42i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
            V15::UnitTime(e) => (43i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
            V15::UnitLength(e) => (44i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
            V15::UnitFrequency(e) => (45i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
            V15::UnitPressure(e) => (46i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
            V15::UnitSoundPressure(e) => (47i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
            V15::UnitVolume(e) => (48i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
            V15::UnitVolumeFlowRate(e) => (49i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
            V15::UnitArea(e) => (50i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
            V15::UnitMass(e) => (51i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
            V15::UnitConductivity(e) => (52i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
            V15::UnitLight(e) => (53i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
            V15::UnitUvIndex(e) => (54i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
            V15::UnitPercentage(e) => (55i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
            V15::UnitIrradiation(e) => (56i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
            V15::UnitConcentration(e) => (57i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
            V15::UnitSpeed(e) => (58i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
            V15::UnitData(e) => (59i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
            V15::UnitDataRate(e) => (60i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
            V15::FanOscillation(e) => (61i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
            V15::FanDirection(e) => (62i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
            V15::FanSpeed(e) => (63i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
            V15::ClimateMode(e) => (64i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
            V15::LockState(e) => (65i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
            V15::MediaState(e) => (66i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
            V15::Cover=> {
              (67i32, ::core::mem::MaybeUninit::<u64>::zeroed(), 0i64, 0i64)
            }
            V15::CoverState(e) => (68i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
            V15::Position(e) => (69i32, ::core::mem::MaybeUninit::new((_rt::as_f64(e)).to_bits() as i64 as u64), 0i64, 0i64),
            V15::Tilt(e) => (70i32, ::core::mem::MaybeUninit::new((_rt::as_f64(e)).to_bits() as i64 as u64), 0i64, 0i64),
            V15::Valve=> {
              (71i32, ::core::mem::MaybeUninit::<u64>::zeroed(), 0i64, 0i64)
            }
            V15::ValveState(e) => (72i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
            V15::AlarmState(e) => (73i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
          };
          let ptr17 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "igloo:lib/core-to-extension-mp@0.1.0")]
          unsafe extern "C" {
            #[link_name = "put-component"]
            fn wit_import18(_: i64, _: i32, _: ::core::mem::MaybeUninit::<u64>, _: i64, _: i64, _: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn wit_import18(_: i64, _: i32, _: ::core::mem::MaybeUninit::<u64>, _: i64, _: i64, _: *mut u8, ) { unreachable!() }
          wit_import18(_rt::as_i64(inner0), result16_0, result16_1, result16_2, result16_3, ptr17);
          let l19 = i32::from(*ptr17.add(0).cast::<u8>());
          let result23 = match l19 {
            0 => {
              let e = ();
              Ok(e)
            }
            1 => {
              let e = {
                let l20 = *ptr17.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                let l21 = *ptr17.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>();
                let len22 = l21;
                let bytes22 = _rt::Vec::from_raw_parts(l20.cast(), len22, len22);

                _rt::string_lift(bytes22)
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          };
          result23
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Custom function defined by extension
      #[allow(async_fn_in_trait)]
      pub fn custom(name: &str,params: &str,) -> Result<(),_rt::String>{
        unsafe {

          #[cfg_attr(target_pointer_width="64", repr(align(8)))]
          #[cfg_attr(target_pointer_width="32", repr(align(4)))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 3*::core::mem::size_of::<*const u8>()]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 3*::core::mem::size_of::<*const u8>()]);
          let vec0 = name;
          let ptr0 = vec0.as_ptr().cast::<u8>();
          let len0 = vec0.len();
          let vec1 = params;
          let ptr1 = vec1.as_ptr().cast::<u8>();
          let len1 = vec1.len();
          let ptr2 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "igloo:lib/core-to-extension-mp@0.1.0")]
          unsafe extern "C" {
            #[link_name = "custom"]
            fn wit_import3(_: *mut u8, _: usize, _: *mut u8, _: usize, _: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn wit_import3(_: *mut u8, _: usize, _: *mut u8, _: usize, _: *mut u8, ) { unreachable!() }
          wit_import3(ptr0.cast_mut(), len0, ptr1.cast_mut(), len1, ptr2);
          let l4 = i32::from(*ptr2.add(0).cast::<u8>());
          let result8 = match l4 {
            0 => {
              let e = ();
              Ok(e)
            }
            1 => {
              let e = {
                let l5 = *ptr2.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                let l6 = *ptr2.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>();
                let len7 = l6;
                let bytes7 = _rt::Vec::from_raw_parts(l5.cast(), len7, len7);

                _rt::string_lift(bytes7)
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          };
          result8
        }
      }

    }

  }
}
mod _rt {
  #![allow(dead_code, unused_imports, clippy::all)]
  pub use alloc_crate::string::String;

  pub fn as_i64<T: AsI64>(t: T) -> i64 {
    t.as_i64()
  }

  pub trait AsI64 {
    fn as_i64(self) -> i64;
  }

  impl<'a, T: Copy + AsI64> AsI64 for &'a T {
    fn as_i64(self) -> i64 {
      (*self).as_i64()
    }
  }
  
  impl AsI64 for i64 {
    #[inline]
    fn as_i64(self) -> i64 {
      self as i64
    }
  }
  
  impl AsI64 for u64 {
    #[inline]
    fn as_i64(self) -> i64 {
      self as i64
    }
  }
  
  pub fn as_f64<T: AsF64>(t: T) -> f64 {
    t.as_f64()
  }

  pub trait AsF64 {
    fn as_f64(self) -> f64;
  }

  impl<'a, T: Copy + AsF64> AsF64 for &'a T {
    fn as_f64(self) -> f64 {
      (*self).as_f64()
    }
  }
  
  impl AsF64 for f64 {
    #[inline]
    fn as_f64(self) -> f64 {
      self as f64
    }
  }
  
  pub fn as_i32<T: AsI32>(t: T) -> i32 {
    t.as_i32()
  }

  pub trait AsI32 {
    fn as_i32(self) -> i32;
  }

  impl<'a, T: Copy + AsI32> AsI32 for &'a T {
    fn as_i32(self) -> i32 {
      (*self).as_i32()
    }
  }
  
  impl AsI32 for i32 {
    #[inline]
    fn as_i32(self) -> i32 {
      self as i32
    }
  }
  
  impl AsI32 for u32 {
    #[inline]
    fn as_i32(self) -> i32 {
      self as i32
    }
  }
  
  impl AsI32 for i16 {
    #[inline]
    fn as_i32(self) -> i32 {
      self as i32
    }
  }
  
  impl AsI32 for u16 {
    #[inline]
    fn as_i32(self) -> i32 {
      self as i32
    }
  }
  
  impl AsI32 for i8 {
    #[inline]
    fn as_i32(self) -> i32 {
      self as i32
    }
  }
  
  impl AsI32 for u8 {
    #[inline]
    fn as_i32(self) -> i32 {
      self as i32
    }
  }
  
  impl AsI32 for char {
    #[inline]
    fn as_i32(self) -> i32 {
      self as i32
    }
  }
  
  impl AsI32 for usize {
    #[inline]
    fn as_i32(self) -> i32 {
      self as i32
    }
  }
  pub use alloc_crate::vec::Vec;
  pub use alloc_crate::alloc;
  pub unsafe fn string_lift(bytes: Vec<u8>) -> String {
    if cfg!(debug_assertions) {
      String::from_utf8(bytes).unwrap()
    } else {
      unsafe { String::from_utf8_unchecked(bytes) }
    }
  }
  pub unsafe fn invalid_enum_discriminant<T>() -> T {
    if cfg!(debug_assertions) {
      panic!("invalid enum discriminant")
    } else {
      unsafe { core::hint::unreachable_unchecked() }
    }
  }
  extern crate alloc as alloc_crate;
}

#[cfg(target_arch = "wasm32")]
#[unsafe(link_section = "component-type:wit-bindgen:0.52.0:igloo:lib@0.1.0:core:encoded world")]
#[doc(hidden)]
#[allow(clippy::octal_escapes)]
pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 5062] = *b"\
\0asm\x0d\0\x01\0\0\x19\x16wit-component-encoding\x04\0\x07\xcb&\x01A\x02\x01A\x10\
\x01B\x0c\x01r\x01\x06packedw\x04\0\x09device-id\x03\0\0\x01r\x01\x06packedw\x04\
\0\x08group-id\x03\0\x02\x01r\x01\x05inners\x04\0\x0cextension-id\x03\0\x04\x01r\
\x01\x05innerw\x04\0\x0fextension-index\x03\0\x06\x01r\x01\x05inners\x04\0\x09en\
tity-id\x03\0\x08\x01r\x01\x05innerw\x04\0\x0centity-index\x03\0\x0a\x03\0\x12ig\
loo:lib/id@0.1.0\x05\0\x01B\x06\x01r\x03\x01ru\x01gu\x01bu\x04\0\x0bigloo-color\x03\
\0\0\x01r\x03\x04year{\x05month}\x03day}\x04\0\x0aigloo-date\x03\0\x02\x01r\x03\x04\
hour}\x06minute}\x06second}\x04\0\x0aigloo-time\x03\0\x04\x03\0\x18igloo:lib/com\
pound@0.1.0\x05\x01\x02\x03\0\x01\x0bigloo-color\x02\x03\0\x01\x0aigloo-date\x02\
\x03\0\x01\x0aigloo-time\x01B]\x02\x03\x02\x01\x02\x04\0\x0bigloo-color\x03\0\0\x02\
\x03\x02\x01\x03\x04\0\x0aigloo-date\x03\0\x02\x02\x03\x02\x01\x04\x04\0\x0aiglo\
o-time\x03\0\x04\x01m\x07\x06sunday\x06monday\x07tuesday\x09wednesday\x08thursda\
y\x06friday\x08saturday\x04\0\x07weekday\x03\0\x06\x01m\x02\x05r-g-b\x0btemperat\
ure\x04\0\x0acolor-mode\x03\0\x08\x01m\x03\x0bmeasurement\x10total-increasing\x05\
total\x04\0\x12sensor-state-class\x03\0\x0a\x01m\x01\x0cvolt-amperes\x04\0\x13un\
it-apparent-power\x03\0\x0c\x01m\x03\x05watts\x0akilo-watts\x0dbtus-per-hour\x04\
\0\x0aunit-power\x03\0\x0e\x01m\x01\x14volt-ampere-reactive\x04\0\x13unit-reacti\
ve-power\x03\0\x10\x01m\x03\x0awatt-hours\x0fkilo-watt-hours\x0fmega-watt-hours\x04\
\0\x0bunit-energy\x03\0\x12\x01m\x02\x0cmilliamperes\x07amperes\x04\0\x15unit-el\
ectric-current\x03\0\x14\x01m\x02\x0amillivolts\x05volts\x04\0\x17unit-electric-\
potential\x03\0\x16\x01m\x01\x07degrees\x04\0\x0bunit-degree\x03\0\x18\x01m\x03\x05\
euros\x07dollars\x05cents\x04\0\x0dunit-currency\x03\0\x1a\x01m\x03\x07celsius\x0a\
fahrenheit\x06kelvin\x04\0\x10unit-temperature\x03\0\x1c\x01m\x09\x0cmicrosecond\
s\x0cmilliseconds\x07seconds\x07minutes\x05hours\x04days\x05weeks\x06months\x05y\
ears\x04\0\x09unit-time\x03\0\x1e\x01m\x08\x0bmillimeters\x0bcentimeters\x06mete\
rs\x0akilometers\x06inches\x04feet\x04yard\x05miles\x04\0\x0bunit-length\x03\0\x20\
\x01m\x04\x05hertz\x09kilohertz\x09megahertz\x09gigahertz\x04\0\x0eunit-frequenc\
y\x03\0\"\x01m\x09\x06pascal\x0bhectopascal\x0akilopascal\x03bar\x08centibar\x08\
millibar\x12millimeter-mercury\x0cinch-mercury\x03psi\x04\0\x0dunit-pressure\x03\
\0$\x01m\x03\x07decibel\x12decibel-a-weighted\x12decibels-milliwatt\x04\0\x13uni\
t-sound-pressure\x03\0&\x01m\x06\x06liters\x0bmilliliters\x0ccubic-meters\x0acub\
ic-feet\x07gallons\x0bfluid-ounce\x04\0\x0bunit-volume\x03\0(\x01m\x02\x15cubic-\
meters-per-hour\x15cubic-feet-per-minute\x04\0\x15unit-volume-flow-rate\x03\0*\x01\
m\x01\x0dsquare-meters\x04\0\x09unit-area\x03\0,\x01m\x06\x05grams\x09kilograms\x0a\
milligrams\x0amicrograms\x06ounces\x06pounds\x04\0\x09unit-mass\x03\0.\x01m\x01\x1b\
microsiemens-per-centimeter\x04\0\x11unit-conductivity\x03\00\x01m\x01\x03lux\x04\
\0\x0aunit-light\x03\02\x01m\x01\x08uv-index\x04\0\x0dunit-uv-index\x03\04\x01m\x01\
\x0apercentage\x04\0\x0funit-percentage\x03\06\x01m\x02\x16watts-per-square-mete\
r\x19btus-per-hour-square-foot\x04\0\x10unit-irradiation\x03\08\x01m\x06\x1amicr\
ograms-per-cubic-meter\x1amilligrams-per-cubic-meter\x19micrograms-per-cubic-foo\
t\x15parts-per-cubic-meter\x11parts-per-million\x11parts-per-billion\x04\0\x12un\
it-concentration\x03\0:\x01m\x09\x13millimeters-per-day\x14millimeters-per-hour\x0f\
feet-per-second\x0einches-per-day\x11meters-per-second\x0finches-per-hour\x13kil\
ometers-per-hour\x05knots\x0emiles-per-hour\x04\0\x0aunit-speed\x03\0<\x01m\x15\x04\
bits\x08kilobits\x08megabits\x08gigabits\x05bytes\x09kilobytes\x09megabytes\x09g\
igabytes\x09terabytes\x09petabytes\x08exabytes\x0azettabytes\x0ayottabytes\x09ki\
bibytes\x09mebibytes\x09gibibytes\x09tebibytes\x09pebibytes\x09exbibytes\x09zebi\
bytes\x09yobibytes\x04\0\x09unit-data\x03\0>\x01m\x0b\x0fbits-per-second\x13kilo\
bits-per-second\x13megabits-per-second\x13gigabits-per-second\x10bytes-per-secon\
d\x14kilobytes-per-second\x14megabytes-per-second\x14gigabytes-per-second\x14kib\
ibytes-per-second\x14mebibytes-per-second\x14gibibytes-per-second\x04\0\x0eunit-\
data-rate\x03\0@\x01m\x05\x03off\x02on\x08vertical\x0ahorizontal\x04both\x04\0\x0f\
fan-oscillation\x03\0B\x01m\x02\x07forward\x07reverse\x04\0\x0dfan-direction\x03\
\0D\x01m\x0a\x02on\x03off\x04auto\x03low\x06medium\x04high\x06middle\x05focus\x07\
diffuse\x05quiet\x04\0\x09fan-speed\x03\0F\x01m\x08\x03off\x04auto\x04heat\x04co\
ol\x09heat-cool\x08fan-only\x03dry\x03eco\x04\0\x0cclimate-mode\x03\0H\x01m\x06\x07\
unknown\x06locked\x08unlocked\x06jammed\x07locking\x09unlocking\x04\0\x0alock-st\
ate\x03\0J\x01m\x04\x07unknown\x04idle\x07playing\x06paused\x04\0\x0bmedia-state\
\x03\0L\x01m\x06\x04idle\x07opening\x07closing\x07stopped\x04open\x06closed\x04\0\
\x0bcover-state\x03\0N\x01m\x03\x04idle\x07opening\x07closing\x04\0\x0bvalve-sta\
te\x03\0P\x01m\x0a\x08disarmed\x0aarmed-home\x0aarmed-away\x0barmed-night\x0earm\
ed-vacation\x0darmed-unknown\x07pending\x09triggered\x06arming\x09disarming\x04\0\
\x0balarm-state\x03\0R\x01px\x01pu\x01ps\x01p\x7f\x01p\x01\x01p\x03\x01p\x05\x01\
qJ\x07integer\x01x\0\x05float\x01u\0\x06string\x01s\0\x04bool\x01\x7f\0\x05color\
\x01\x01\0\x04date\x01\x03\0\x04time\x01\x05\0\x0cinteger-list\x01\xd4\0\0\x0afl\
oat-list\x01\xd5\0\0\x0bstring-list\x01\xd6\0\0\x0cboolean-list\x01\xd7\0\0\x0ac\
olor-list\x01\xd8\0\0\x09date-list\x01\xd9\0\0\x09time-list\x01\xda\0\0\x07trigg\
er\0\0\x09timestamp\x01x\0\x08duration\x01x\0\x07weekday\x01\x07\0\x05light\0\0\x06\
switch\x01\x7f\0\x06dimmer\x01u\0\x06switch\x01\x7f\0\x0acolor-mode\x01\x09\0\x11\
color-temperature\x01x\0\x06volume\x01u\0\x05muted\x01\x7f\0\x06config\0\0\x0adi\
agnostic\0\0\x05siren\0\0\x06sensor\0\0\x04icon\x01s\0\x11accuracy-decimals\x01x\
\0\x0cdevice-class\x01s\0\x12sensor-state-class\x01\x0b\0\x13unit-apparent-power\
\x01\x0d\0\x0aunit-power\x01\x0f\0\x13unit-reactive-power\x01\x11\0\x0bunit-ener\
gy\x01\x13\0\x15unit-electric-current\x01\x15\0\x17unit-electric-potential\x01\x17\
\0\x0bunit-degree\x01\x19\0\x0dunit-currency\x01\x1b\0\x10unit-temperature\x01\x1d\
\0\x09unit-time\x01\x1f\0\x0bunit-length\x01!\0\x0eunit-frequency\x01#\0\x0dunit\
-pressure\x01%\0\x13unit-sound-pressure\x01'\0\x0bunit-volume\x01)\0\x15unit-vol\
ume-flow-rate\x01+\0\x09unit-area\x01-\0\x09unit-mass\x01/\0\x11unit-conductivit\
y\x011\0\x0aunit-light\x013\0\x0dunit-uv-index\x015\0\x0funit-percentage\x017\0\x10\
unit-irradiation\x019\0\x12unit-concentration\x01;\0\x0aunit-speed\x01=\0\x09uni\
t-data\x01?\0\x0eunit-data-rate\x01\xc1\0\0\x0ffan-oscillation\x01\xc3\0\0\x0dfa\
n-direction\x01\xc5\0\0\x09fan-speed\x01\xc7\0\0\x0cclimate-mode\x01\xc9\0\0\x0a\
lock-state\x01\xcb\0\0\x0bmedia-state\x01\xcd\0\0\x05cover\0\0\x0bcover-state\x01\
\xcf\0\0\x08position\x01u\0\x04tilt\x01u\0\x05valve\0\0\x0bvalve-state\x01\xd1\0\
\0\x0balarm-state\x01\xd3\0\0\x04\0\x09component\x03\0[\x03\0\x19igloo:lib/compo\
nent@0.1.0\x05\x05\x02\x03\0\0\x09device-id\x02\x03\0\0\x0centity-index\x02\x03\0\
\x02\x09component\x01B\x0d\x02\x03\x02\x01\x06\x04\0\x09device-id\x03\0\0\x02\x03\
\x02\x01\x07\x04\0\x0centity-index\x03\0\x02\x02\x03\x02\x01\x08\x04\0\x09compon\
ent\x03\0\x04\x01j\0\x01s\x01C\x03\x09device-id\x01\x0centity-index\x03\x09compo\
nent\x05\0\x06\x04\0\x0dput-component\x01\x07\x01C\x01\x09device-id\x01\0\x06\x04\
\0\x0ddelete-device\x01\x08\x01C\x02\x04names\x06paramss\0\x06\x04\0\x06custom\x01\
\x09\x03\0$igloo:lib/core-to-extension-sp@0.1.0\x05\x09\x01B\x09\x02\x03\x02\x01\
\x07\x04\0\x0centity-index\x03\0\0\x02\x03\x02\x01\x08\x04\0\x09component\x03\0\x02\
\x01j\0\x01s\x01C\x02\x0centity-index\x01\x09component\x03\0\x04\x04\0\x0dput-co\
mponent\x01\x05\x01C\x02\x04names\x06paramss\0\x04\x04\0\x06custom\x01\x06\x03\0\
$igloo:lib/core-to-extension-mp@0.1.0\x05\x0a\x04\0\x14igloo:lib/core@0.1.0\x04\0\
\x0b\x0a\x01\0\x04core\x03\0\0\0G\x09producers\x01\x0cprocessed-by\x02\x0dwit-co\
mponent\x070.244.0\x10wit-bindgen-rust\x060.52.0";

#[inline(never)]
#[doc(hidden)]
pub fn __link_custom_section_describing_imports() {
  wit_bindgen::rt::maybe_link_cabi_realloc();
}

