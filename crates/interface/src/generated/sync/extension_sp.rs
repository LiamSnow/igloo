// Generated by `wit-bindgen` 0.52.0. DO NOT EDIT!
// Options used:
//   * additional derives ["PartialEq", "serde::Serialize", "serde::Deserialize"]
//   * with "igloo:lib/id@0.1.0" = "crate::generated::shared::igloo::lib::id"
//   * with "igloo:lib/compound@0.1.0" = "crate::generated::shared::igloo::lib::compound"
//   * with "igloo:lib/component@0.1.0" = "crate::generated::shared::igloo::lib::component"
//   * generate_unused_types
//   * async: -all
#[allow(unfulfilled_lint_expectations, unused_imports)]
use crate::generated::shared::igloo::lib::id as __with_name0;
#[allow(unfulfilled_lint_expectations, unused_imports)]
use crate::generated::shared::igloo::lib::compound as __with_name1;
#[allow(unfulfilled_lint_expectations, unused_imports)]
use crate::generated::shared::igloo::lib::component as __with_name2;
#[allow(dead_code, clippy::all)]
pub mod igloo {
  pub mod lib {

    #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
    pub mod entity {
      #[used]
      #[doc(hidden)]
      static __FORCE_SECTION_REF: fn() =
      super::super::super::__link_custom_section_describing_imports;
      
      use super::super::super::_rt;
      pub type EntityId = super::super::super::__with_name0::EntityId;
      pub type EntityIndex = super::super::super::__with_name0::EntityIndex;
      pub type Component = super::super::super::__with_name2::Component;
      #[repr(u8)]
      #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd, serde::Deserialize, serde::Serialize)]
      pub enum EntityError {
        InvalidEntity,
      }
      impl EntityError{
        pub fn name(&self) -> &'static str {
          match self {
            EntityError::InvalidEntity => "invalid-entity",
          }
        }
        pub fn message(&self) -> &'static str {
          match self {
            EntityError::InvalidEntity => "",
          }
        }
      }
      impl ::core::fmt::Debug for EntityError{
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("EntityError")
          .field("code", &(*self as i32))
          .field("name", &self.name())
          .field("message", &self.message())
          .finish()
        }
      }
      impl ::core::fmt::Display for EntityError{
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          write!(f, "{} (error {})", self.name(), *self as i32)
        }
      }

      impl ::core::error::Error for EntityError {}

      impl EntityError{
        #[doc(hidden)]
        pub unsafe fn _lift(val: u8) -> EntityError{
          if !cfg!(debug_assertions) {
            return unsafe { ::core::mem::transmute(val) };
          }

          match val {
            0 => EntityError::InvalidEntity,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }


      #[derive(Debug)]
      #[repr(transparent)]
      pub struct Entity{
        handle: _rt::Resource<Entity>,
      }

      impl Entity{
        #[doc(hidden)]
        pub unsafe fn from_handle(handle: u32) -> Self {
          Self {
            handle: unsafe { _rt::Resource::from_handle(handle) },
          }
        }

        #[doc(hidden)]
        pub fn take_handle(&self) -> u32 {
          _rt::Resource::take_handle(&self.handle)
        }

        #[doc(hidden)]
        pub fn handle(&self) -> u32 {
          _rt::Resource::handle(&self.handle)
        }
      }
      

      unsafe impl _rt::WasmResource for Entity{
        #[inline]
        unsafe fn drop(_handle: u32) {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "igloo:lib/entity@0.1.0")]
          unsafe extern "C" {
            #[link_name = "[resource-drop]entity"]
            fn drop(_: i32, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn drop(_: i32, ) { unreachable!() }
          
          unsafe { drop(_handle as i32); }
        }
      }
      
      impl Entity {
        #[allow(unused_unsafe, clippy::all)]
        #[allow(async_fn_in_trait)]
        pub fn id(&self,) -> EntityId{
          unsafe {

            #[cfg_attr(target_pointer_width="64", repr(align(8)))]
            #[cfg_attr(target_pointer_width="32", repr(align(4)))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 2*::core::mem::size_of::<*const u8>()]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2*::core::mem::size_of::<*const u8>()]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "igloo:lib/entity@0.1.0")]
            unsafe extern "C" {
              #[link_name = "[method]entity.id"]
              fn wit_import1(_: i32, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, ) { unreachable!() }
            wit_import1((self).handle() as i32, ptr0);
            let l2 = *ptr0.add(0).cast::<*mut u8>();
            let l3 = *ptr0.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
            let len4 = l3;
            let bytes4 = _rt::Vec::from_raw_parts(l2.cast(), len4, len4);
            let result5 = super::super::super::__with_name0::EntityId{
              inner: _rt::string_lift(bytes4),
            };
            result5
          }
        }
      }
      impl Entity {
        #[allow(unused_unsafe, clippy::all)]
        #[allow(async_fn_in_trait)]
        pub fn index(&self,) -> EntityIndex{
          unsafe {

            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "igloo:lib/entity@0.1.0")]
            unsafe extern "C" {
              #[link_name = "[method]entity.index"]
              fn wit_import0(_: i32, ) -> i64;
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import0(_: i32, ) -> i64 { unreachable!() }
            let ret = wit_import0((self).handle() as i32);
            super::super::super::__with_name0::EntityIndex{
              inner: ret as u64,
            }
          }
        }
      }
      impl Entity {
        #[allow(unused_unsafe, clippy::all)]
        /// Will either put a component on the given entity
        /// or will set the value (if it already exists)
        ///
        /// Fails if this entity is invalid
        #[allow(async_fn_in_trait)]
        pub fn put_component(&self,component: &Component,) -> Result<(),EntityError>{
          unsafe {
            let mut cleanup_list = _rt::Vec::new();

            #[repr(align(1))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 2]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2]);
            use super::super::super::__with_name2::Component as V14;
            let (result15_0,result15_1,result15_2,result15_3,) = match component {
              V14::Integer(e) => (0i32, ::core::mem::MaybeUninit::new(_rt::as_i64(e) as u64), 0i64, 0i64),
              V14::Float(e) => (1i32, ::core::mem::MaybeUninit::new((_rt::as_f64(e)).to_bits() as i64 as u64), 0i64, 0i64),
              V14::String(e) => {
                let vec0 = e;
                let ptr0 = vec0.as_ptr().cast::<u8>();
                let len0 = vec0.len();

                (2i32, {
                  let mut t = ::core::mem::MaybeUninit::<u64>::uninit();
                  t.as_mut_ptr().cast::<*mut u8>().write(ptr0.cast_mut());
                  t
                }, len0 as i64, 0i64)
              },
              V14::Bool(e) => (3i32, ::core::mem::MaybeUninit::new(i64::from(match e { true => 1, false => 0 }) as u64), 0i64, 0i64),
              V14::Color(e) => {
                let super::super::super::__with_name1::IglooColor{ r:r1, g:g1, b:b1, } = e;

                (4i32, ::core::mem::MaybeUninit::new((_rt::as_f64(r1)).to_bits() as i64 as u64), (_rt::as_f64(g1)).to_bits() as i64, (_rt::as_f64(b1)).to_bits() as i64)
              },
              V14::Date(e) => {
                let super::super::super::__with_name1::IglooDate{ year:year2, month:month2, day:day2, } = e;

                (5i32, ::core::mem::MaybeUninit::new(i64::from(_rt::as_i32(year2)) as u64), i64::from(_rt::as_i32(month2)), i64::from(_rt::as_i32(day2)))
              },
              V14::Time(e) => {
                let super::super::super::__with_name1::IglooTime{ hour:hour3, minute:minute3, second:second3, } = e;

                (6i32, ::core::mem::MaybeUninit::new(i64::from(_rt::as_i32(hour3)) as u64), i64::from(_rt::as_i32(minute3)), i64::from(_rt::as_i32(second3)))
              },
              V14::IntegerList(e) => {
                let vec4 = e;
                let ptr4 = vec4.as_ptr().cast::<u8>();
                let len4 = vec4.len();

                (7i32, {
                  let mut t = ::core::mem::MaybeUninit::<u64>::uninit();
                  t.as_mut_ptr().cast::<*mut u8>().write(ptr4.cast_mut());
                  t
                }, len4 as i64, 0i64)
              },
              V14::FloatList(e) => {
                let vec5 = e;
                let ptr5 = vec5.as_ptr().cast::<u8>();
                let len5 = vec5.len();

                (8i32, {
                  let mut t = ::core::mem::MaybeUninit::<u64>::uninit();
                  t.as_mut_ptr().cast::<*mut u8>().write(ptr5.cast_mut());
                  t
                }, len5 as i64, 0i64)
              },
              V14::StringList(e) => {
                let vec7 = e;
                let len7 = vec7.len();
                let layout7 = _rt::alloc::Layout::from_size_align(vec7.len() * (2*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>()).unwrap();
                let (result7, _cleanup7) = wit_bindgen::rt::Cleanup::new(layout7);cleanup_list.extend(_cleanup7);
                for (i, e) in vec7.into_iter().enumerate() {
                  let base = result7.add(i * (2*::core::mem::size_of::<*const u8>()));
                  {
                    let vec6 = e;
                    let ptr6 = vec6.as_ptr().cast::<u8>();
                    let len6 = vec6.len();
                    *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len6;
                    *base.add(0).cast::<*mut u8>() = ptr6.cast_mut();
                  }
                }

                (9i32, {
                  let mut t = ::core::mem::MaybeUninit::<u64>::uninit();
                  t.as_mut_ptr().cast::<*mut u8>().write(result7);
                  t
                }, len7 as i64, 0i64)
              },
              V14::BooleanList(e) => {
                let vec8 = e;
                let len8 = vec8.len();
                let layout8 = _rt::alloc::Layout::from_size_align(vec8.len() * 1, 1).unwrap();
                let (result8, _cleanup8) = wit_bindgen::rt::Cleanup::new(layout8);cleanup_list.extend(_cleanup8);
                for (i, e) in vec8.into_iter().enumerate() {
                  let base = result8.add(i * 1);
                  {
                    *base.add(0).cast::<u8>() = (match e { true => 1, false => 0 }) as u8;
                  }
                }

                (10i32, {
                  let mut t = ::core::mem::MaybeUninit::<u64>::uninit();
                  t.as_mut_ptr().cast::<*mut u8>().write(result8);
                  t
                }, len8 as i64, 0i64)
              },
              V14::ColorList(e) => {
                let vec9 = e;
                let ptr9 = vec9.as_ptr().cast::<u8>();
                let len9 = vec9.len();

                (11i32, {
                  let mut t = ::core::mem::MaybeUninit::<u64>::uninit();
                  t.as_mut_ptr().cast::<*mut u8>().write(ptr9.cast_mut());
                  t
                }, len9 as i64, 0i64)
              },
              V14::DateList(e) => {
                let vec10 = e;
                let ptr10 = vec10.as_ptr().cast::<u8>();
                let len10 = vec10.len();

                (12i32, {
                  let mut t = ::core::mem::MaybeUninit::<u64>::uninit();
                  t.as_mut_ptr().cast::<*mut u8>().write(ptr10.cast_mut());
                  t
                }, len10 as i64, 0i64)
              },
              V14::TimeList(e) => {
                let vec11 = e;
                let ptr11 = vec11.as_ptr().cast::<u8>();
                let len11 = vec11.len();

                (13i32, {
                  let mut t = ::core::mem::MaybeUninit::<u64>::uninit();
                  t.as_mut_ptr().cast::<*mut u8>().write(ptr11.cast_mut());
                  t
                }, len11 as i64, 0i64)
              },
              V14::Trigger=> {
                (14i32, ::core::mem::MaybeUninit::<u64>::zeroed(), 0i64, 0i64)
              }
              V14::Timestamp(e) => (15i32, ::core::mem::MaybeUninit::new(_rt::as_i64(e) as u64), 0i64, 0i64),
              V14::Duration(e) => (16i32, ::core::mem::MaybeUninit::new(_rt::as_i64(e) as u64), 0i64, 0i64),
              V14::Weekday(e) => (17i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
              V14::Light=> {
                (18i32, ::core::mem::MaybeUninit::<u64>::zeroed(), 0i64, 0i64)
              }
              V14::Switch(e) => (19i32, ::core::mem::MaybeUninit::new(i64::from(match e { true => 1, false => 0 }) as u64), 0i64, 0i64),
              V14::Dimmer(e) => (20i32, ::core::mem::MaybeUninit::new((_rt::as_f64(e)).to_bits() as i64 as u64), 0i64, 0i64),
              V14::Switch(e) => (21i32, ::core::mem::MaybeUninit::new(i64::from(match e { true => 1, false => 0 }) as u64), 0i64, 0i64),
              V14::ColorMode(e) => (22i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
              V14::ColorTemperature(e) => (23i32, ::core::mem::MaybeUninit::new(_rt::as_i64(e) as u64), 0i64, 0i64),
              V14::Volume(e) => (24i32, ::core::mem::MaybeUninit::new((_rt::as_f64(e)).to_bits() as i64 as u64), 0i64, 0i64),
              V14::Muted(e) => (25i32, ::core::mem::MaybeUninit::new(i64::from(match e { true => 1, false => 0 }) as u64), 0i64, 0i64),
              V14::Config=> {
                (26i32, ::core::mem::MaybeUninit::<u64>::zeroed(), 0i64, 0i64)
              }
              V14::Diagnostic=> {
                (27i32, ::core::mem::MaybeUninit::<u64>::zeroed(), 0i64, 0i64)
              }
              V14::Siren=> {
                (28i32, ::core::mem::MaybeUninit::<u64>::zeroed(), 0i64, 0i64)
              }
              V14::Sensor=> {
                (29i32, ::core::mem::MaybeUninit::<u64>::zeroed(), 0i64, 0i64)
              }
              V14::Icon(e) => {
                let vec12 = e;
                let ptr12 = vec12.as_ptr().cast::<u8>();
                let len12 = vec12.len();

                (30i32, {
                  let mut t = ::core::mem::MaybeUninit::<u64>::uninit();
                  t.as_mut_ptr().cast::<*mut u8>().write(ptr12.cast_mut());
                  t
                }, len12 as i64, 0i64)
              },
              V14::AccuracyDecimals(e) => (31i32, ::core::mem::MaybeUninit::new(_rt::as_i64(e) as u64), 0i64, 0i64),
              V14::DeviceClass(e) => {
                let vec13 = e;
                let ptr13 = vec13.as_ptr().cast::<u8>();
                let len13 = vec13.len();

                (32i32, {
                  let mut t = ::core::mem::MaybeUninit::<u64>::uninit();
                  t.as_mut_ptr().cast::<*mut u8>().write(ptr13.cast_mut());
                  t
                }, len13 as i64, 0i64)
              },
              V14::SensorStateClass(e) => (33i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
              V14::UnitApparentPower(e) => (34i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
              V14::UnitPower(e) => (35i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
              V14::UnitReactivePower(e) => (36i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
              V14::UnitEnergy(e) => (37i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
              V14::UnitElectricCurrent(e) => (38i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
              V14::UnitElectricPotential(e) => (39i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
              V14::UnitDegree(e) => (40i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
              V14::UnitCurrency(e) => (41i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
              V14::UnitTemperature(e) => (42i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
              V14::UnitTime(e) => (43i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
              V14::UnitLength(e) => (44i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
              V14::UnitFrequency(e) => (45i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
              V14::UnitPressure(e) => (46i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
              V14::UnitSoundPressure(e) => (47i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
              V14::UnitVolume(e) => (48i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
              V14::UnitVolumeFlowRate(e) => (49i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
              V14::UnitArea(e) => (50i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
              V14::UnitMass(e) => (51i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
              V14::UnitConductivity(e) => (52i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
              V14::UnitLight(e) => (53i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
              V14::UnitUvIndex(e) => (54i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
              V14::UnitPercentage(e) => (55i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
              V14::UnitIrradiation(e) => (56i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
              V14::UnitConcentration(e) => (57i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
              V14::UnitSpeed(e) => (58i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
              V14::UnitData(e) => (59i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
              V14::UnitDataRate(e) => (60i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
              V14::FanOscillation(e) => (61i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
              V14::FanDirection(e) => (62i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
              V14::FanSpeed(e) => (63i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
              V14::ClimateMode(e) => (64i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
              V14::LockState(e) => (65i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
              V14::MediaState(e) => (66i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
              V14::Cover=> {
                (67i32, ::core::mem::MaybeUninit::<u64>::zeroed(), 0i64, 0i64)
              }
              V14::CoverState(e) => (68i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
              V14::Position(e) => (69i32, ::core::mem::MaybeUninit::new((_rt::as_f64(e)).to_bits() as i64 as u64), 0i64, 0i64),
              V14::Tilt(e) => (70i32, ::core::mem::MaybeUninit::new((_rt::as_f64(e)).to_bits() as i64 as u64), 0i64, 0i64),
              V14::Valve=> {
                (71i32, ::core::mem::MaybeUninit::<u64>::zeroed(), 0i64, 0i64)
              }
              V14::ValveState(e) => (72i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
              V14::AlarmState(e) => (73i32, ::core::mem::MaybeUninit::new(i64::from(e.clone() as i32) as u64), 0i64, 0i64),
            };
            let ptr16 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "igloo:lib/entity@0.1.0")]
            unsafe extern "C" {
              #[link_name = "[method]entity.put-component"]
              fn wit_import17(_: i32, _: i32, _: ::core::mem::MaybeUninit::<u64>, _: i64, _: i64, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import17(_: i32, _: i32, _: ::core::mem::MaybeUninit::<u64>, _: i64, _: i64, _: *mut u8, ) { unreachable!() }
            wit_import17((self).handle() as i32, result15_0, result15_1, result15_2, result15_3, ptr16);
            let l18 = i32::from(*ptr16.add(0).cast::<u8>());
            let result20 = match l18 {
              0 => {
                let e = ();
                Ok(e)
              }
              1 => {
                let e = {
                  let l19 = i32::from(*ptr16.add(1).cast::<u8>());

                  EntityError::_lift(l19 as u8)
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            };
            result20
          }
        }
      }

    }


    #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
    pub mod extension_sp_to_igloo {
      #[used]
      #[doc(hidden)]
      static __FORCE_SECTION_REF: fn() =
      super::super::super::__link_custom_section_describing_imports;
      
      use super::super::super::_rt;
      pub type DeviceId = super::super::super::__with_name0::DeviceId;
      pub type EntityId = super::super::super::__with_name0::EntityId;
      pub type Component = super::super::super::__with_name2::Component;
      pub type Entity = super::super::super::igloo::lib::entity::Entity;
      #[repr(u8)]
      #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd, serde::Deserialize, serde::Serialize)]
      pub enum DeviceError {
        InvalidDevice,
      }
      impl DeviceError{
        pub fn name(&self) -> &'static str {
          match self {
            DeviceError::InvalidDevice => "invalid-device",
          }
        }
        pub fn message(&self) -> &'static str {
          match self {
            DeviceError::InvalidDevice => "",
          }
        }
      }
      impl ::core::fmt::Debug for DeviceError{
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("DeviceError")
          .field("code", &(*self as i32))
          .field("name", &self.name())
          .field("message", &self.message())
          .finish()
        }
      }
      impl ::core::fmt::Display for DeviceError{
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          write!(f, "{} (error {})", self.name(), *self as i32)
        }
      }

      impl ::core::error::Error for DeviceError {}

      impl DeviceError{
        #[doc(hidden)]
        pub unsafe fn _lift(val: u8) -> DeviceError{
          if !cfg!(debug_assertions) {
            return unsafe { ::core::mem::transmute(val) };
          }

          match val {
            0 => DeviceError::InvalidDevice,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }


      #[derive(Debug)]
      #[repr(transparent)]
      pub struct Device{
        handle: _rt::Resource<Device>,
      }

      impl Device{
        #[doc(hidden)]
        pub unsafe fn from_handle(handle: u32) -> Self {
          Self {
            handle: unsafe { _rt::Resource::from_handle(handle) },
          }
        }

        #[doc(hidden)]
        pub fn take_handle(&self) -> u32 {
          _rt::Resource::take_handle(&self.handle)
        }

        #[doc(hidden)]
        pub fn handle(&self) -> u32 {
          _rt::Resource::handle(&self.handle)
        }
      }
      

      unsafe impl _rt::WasmResource for Device{
        #[inline]
        unsafe fn drop(_handle: u32) {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "igloo:lib/extension-sp-to-igloo@0.1.0")]
          unsafe extern "C" {
            #[link_name = "[resource-drop]device"]
            fn drop(_: i32, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn drop(_: i32, ) { unreachable!() }
          
          unsafe { drop(_handle as i32); }
        }
      }
      
      #[allow(unused_unsafe, clippy::all)]
      /// Get persisted devices
      #[allow(async_fn_in_trait)]
      pub fn get_devices() -> _rt::Vec::<Device>{
        unsafe {

          #[cfg_attr(target_pointer_width="64", repr(align(8)))]
          #[cfg_attr(target_pointer_width="32", repr(align(4)))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 2*::core::mem::size_of::<*const u8>()]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2*::core::mem::size_of::<*const u8>()]);
          let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "igloo:lib/extension-sp-to-igloo@0.1.0")]
          unsafe extern "C" {
            #[link_name = "get-devices"]
            fn wit_import1(_: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn wit_import1(_: *mut u8, ) { unreachable!() }
          wit_import1(ptr0);
          let l2 = *ptr0.add(0).cast::<*mut u8>();
          let l3 = *ptr0.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
          let base5 = l2;
          let len5 = l3;
          let mut result5 = _rt::Vec::with_capacity(len5);
          for i in 0..len5 {
            let base = base5.add(i * 4);
            let e5 = {
              let l4 = *base.add(0).cast::<i32>();

              Device::from_handle(l4 as u32)
            };
            result5.push(e5);
          }
          _rt::cabi_dealloc(base5, len5 * 4, 4);
          let result6 = result5;
          result6
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Get a value from the config for the entire extension
      #[allow(async_fn_in_trait)]
      pub fn get_cfg(key: &str,) -> Option<_rt::String>{
        unsafe {

          #[cfg_attr(target_pointer_width="64", repr(align(8)))]
          #[cfg_attr(target_pointer_width="32", repr(align(4)))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 3*::core::mem::size_of::<*const u8>()]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 3*::core::mem::size_of::<*const u8>()]);
          let vec0 = key;
          let ptr0 = vec0.as_ptr().cast::<u8>();
          let len0 = vec0.len();
          let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "igloo:lib/extension-sp-to-igloo@0.1.0")]
          unsafe extern "C" {
            #[link_name = "get-cfg"]
            fn wit_import2(_: *mut u8, _: usize, _: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn wit_import2(_: *mut u8, _: usize, _: *mut u8, ) { unreachable!() }
          wit_import2(ptr0.cast_mut(), len0, ptr1);
          let l3 = i32::from(*ptr1.add(0).cast::<u8>());
          let result7 = match l3 {
            0 => None,
            1 => {
              let e = {
                let l4 = *ptr1.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                let l5 = *ptr1.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>();
                let len6 = l5;
                let bytes6 = _rt::Vec::from_raw_parts(l4.cast(), len6, len6);

                _rt::string_lift(bytes6)
              };
              Some(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          };
          result7
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Save a value to the config for the entire extension
      #[allow(async_fn_in_trait)]
      pub fn save_cfg(key: &str,value: &str,) -> (){
        unsafe {
          let vec0 = key;
          let ptr0 = vec0.as_ptr().cast::<u8>();
          let len0 = vec0.len();
          let vec1 = value;
          let ptr1 = vec1.as_ptr().cast::<u8>();
          let len1 = vec1.len();

          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "igloo:lib/extension-sp-to-igloo@0.1.0")]
          unsafe extern "C" {
            #[link_name = "save-cfg"]
            fn wit_import2(_: *mut u8, _: usize, _: *mut u8, _: usize, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn wit_import2(_: *mut u8, _: usize, _: *mut u8, _: usize, ) { unreachable!() }
          wit_import2(ptr0.cast_mut(), len0, ptr1.cast_mut(), len1);
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Remove a value from the config for the entire extension
      #[allow(async_fn_in_trait)]
      pub fn remove_cfg(key: &str,) -> (){
        unsafe {
          let vec0 = key;
          let ptr0 = vec0.as_ptr().cast::<u8>();
          let len0 = vec0.len();

          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "igloo:lib/extension-sp-to-igloo@0.1.0")]
          unsafe extern "C" {
            #[link_name = "remove-cfg"]
            fn wit_import1(_: *mut u8, _: usize, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn wit_import1(_: *mut u8, _: usize, ) { unreachable!() }
          wit_import1(ptr0.cast_mut(), len0);
        }
      }
      impl Device {
        #[allow(unused_unsafe, clippy::all)]
        /// Requests to register new device with Igloo
        /// Infallible
        #[allow(async_fn_in_trait)]
        pub fn new(name: &str,) -> Self{
          unsafe {
            let vec0 = name;
            let ptr0 = vec0.as_ptr().cast::<u8>();
            let len0 = vec0.len();

            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "igloo:lib/extension-sp-to-igloo@0.1.0")]
            unsafe extern "C" {
              #[link_name = "[constructor]device"]
              fn wit_import1(_: *mut u8, _: usize, ) -> i32;
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import1(_: *mut u8, _: usize, ) -> i32 { unreachable!() }
            let ret = wit_import1(ptr0.cast_mut(), len0);
            Device::from_handle(ret as u32)
          }
        }
      }
      impl Device {
        #[allow(unused_unsafe, clippy::all)]
        /// Returns the ID of the device
        #[allow(async_fn_in_trait)]
        pub fn id(&self,) -> Result<DeviceId,DeviceError>{
          unsafe {

            #[repr(align(8))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 16]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 16]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "igloo:lib/extension-sp-to-igloo@0.1.0")]
            unsafe extern "C" {
              #[link_name = "[method]device.id"]
              fn wit_import1(_: i32, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, ) { unreachable!() }
            wit_import1((self).handle() as i32, ptr0);
            let l2 = i32::from(*ptr0.add(0).cast::<u8>());
            let result5 = match l2 {
              0 => {
                let e = {
                  let l3 = *ptr0.add(8).cast::<i64>();

                  super::super::super::__with_name0::DeviceId{
                    packed: l3 as u64,
                  }
                };
                Ok(e)
              }
              1 => {
                let e = {
                  let l4 = i32::from(*ptr0.add(8).cast::<u8>());

                  DeviceError::_lift(l4 as u8)
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            };
            result5
          }
        }
      }
      impl Device {
        #[allow(unused_unsafe, clippy::all)]
        /// Get a value from the config for this device
        #[allow(async_fn_in_trait)]
        pub fn get_cfg(&self,key: &str,) -> Result<Option<_rt::String>,DeviceError>{
          unsafe {

            #[cfg_attr(target_pointer_width="64", repr(align(8)))]
            #[cfg_attr(target_pointer_width="32", repr(align(4)))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 4*::core::mem::size_of::<*const u8>()]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 4*::core::mem::size_of::<*const u8>()]);
            let vec0 = key;
            let ptr0 = vec0.as_ptr().cast::<u8>();
            let len0 = vec0.len();
            let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "igloo:lib/extension-sp-to-igloo@0.1.0")]
            unsafe extern "C" {
              #[link_name = "[method]device.get-cfg"]
              fn wit_import2(_: i32, _: *mut u8, _: usize, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import2(_: i32, _: *mut u8, _: usize, _: *mut u8, ) { unreachable!() }
            wit_import2((self).handle() as i32, ptr0.cast_mut(), len0, ptr1);
            let l3 = i32::from(*ptr1.add(0).cast::<u8>());
            let result9 = match l3 {
              0 => {
                let e = {
                  let l4 = i32::from(*ptr1.add(::core::mem::size_of::<*const u8>()).cast::<u8>());

                  match l4 {
                    0 => None,
                    1 => {
                      let e = {
                        let l5 = *ptr1.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                        let l6 = *ptr1.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>();
                        let len7 = l6;
                        let bytes7 = _rt::Vec::from_raw_parts(l5.cast(), len7, len7);

                        _rt::string_lift(bytes7)
                      };
                      Some(e)
                    }
                    _ => _rt::invalid_enum_discriminant(),
                  }
                };
                Ok(e)
              }
              1 => {
                let e = {
                  let l8 = i32::from(*ptr1.add(::core::mem::size_of::<*const u8>()).cast::<u8>());

                  DeviceError::_lift(l8 as u8)
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            };
            result9
          }
        }
      }
      impl Device {
        #[allow(unused_unsafe, clippy::all)]
        /// Save a value to the config for this device
        #[allow(async_fn_in_trait)]
        pub fn save_cfg(&self,key: &str,value: &str,) -> Result<(),DeviceError>{
          unsafe {

            #[repr(align(1))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 2]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2]);
            let vec0 = key;
            let ptr0 = vec0.as_ptr().cast::<u8>();
            let len0 = vec0.len();
            let vec1 = value;
            let ptr1 = vec1.as_ptr().cast::<u8>();
            let len1 = vec1.len();
            let ptr2 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "igloo:lib/extension-sp-to-igloo@0.1.0")]
            unsafe extern "C" {
              #[link_name = "[method]device.save-cfg"]
              fn wit_import3(_: i32, _: *mut u8, _: usize, _: *mut u8, _: usize, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import3(_: i32, _: *mut u8, _: usize, _: *mut u8, _: usize, _: *mut u8, ) { unreachable!() }
            wit_import3((self).handle() as i32, ptr0.cast_mut(), len0, ptr1.cast_mut(), len1, ptr2);
            let l4 = i32::from(*ptr2.add(0).cast::<u8>());
            let result6 = match l4 {
              0 => {
                let e = ();
                Ok(e)
              }
              1 => {
                let e = {
                  let l5 = i32::from(*ptr2.add(1).cast::<u8>());

                  DeviceError::_lift(l5 as u8)
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            };
            result6
          }
        }
      }
      impl Device {
        #[allow(unused_unsafe, clippy::all)]
        /// Remove a value from the config for this device
        #[allow(async_fn_in_trait)]
        pub fn remove_cfg(&self,key: &str,) -> Result<(),DeviceError>{
          unsafe {

            #[repr(align(1))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 2]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2]);
            let vec0 = key;
            let ptr0 = vec0.as_ptr().cast::<u8>();
            let len0 = vec0.len();
            let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "igloo:lib/extension-sp-to-igloo@0.1.0")]
            unsafe extern "C" {
              #[link_name = "[method]device.remove-cfg"]
              fn wit_import2(_: i32, _: *mut u8, _: usize, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import2(_: i32, _: *mut u8, _: usize, _: *mut u8, ) { unreachable!() }
            wit_import2((self).handle() as i32, ptr0.cast_mut(), len0, ptr1);
            let l3 = i32::from(*ptr1.add(0).cast::<u8>());
            let result5 = match l3 {
              0 => {
                let e = ();
                Ok(e)
              }
              1 => {
                let e = {
                  let l4 = i32::from(*ptr1.add(1).cast::<u8>());

                  DeviceError::_lift(l4 as u8)
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            };
            result5
          }
        }
      }
      impl Device {
        #[allow(unused_unsafe, clippy::all)]
        /// Register an entity under this device
        /// Fails if the device is invalid
        #[allow(async_fn_in_trait)]
        pub fn register_entity(&self,id: &EntityId,) -> Result<Entity,DeviceError>{
          unsafe {

            #[repr(align(4))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 8]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 8]);
            let super::super::super::__with_name0::EntityId{ inner:inner0, } = id;
            let vec1 = inner0;
            let ptr1 = vec1.as_ptr().cast::<u8>();
            let len1 = vec1.len();
            let ptr2 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "igloo:lib/extension-sp-to-igloo@0.1.0")]
            unsafe extern "C" {
              #[link_name = "[method]device.register-entity"]
              fn wit_import3(_: i32, _: *mut u8, _: usize, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import3(_: i32, _: *mut u8, _: usize, _: *mut u8, ) { unreachable!() }
            wit_import3((self).handle() as i32, ptr1.cast_mut(), len1, ptr2);
            let l4 = i32::from(*ptr2.add(0).cast::<u8>());
            let result7 = match l4 {
              0 => {
                let e = {
                  let l5 = *ptr2.add(4).cast::<i32>();

                  super::super::super::igloo::lib::entity::Entity::from_handle(l5 as u32)
                };
                Ok(e)
              }
              1 => {
                let e = {
                  let l6 = i32::from(*ptr2.add(4).cast::<u8>());

                  DeviceError::_lift(l6 as u8)
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            };
            result7
          }
        }
      }

    }

  }
}
#[allow(dead_code, clippy::all)]
pub mod wasi {
  pub mod cli {

    #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
    pub mod environment {
      #[used]
      #[doc(hidden)]
      static __FORCE_SECTION_REF: fn() =
      super::super::super::__link_custom_section_describing_imports;
      
      use super::super::super::_rt;
      #[allow(unused_unsafe, clippy::all)]
      /// Get the POSIX-style environment variables.
      ///
      /// Each environment variable is provided as a pair of string variable names
      /// and string value.
      ///
      /// Morally, these are a value import, but until value imports are available
      /// in the component model, this import function should return the same
      /// values each time it is called.
      #[allow(async_fn_in_trait)]
      pub fn get_environment() -> _rt::Vec::<(_rt::String,_rt::String,)>{
        unsafe {

          #[cfg_attr(target_pointer_width="64", repr(align(8)))]
          #[cfg_attr(target_pointer_width="32", repr(align(4)))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 2*::core::mem::size_of::<*const u8>()]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2*::core::mem::size_of::<*const u8>()]);
          let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:cli/environment@0.3.0-rc-2026-01-06")]
          unsafe extern "C" {
            #[link_name = "get-environment"]
            fn wit_import1(_: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn wit_import1(_: *mut u8, ) { unreachable!() }
          wit_import1(ptr0);
          let l2 = *ptr0.add(0).cast::<*mut u8>();
          let l3 = *ptr0.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
          let base10 = l2;
          let len10 = l3;
          let mut result10 = _rt::Vec::with_capacity(len10);
          for i in 0..len10 {
            let base = base10.add(i * (4*::core::mem::size_of::<*const u8>()));
            let e10 = {
              let l4 = *base.add(0).cast::<*mut u8>();
              let l5 = *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
              let len6 = l5;
              let bytes6 = _rt::Vec::from_raw_parts(l4.cast(), len6, len6);
              let l7 = *base.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
              let l8 = *base.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>();
              let len9 = l8;
              let bytes9 = _rt::Vec::from_raw_parts(l7.cast(), len9, len9);

              (_rt::string_lift(bytes6), _rt::string_lift(bytes9))
            };
            result10.push(e10);
          }
          _rt::cabi_dealloc(base10, len10 * (4*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>());
          let result11 = result10;
          result11
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Get the POSIX-style arguments to the program.
      #[allow(async_fn_in_trait)]
      pub fn get_arguments() -> _rt::Vec::<_rt::String>{
        unsafe {

          #[cfg_attr(target_pointer_width="64", repr(align(8)))]
          #[cfg_attr(target_pointer_width="32", repr(align(4)))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 2*::core::mem::size_of::<*const u8>()]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2*::core::mem::size_of::<*const u8>()]);
          let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:cli/environment@0.3.0-rc-2026-01-06")]
          unsafe extern "C" {
            #[link_name = "get-arguments"]
            fn wit_import1(_: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn wit_import1(_: *mut u8, ) { unreachable!() }
          wit_import1(ptr0);
          let l2 = *ptr0.add(0).cast::<*mut u8>();
          let l3 = *ptr0.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
          let base7 = l2;
          let len7 = l3;
          let mut result7 = _rt::Vec::with_capacity(len7);
          for i in 0..len7 {
            let base = base7.add(i * (2*::core::mem::size_of::<*const u8>()));
            let e7 = {
              let l4 = *base.add(0).cast::<*mut u8>();
              let l5 = *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
              let len6 = l5;
              let bytes6 = _rt::Vec::from_raw_parts(l4.cast(), len6, len6);

              _rt::string_lift(bytes6)
            };
            result7.push(e7);
          }
          _rt::cabi_dealloc(base7, len7 * (2*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>());
          let result8 = result7;
          result8
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Return a path that programs should use as their initial current working
      /// directory, interpreting `.` as shorthand for this.
      #[allow(async_fn_in_trait)]
      pub fn get_initial_cwd() -> Option<_rt::String>{
        unsafe {

          #[cfg_attr(target_pointer_width="64", repr(align(8)))]
          #[cfg_attr(target_pointer_width="32", repr(align(4)))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 3*::core::mem::size_of::<*const u8>()]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 3*::core::mem::size_of::<*const u8>()]);
          let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:cli/environment@0.3.0-rc-2026-01-06")]
          unsafe extern "C" {
            #[link_name = "get-initial-cwd"]
            fn wit_import1(_: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn wit_import1(_: *mut u8, ) { unreachable!() }
          wit_import1(ptr0);
          let l2 = i32::from(*ptr0.add(0).cast::<u8>());
          let result6 = match l2 {
            0 => None,
            1 => {
              let e = {
                let l3 = *ptr0.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                let l4 = *ptr0.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>();
                let len5 = l4;
                let bytes5 = _rt::Vec::from_raw_parts(l3.cast(), len5, len5);

                _rt::string_lift(bytes5)
              };
              Some(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          };
          result6
        }
      }

    }


    #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
    pub mod exit {
      #[used]
      #[doc(hidden)]
      static __FORCE_SECTION_REF: fn() =
      super::super::super::__link_custom_section_describing_imports;
      
      #[allow(unused_unsafe, clippy::all)]
      /// Exit the current instance and any linked instances.
      #[allow(async_fn_in_trait)]
      pub fn exit(status: Result<(),()>,) -> (){
        unsafe {
          let result0 = match status {
            Ok(_) => { 0i32 },
            Err(_) => { 1i32 },
          };
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:cli/exit@0.3.0-rc-2026-01-06")]
          unsafe extern "C" {
            #[link_name = "exit"]
            fn wit_import1(_: i32, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn wit_import1(_: i32, ) { unreachable!() }
          wit_import1(result0);
        }
      }

    }


    #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
    pub mod types {
      #[used]
      #[doc(hidden)]
      static __FORCE_SECTION_REF: fn() =
      super::super::super::__link_custom_section_describing_imports;
      
      #[repr(u8)]
      #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd, serde::Deserialize, serde::Serialize)]
      pub enum ErrorCode {
        /// Input/output error
        Io,
        /// Invalid or incomplete multibyte or wide character
        IllegalByteSequence,
        /// Broken pipe
        Pipe,
      }
      impl ErrorCode{
        pub fn name(&self) -> &'static str {
          match self {
            ErrorCode::Io => "io",
            ErrorCode::IllegalByteSequence => "illegal-byte-sequence",
            ErrorCode::Pipe => "pipe",
          }
        }
        pub fn message(&self) -> &'static str {
          match self {
            ErrorCode::Io => "Input/output error",
            ErrorCode::IllegalByteSequence => "Invalid or incomplete multibyte or wide character",
            ErrorCode::Pipe => "Broken pipe",
          }
        }
      }
      impl ::core::fmt::Debug for ErrorCode{
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("ErrorCode")
          .field("code", &(*self as i32))
          .field("name", &self.name())
          .field("message", &self.message())
          .finish()
        }
      }
      impl ::core::fmt::Display for ErrorCode{
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          write!(f, "{} (error {})", self.name(), *self as i32)
        }
      }

      impl ::core::error::Error for ErrorCode {}

      impl ErrorCode{
        #[doc(hidden)]
        pub unsafe fn _lift(val: u8) -> ErrorCode{
          if !cfg!(debug_assertions) {
            return unsafe { ::core::mem::transmute(val) };
          }

          match val {
            0 => ErrorCode::Io,
            1 => ErrorCode::IllegalByteSequence,
            2 => ErrorCode::Pipe,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }


    }


    #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
    pub mod stdin {
      #[used]
      #[doc(hidden)]
      static __FORCE_SECTION_REF: fn() =
      super::super::super::__link_custom_section_describing_imports;
      
      use super::super::super::_rt;
      pub type ErrorCode = super::super::super::wasi::cli::types::ErrorCode;
      #[allow(unused_unsafe, clippy::all)]
      /// Return a stream for reading from stdin.
      ///
      /// This function returns a stream which provides data read from stdin,
      /// and a future to signal read results.
      ///
      /// If the stream's readable end is dropped the future will resolve to success.
      ///
      /// If the stream's writable end is dropped the future will either resolve to
      /// success if stdin was closed by the writer or to an error-code if reading
      /// failed for some other reason.
      ///
      /// Multiple streams may be active at the same time. The behavior of concurrent
      /// reads is implementation-specific.
      #[allow(async_fn_in_trait)]
      pub fn read_via_stream() -> (wit_bindgen::rt::async_support::StreamReader<u8>,wit_bindgen::rt::async_support::FutureReader<Result<(),ErrorCode>>,){
        unsafe {

          #[repr(align(4))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 8]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 8]);
          let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:cli/stdin@0.3.0-rc-2026-01-06")]
          unsafe extern "C" {
            #[link_name = "read-via-stream"]
            fn wit_import1(_: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn wit_import1(_: *mut u8, ) { unreachable!() }
          wit_import1(ptr0);
          let l2 = *ptr0.add(0).cast::<i32>();
          let l3 = *ptr0.add(4).cast::<i32>();
          let result4 = (wit_bindgen::rt::async_support::StreamReader::new(l2 as u32, &super::super::super::wit_stream::vtable0::VTABLE), wit_bindgen::rt::async_support::FutureReader::new(l3 as u32, &super::super::super::wit_future::vtable0::VTABLE));
          result4
        }
      }

    }


    #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
    pub mod stdout {
      #[used]
      #[doc(hidden)]
      static __FORCE_SECTION_REF: fn() =
      super::super::super::__link_custom_section_describing_imports;
      
      use super::super::super::_rt;
      pub type ErrorCode = super::super::super::wasi::cli::types::ErrorCode;
      #[allow(unused_unsafe, clippy::all)]
      /// Write the given stream to stdout.
      ///
      /// If the stream's writable end is dropped this function will either return
      /// success once the entire contents of the stream have been written or an
      /// error-code representing a failure.
      ///
      /// Otherwise if there is an error the readable end of the stream will be
      /// dropped and this function will return an error-code.
      #[allow(async_fn_in_trait)]
      pub fn write_via_stream(data: wit_bindgen::rt::async_support::StreamReader<u8>,) -> Result<(),ErrorCode>{
        unsafe {

          #[repr(align(1))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 2]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2]);
          let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:cli/stdout@0.3.0-rc-2026-01-06")]
          unsafe extern "C" {
            #[link_name = "write-via-stream"]
            fn wit_import1(_: i32, _: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, ) { unreachable!() }
          wit_import1((&data).take_handle() as i32, ptr0);
          let l2 = i32::from(*ptr0.add(0).cast::<u8>());
          let result4 = match l2 {
            0 => {
              let e = ();
              Ok(e)
            }
            1 => {
              let e = {
                let l3 = i32::from(*ptr0.add(1).cast::<u8>());

                super::super::super::wasi::cli::types::ErrorCode::_lift(l3 as u8)
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          };
          result4
        }
      }

    }


    #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
    pub mod stderr {
      #[used]
      #[doc(hidden)]
      static __FORCE_SECTION_REF: fn() =
      super::super::super::__link_custom_section_describing_imports;
      
      use super::super::super::_rt;
      pub type ErrorCode = super::super::super::wasi::cli::types::ErrorCode;
      #[allow(unused_unsafe, clippy::all)]
      /// Write the given stream to stderr.
      ///
      /// If the stream's writable end is dropped this function will either return
      /// success once the entire contents of the stream have been written or an
      /// error-code representing a failure.
      ///
      /// Otherwise if there is an error the readable end of the stream will be
      /// dropped and this function will return an error-code.
      #[allow(async_fn_in_trait)]
      pub fn write_via_stream(data: wit_bindgen::rt::async_support::StreamReader<u8>,) -> Result<(),ErrorCode>{
        unsafe {

          #[repr(align(1))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 2]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2]);
          let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:cli/stderr@0.3.0-rc-2026-01-06")]
          unsafe extern "C" {
            #[link_name = "write-via-stream"]
            fn wit_import1(_: i32, _: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, ) { unreachable!() }
          wit_import1((&data).take_handle() as i32, ptr0);
          let l2 = i32::from(*ptr0.add(0).cast::<u8>());
          let result4 = match l2 {
            0 => {
              let e = ();
              Ok(e)
            }
            1 => {
              let e = {
                let l3 = i32::from(*ptr0.add(1).cast::<u8>());

                super::super::super::wasi::cli::types::ErrorCode::_lift(l3 as u8)
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          };
          result4
        }
      }

    }

    /// Terminal input.
    ///
    /// In the future, this may include functions for disabling echoing,
    /// disabling input buffering so that keyboard events are sent through
    /// immediately, querying supported features, and so on.
    #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
    pub mod terminal_input {
      #[used]
      #[doc(hidden)]
      static __FORCE_SECTION_REF: fn() =
      super::super::super::__link_custom_section_describing_imports;
      
      use super::super::super::_rt;
      /// The input side of a terminal.

      #[derive(Debug)]
      #[repr(transparent)]
      pub struct TerminalInput{
        handle: _rt::Resource<TerminalInput>,
      }

      impl TerminalInput{
        #[doc(hidden)]
        pub unsafe fn from_handle(handle: u32) -> Self {
          Self {
            handle: unsafe { _rt::Resource::from_handle(handle) },
          }
        }

        #[doc(hidden)]
        pub fn take_handle(&self) -> u32 {
          _rt::Resource::take_handle(&self.handle)
        }

        #[doc(hidden)]
        pub fn handle(&self) -> u32 {
          _rt::Resource::handle(&self.handle)
        }
      }
      

      unsafe impl _rt::WasmResource for TerminalInput{
        #[inline]
        unsafe fn drop(_handle: u32) {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:cli/terminal-input@0.3.0-rc-2026-01-06")]
          unsafe extern "C" {
            #[link_name = "[resource-drop]terminal-input"]
            fn drop(_: i32, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn drop(_: i32, ) { unreachable!() }
          
          unsafe { drop(_handle as i32); }
        }
      }
      

    }

    /// Terminal output.
    ///
    /// In the future, this may include functions for querying the terminal
    /// size, being notified of terminal size changes, querying supported
    /// features, and so on.
    #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
    pub mod terminal_output {
      #[used]
      #[doc(hidden)]
      static __FORCE_SECTION_REF: fn() =
      super::super::super::__link_custom_section_describing_imports;
      
      use super::super::super::_rt;
      /// The output side of a terminal.

      #[derive(Debug)]
      #[repr(transparent)]
      pub struct TerminalOutput{
        handle: _rt::Resource<TerminalOutput>,
      }

      impl TerminalOutput{
        #[doc(hidden)]
        pub unsafe fn from_handle(handle: u32) -> Self {
          Self {
            handle: unsafe { _rt::Resource::from_handle(handle) },
          }
        }

        #[doc(hidden)]
        pub fn take_handle(&self) -> u32 {
          _rt::Resource::take_handle(&self.handle)
        }

        #[doc(hidden)]
        pub fn handle(&self) -> u32 {
          _rt::Resource::handle(&self.handle)
        }
      }
      

      unsafe impl _rt::WasmResource for TerminalOutput{
        #[inline]
        unsafe fn drop(_handle: u32) {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:cli/terminal-output@0.3.0-rc-2026-01-06")]
          unsafe extern "C" {
            #[link_name = "[resource-drop]terminal-output"]
            fn drop(_: i32, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn drop(_: i32, ) { unreachable!() }
          
          unsafe { drop(_handle as i32); }
        }
      }
      

    }

    /// An interface providing an optional `terminal-input` for stdin as a
    /// link-time authority.
    #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
    pub mod terminal_stdin {
      #[used]
      #[doc(hidden)]
      static __FORCE_SECTION_REF: fn() =
      super::super::super::__link_custom_section_describing_imports;
      
      use super::super::super::_rt;
      pub type TerminalInput = super::super::super::wasi::cli::terminal_input::TerminalInput;
      #[allow(unused_unsafe, clippy::all)]
      /// If stdin is connected to a terminal, return a `terminal-input` handle
      /// allowing further interaction with it.
      #[allow(async_fn_in_trait)]
      pub fn get_terminal_stdin() -> Option<TerminalInput>{
        unsafe {

          #[repr(align(4))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 8]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 8]);
          let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:cli/terminal-stdin@0.3.0-rc-2026-01-06")]
          unsafe extern "C" {
            #[link_name = "get-terminal-stdin"]
            fn wit_import1(_: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn wit_import1(_: *mut u8, ) { unreachable!() }
          wit_import1(ptr0);
          let l2 = i32::from(*ptr0.add(0).cast::<u8>());
          let result4 = match l2 {
            0 => None,
            1 => {
              let e = {
                let l3 = *ptr0.add(4).cast::<i32>();

                super::super::super::wasi::cli::terminal_input::TerminalInput::from_handle(l3 as u32)
              };
              Some(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          };
          result4
        }
      }

    }

    /// An interface providing an optional `terminal-output` for stdout as a
    /// link-time authority.
    #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
    pub mod terminal_stdout {
      #[used]
      #[doc(hidden)]
      static __FORCE_SECTION_REF: fn() =
      super::super::super::__link_custom_section_describing_imports;
      
      use super::super::super::_rt;
      pub type TerminalOutput = super::super::super::wasi::cli::terminal_output::TerminalOutput;
      #[allow(unused_unsafe, clippy::all)]
      /// If stdout is connected to a terminal, return a `terminal-output` handle
      /// allowing further interaction with it.
      #[allow(async_fn_in_trait)]
      pub fn get_terminal_stdout() -> Option<TerminalOutput>{
        unsafe {

          #[repr(align(4))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 8]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 8]);
          let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:cli/terminal-stdout@0.3.0-rc-2026-01-06")]
          unsafe extern "C" {
            #[link_name = "get-terminal-stdout"]
            fn wit_import1(_: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn wit_import1(_: *mut u8, ) { unreachable!() }
          wit_import1(ptr0);
          let l2 = i32::from(*ptr0.add(0).cast::<u8>());
          let result4 = match l2 {
            0 => None,
            1 => {
              let e = {
                let l3 = *ptr0.add(4).cast::<i32>();

                super::super::super::wasi::cli::terminal_output::TerminalOutput::from_handle(l3 as u32)
              };
              Some(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          };
          result4
        }
      }

    }

    /// An interface providing an optional `terminal-output` for stderr as a
    /// link-time authority.
    #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
    pub mod terminal_stderr {
      #[used]
      #[doc(hidden)]
      static __FORCE_SECTION_REF: fn() =
      super::super::super::__link_custom_section_describing_imports;
      
      use super::super::super::_rt;
      pub type TerminalOutput = super::super::super::wasi::cli::terminal_output::TerminalOutput;
      #[allow(unused_unsafe, clippy::all)]
      /// If stderr is connected to a terminal, return a `terminal-output` handle
      /// allowing further interaction with it.
      #[allow(async_fn_in_trait)]
      pub fn get_terminal_stderr() -> Option<TerminalOutput>{
        unsafe {

          #[repr(align(4))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 8]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 8]);
          let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:cli/terminal-stderr@0.3.0-rc-2026-01-06")]
          unsafe extern "C" {
            #[link_name = "get-terminal-stderr"]
            fn wit_import1(_: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn wit_import1(_: *mut u8, ) { unreachable!() }
          wit_import1(ptr0);
          let l2 = i32::from(*ptr0.add(0).cast::<u8>());
          let result4 = match l2 {
            0 => None,
            1 => {
              let e = {
                let l3 = *ptr0.add(4).cast::<i32>();

                super::super::super::wasi::cli::terminal_output::TerminalOutput::from_handle(l3 as u32)
              };
              Some(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          };
          result4
        }
      }

    }

  }
  pub mod clocks {
    /// This interface common types used throughout wasi:clocks.
    #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
    pub mod types {
      #[used]
      #[doc(hidden)]
      static __FORCE_SECTION_REF: fn() =
      super::super::super::__link_custom_section_describing_imports;
      
      /// A duration of time, in nanoseconds.
      pub type Duration = u64;

    }

    /// WASI Monotonic Clock is a clock API intended to let users measure elapsed
    /// time.
    ///
    /// It is intended to be portable at least between Unix-family platforms and
    /// Windows.
    ///
    /// A monotonic clock is a clock which has an unspecified initial value, and
    /// successive reads of the clock will produce non-decreasing values.
    #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
    pub mod monotonic_clock {
      #[used]
      #[doc(hidden)]
      static __FORCE_SECTION_REF: fn() =
      super::super::super::__link_custom_section_describing_imports;
      
      use super::super::super::_rt;
      pub type Duration = super::super::super::wasi::clocks::types::Duration;
      /// A mark on a monotonic clock is a number of nanoseconds since an
      /// unspecified initial value, and can only be compared to instances from
      /// the same monotonic-clock.
      pub type Mark = u64;
      #[allow(unused_unsafe, clippy::all)]
      /// Read the current value of the clock.
      ///
      /// The clock is monotonic, therefore calling this function repeatedly will
      /// produce a sequence of non-decreasing values.
      ///
      /// For completeness, this function traps if it's not possible to represent
      /// the value of the clock in a `mark`. Consequently, implementations
      /// should ensure that the starting time is low enough to avoid the
      /// possibility of overflow in practice.
      #[allow(async_fn_in_trait)]
      pub fn now() -> Mark{
        unsafe {

          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:clocks/monotonic-clock@0.3.0-rc-2026-01-06")]
          unsafe extern "C" {
            #[link_name = "now"]
            fn wit_import0() -> i64;
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn wit_import0() -> i64 { unreachable!() }
          let ret = wit_import0();
          ret as u64
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Query the resolution of the clock. Returns the duration of time
      /// corresponding to a clock tick.
      #[allow(async_fn_in_trait)]
      pub fn get_resolution() -> Duration{
        unsafe {

          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:clocks/monotonic-clock@0.3.0-rc-2026-01-06")]
          unsafe extern "C" {
            #[link_name = "get-resolution"]
            fn wit_import0() -> i64;
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn wit_import0() -> i64 { unreachable!() }
          let ret = wit_import0();
          ret as u64
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Wait until the specified mark has occurred.
      #[allow(async_fn_in_trait)]
      pub fn wait_until(when: Mark,) -> (){
        unsafe {

          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:clocks/monotonic-clock@0.3.0-rc-2026-01-06")]
          unsafe extern "C" {
            #[link_name = "wait-until"]
            fn wit_import0(_: i64, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn wit_import0(_: i64, ) { unreachable!() }
          wit_import0(_rt::as_i64(when));
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Wait for the specified duration to elapse.
      #[allow(async_fn_in_trait)]
      pub fn wait_for(how_long: Duration,) -> (){
        unsafe {

          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:clocks/monotonic-clock@0.3.0-rc-2026-01-06")]
          unsafe extern "C" {
            #[link_name = "wait-for"]
            fn wit_import0(_: i64, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn wit_import0(_: i64, ) { unreachable!() }
          wit_import0(_rt::as_i64(how_long));
        }
      }

    }

    /// WASI System Clock is a clock API intended to let users query the current
    /// time. The clock is not necessarily monotonic as it may be reset.
    ///
    /// It is intended to be portable at least between Unix-family platforms and
    /// Windows.
    ///
    /// External references may be reset, so this clock is not necessarily
    /// monotonic, making it unsuitable for measuring elapsed time.
    ///
    /// It is intended for reporting the current date and time for humans.
    #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
    pub mod system_clock {
      #[used]
      #[doc(hidden)]
      static __FORCE_SECTION_REF: fn() =
      super::super::super::__link_custom_section_describing_imports;
      
      pub type Duration = super::super::super::wasi::clocks::types::Duration;
      /// An "instant", or "exact time", is a point in time without regard to any
      /// time zone: just the time since a particular external reference point,
      /// often called an "epoch".
      ///
      /// Here, the epoch is 1970-01-01T00:00:00Z, also known as
      /// [POSIX's Seconds Since the Epoch], also known as [Unix Time].
      ///
      /// Note that even if the seconds field is negative, incrementing
      /// nanoseconds always represents moving forwards in time.
      /// For example, `{ -1 seconds, 999999999 nanoseconds }` represents the
      /// instant one nanosecond before the epoch.
      /// For more on various different ways to represent time, see
      /// https://tc39.es/proposal-temporal/docs/timezone.html
      ///
      /// [POSIX's Seconds Since the Epoch]: https://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_xbd_chap04.html#tag_21_04_16
      /// [Unix Time]: https://en.wikipedia.org/wiki/Unix_time
      #[repr(C)]
      #[derive(Clone, Copy, PartialEq, serde::Deserialize, serde::Serialize)]
      pub struct Instant {
        pub seconds: i64,
        pub nanoseconds: u32,
      }
      impl ::core::fmt::Debug for Instant {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("Instant").field("seconds", &self.seconds).field("nanoseconds", &self.nanoseconds).finish()
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Read the current value of the clock.
      ///
      /// This clock is not monotonic, therefore calling this function repeatedly
      /// will not necessarily produce a sequence of non-decreasing values.
      ///
      /// The nanoseconds field of the output is always less than 1000000000.
      #[allow(async_fn_in_trait)]
      pub fn now() -> Instant{
        unsafe {

          #[repr(align(8))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 16]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 16]);
          let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:clocks/system-clock@0.3.0-rc-2026-01-06")]
          unsafe extern "C" {
            #[link_name = "now"]
            fn wit_import1(_: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn wit_import1(_: *mut u8, ) { unreachable!() }
          wit_import1(ptr0);
          let l2 = *ptr0.add(0).cast::<i64>();
          let l3 = *ptr0.add(8).cast::<i32>();
          let result4 = Instant{
            seconds: l2,
            nanoseconds: l3 as u32,
          };
          result4
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Query the resolution of the clock. Returns the smallest duration of time
      /// that the implementation permits distinguishing.
      #[allow(async_fn_in_trait)]
      pub fn get_resolution() -> Duration{
        unsafe {

          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:clocks/system-clock@0.3.0-rc-2026-01-06")]
          unsafe extern "C" {
            #[link_name = "get-resolution"]
            fn wit_import0() -> i64;
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn wit_import0() -> i64 { unreachable!() }
          let ret = wit_import0();
          ret as u64
        }
      }

    }

  }
  pub mod filesystem {
    /// WASI filesystem is a filesystem API primarily intended to let users run WASI
    /// programs that access their files on their existing filesystems, without
    /// significant overhead.
    ///
    /// It is intended to be roughly portable between Unix-family platforms and
    /// Windows, though it does not hide many of the major differences.
    ///
    /// Paths are passed as interface-type `string`s, meaning they must consist of
    /// a sequence of Unicode Scalar Values (USVs). Some filesystems may contain
    /// paths which are not accessible by this API.
    ///
    /// The directory separator in WASI is always the forward-slash (`/`).
    ///
    /// All paths in WASI are relative paths, and are interpreted relative to a
    /// `descriptor` referring to a base directory. If a `path` argument to any WASI
    /// function starts with `/`, or if any step of resolving a `path`, including
    /// `..` and symbolic link steps, reaches a directory outside of the base
    /// directory, or reaches a symlink to an absolute or rooted path in the
    /// underlying filesystem, the function fails with `error-code::not-permitted`.
    ///
    /// For more information about WASI path resolution and sandboxing, see
    /// [WASI filesystem path resolution].
    ///
    /// [WASI filesystem path resolution]: https://github.com/WebAssembly/wasi-filesystem/blob/main/path-resolution.md
    #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
    pub mod types {
      #[used]
      #[doc(hidden)]
      static __FORCE_SECTION_REF: fn() =
      super::super::super::__link_custom_section_describing_imports;
      
      use super::super::super::_rt;
      pub type Instant = super::super::super::wasi::clocks::system_clock::Instant;
      /// File size or length of a region within a file.
      pub type Filesize = u64;
      /// The type of a filesystem object referenced by a descriptor.
      ///
      /// Note: This was called `filetype` in earlier versions of WASI.
      #[repr(u8)]
      #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd, serde::Deserialize, serde::Serialize)]
      pub enum DescriptorType {
        /// The type of the descriptor or file is unknown or is different from
        /// any of the other types specified.
        Unknown,
        /// The descriptor refers to a block device inode.
        BlockDevice,
        /// The descriptor refers to a character device inode.
        CharacterDevice,
        /// The descriptor refers to a directory inode.
        Directory,
        /// The descriptor refers to a named pipe.
        Fifo,
        /// The file refers to a symbolic link inode.
        SymbolicLink,
        /// The descriptor refers to a regular file inode.
        RegularFile,
        /// The descriptor refers to a socket.
        Socket,
      }
      impl ::core::fmt::Debug for DescriptorType {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            DescriptorType::Unknown => {
              f.debug_tuple("DescriptorType::Unknown").finish()
            }
            DescriptorType::BlockDevice => {
              f.debug_tuple("DescriptorType::BlockDevice").finish()
            }
            DescriptorType::CharacterDevice => {
              f.debug_tuple("DescriptorType::CharacterDevice").finish()
            }
            DescriptorType::Directory => {
              f.debug_tuple("DescriptorType::Directory").finish()
            }
            DescriptorType::Fifo => {
              f.debug_tuple("DescriptorType::Fifo").finish()
            }
            DescriptorType::SymbolicLink => {
              f.debug_tuple("DescriptorType::SymbolicLink").finish()
            }
            DescriptorType::RegularFile => {
              f.debug_tuple("DescriptorType::RegularFile").finish()
            }
            DescriptorType::Socket => {
              f.debug_tuple("DescriptorType::Socket").finish()
            }
          }
        }
      }

      impl DescriptorType{
        #[doc(hidden)]
        pub unsafe fn _lift(val: u8) -> DescriptorType{
          if !cfg!(debug_assertions) {
            return unsafe { ::core::mem::transmute(val) };
          }

          match val {
            0 => DescriptorType::Unknown,
            1 => DescriptorType::BlockDevice,
            2 => DescriptorType::CharacterDevice,
            3 => DescriptorType::Directory,
            4 => DescriptorType::Fifo,
            5 => DescriptorType::SymbolicLink,
            6 => DescriptorType::RegularFile,
            7 => DescriptorType::Socket,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }

      wit_bindgen::rt::bitflags::bitflags! {
        /// Descriptor flags.
        ///
        /// Note: This was called `fdflags` in earlier versions of WASI.
        #[derive(PartialEq, Eq, PartialOrd, Ord, Hash, Debug, Clone, Copy)]
        pub struct DescriptorFlags: u8 {
          /// Read mode: Data can be read.
          const READ = 1 << 0;
          /// Write mode: Data can be written to.
          const WRITE = 1 << 1;
          /// Request that writes be performed according to synchronized I/O file
          /// integrity completion. The data stored in the file and the file's
          /// metadata are synchronized. This is similar to `O_SYNC` in POSIX.
          ///
          /// The precise semantics of this operation have not yet been defined for
          /// WASI. At this time, it should be interpreted as a request, and not a
          /// requirement.
          const FILE_INTEGRITY_SYNC = 1 << 2;
          /// Request that writes be performed according to synchronized I/O data
          /// integrity completion. Only the data stored in the file is
          /// synchronized. This is similar to `O_DSYNC` in POSIX.
          ///
          /// The precise semantics of this operation have not yet been defined for
          /// WASI. At this time, it should be interpreted as a request, and not a
          /// requirement.
          const DATA_INTEGRITY_SYNC = 1 << 3;
          /// Requests that reads be performed at the same level of integrity
          /// requested for writes. This is similar to `O_RSYNC` in POSIX.
          ///
          /// The precise semantics of this operation have not yet been defined for
          /// WASI. At this time, it should be interpreted as a request, and not a
          /// requirement.
          const REQUESTED_WRITE_SYNC = 1 << 4;
          /// Mutating directories mode: Directory contents may be mutated.
          ///
          /// When this flag is unset on a descriptor, operations using the
          /// descriptor which would create, rename, delete, modify the data or
          /// metadata of filesystem objects, or obtain another handle which
          /// would permit any of those, shall fail with `error-code::read-only` if
          /// they would otherwise succeed.
          ///
          /// This may only be set on directories.
          const MUTATE_DIRECTORY = 1 << 5;
        }
      }
      wit_bindgen::rt::bitflags::bitflags! {
        /// Flags determining the method of how paths are resolved.
        #[derive(PartialEq, Eq, PartialOrd, Ord, Hash, Debug, Clone, Copy)]
        pub struct PathFlags: u8 {
          /// As long as the resolved path corresponds to a symbolic link, it is
          /// expanded.
          const SYMLINK_FOLLOW = 1 << 0;
        }
      }
      wit_bindgen::rt::bitflags::bitflags! {
        /// Open flags used by `open-at`.
        #[derive(PartialEq, Eq, PartialOrd, Ord, Hash, Debug, Clone, Copy)]
        pub struct OpenFlags: u8 {
          /// Create file if it does not exist, similar to `O_CREAT` in POSIX.
          const CREATE = 1 << 0;
          /// Fail if not a directory, similar to `O_DIRECTORY` in POSIX.
          const DIRECTORY = 1 << 1;
          /// Fail if file already exists, similar to `O_EXCL` in POSIX.
          const EXCLUSIVE = 1 << 2;
          /// Truncate file to size 0, similar to `O_TRUNC` in POSIX.
          const TRUNCATE = 1 << 3;
        }
      }
      /// Number of hard links to an inode.
      pub type LinkCount = u64;
      /// File attributes.
      ///
      /// Note: This was called `filestat` in earlier versions of WASI.
      #[repr(C)]
      #[derive(Clone, Copy, PartialEq, serde::Deserialize, serde::Serialize)]
      pub struct DescriptorStat {
        /// File type.
        pub type_: DescriptorType,
        /// Number of hard links to the file.
        pub link_count: LinkCount,
        /// For regular files, the file size in bytes. For symbolic links, the
        /// length in bytes of the pathname contained in the symbolic link.
        pub size: Filesize,
        /// Last data access timestamp.
        ///
        /// If the `option` is none, the platform doesn't maintain an access
        /// timestamp for this file.
        pub data_access_timestamp: Option<Instant>,
        /// Last data modification timestamp.
        ///
        /// If the `option` is none, the platform doesn't maintain a
        /// modification timestamp for this file.
        pub data_modification_timestamp: Option<Instant>,
        /// Last file status-change timestamp.
        ///
        /// If the `option` is none, the platform doesn't maintain a
        /// status-change timestamp for this file.
        pub status_change_timestamp: Option<Instant>,
      }
      impl ::core::fmt::Debug for DescriptorStat {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("DescriptorStat").field("type", &self.type_).field("link-count", &self.link_count).field("size", &self.size).field("data-access-timestamp", &self.data_access_timestamp).field("data-modification-timestamp", &self.data_modification_timestamp).field("status-change-timestamp", &self.status_change_timestamp).finish()
        }
      }
      /// When setting a timestamp, this gives the value to set it to.
      #[derive(Clone, Copy, PartialEq, serde::Deserialize, serde::Serialize)]
      pub enum NewTimestamp {
        /// Leave the timestamp set to its previous value.
        NoChange,
        /// Set the timestamp to the current time of the system clock associated
        /// with the filesystem.
        Now,
        /// Set the timestamp to the given value.
        Timestamp(Instant),
      }
      impl ::core::fmt::Debug for NewTimestamp {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            NewTimestamp::NoChange => {
              f.debug_tuple("NewTimestamp::NoChange").finish()
            }
            NewTimestamp::Now => {
              f.debug_tuple("NewTimestamp::Now").finish()
            }
            NewTimestamp::Timestamp(e) => {
              f.debug_tuple("NewTimestamp::Timestamp").field(e).finish()
            }
          }
        }
      }
      /// A directory entry.
      #[derive(Clone, PartialEq, serde::Deserialize, serde::Serialize)]
      pub struct DirectoryEntry {
        /// The type of the file referred to by this directory entry.
        pub type_: DescriptorType,
        /// The name of the object.
        pub name: _rt::String,
      }
      impl ::core::fmt::Debug for DirectoryEntry {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("DirectoryEntry").field("type", &self.type_).field("name", &self.name).finish()
        }
      }
      /// Error codes returned by functions, similar to `errno` in POSIX.
      /// Not all of these error codes are returned by the functions provided by this
      /// API; some are used in higher-level library layers, and others are provided
      /// merely for alignment with POSIX.
      #[repr(u8)]
      #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd, serde::Deserialize, serde::Serialize)]
      pub enum ErrorCode {
        /// Permission denied, similar to `EACCES` in POSIX.
        Access,
        /// Connection already in progress, similar to `EALREADY` in POSIX.
        Already,
        /// Bad descriptor, similar to `EBADF` in POSIX.
        BadDescriptor,
        /// Device or resource busy, similar to `EBUSY` in POSIX.
        Busy,
        /// Resource deadlock would occur, similar to `EDEADLK` in POSIX.
        Deadlock,
        /// Storage quota exceeded, similar to `EDQUOT` in POSIX.
        Quota,
        /// File exists, similar to `EEXIST` in POSIX.
        Exist,
        /// File too large, similar to `EFBIG` in POSIX.
        FileTooLarge,
        /// Illegal byte sequence, similar to `EILSEQ` in POSIX.
        IllegalByteSequence,
        /// Operation in progress, similar to `EINPROGRESS` in POSIX.
        InProgress,
        /// Interrupted function, similar to `EINTR` in POSIX.
        Interrupted,
        /// Invalid argument, similar to `EINVAL` in POSIX.
        Invalid,
        /// I/O error, similar to `EIO` in POSIX.
        Io,
        /// Is a directory, similar to `EISDIR` in POSIX.
        IsDirectory,
        /// Too many levels of symbolic links, similar to `ELOOP` in POSIX.
        Loop,
        /// Too many links, similar to `EMLINK` in POSIX.
        TooManyLinks,
        /// Message too large, similar to `EMSGSIZE` in POSIX.
        MessageSize,
        /// Filename too long, similar to `ENAMETOOLONG` in POSIX.
        NameTooLong,
        /// No such device, similar to `ENODEV` in POSIX.
        NoDevice,
        /// No such file or directory, similar to `ENOENT` in POSIX.
        NoEntry,
        /// No locks available, similar to `ENOLCK` in POSIX.
        NoLock,
        /// Not enough space, similar to `ENOMEM` in POSIX.
        InsufficientMemory,
        /// No space left on device, similar to `ENOSPC` in POSIX.
        InsufficientSpace,
        /// Not a directory or a symbolic link to a directory, similar to `ENOTDIR` in POSIX.
        NotDirectory,
        /// Directory not empty, similar to `ENOTEMPTY` in POSIX.
        NotEmpty,
        /// State not recoverable, similar to `ENOTRECOVERABLE` in POSIX.
        NotRecoverable,
        /// Not supported, similar to `ENOTSUP` and `ENOSYS` in POSIX.
        Unsupported,
        /// Inappropriate I/O control operation, similar to `ENOTTY` in POSIX.
        NoTty,
        /// No such device or address, similar to `ENXIO` in POSIX.
        NoSuchDevice,
        /// Value too large to be stored in data type, similar to `EOVERFLOW` in POSIX.
        Overflow,
        /// Operation not permitted, similar to `EPERM` in POSIX.
        NotPermitted,
        /// Broken pipe, similar to `EPIPE` in POSIX.
        Pipe,
        /// Read-only file system, similar to `EROFS` in POSIX.
        ReadOnly,
        /// Invalid seek, similar to `ESPIPE` in POSIX.
        InvalidSeek,
        /// Text file busy, similar to `ETXTBSY` in POSIX.
        TextFileBusy,
        /// Cross-device link, similar to `EXDEV` in POSIX.
        CrossDevice,
      }
      impl ErrorCode{
        pub fn name(&self) -> &'static str {
          match self {
            ErrorCode::Access => "access",
            ErrorCode::Already => "already",
            ErrorCode::BadDescriptor => "bad-descriptor",
            ErrorCode::Busy => "busy",
            ErrorCode::Deadlock => "deadlock",
            ErrorCode::Quota => "quota",
            ErrorCode::Exist => "exist",
            ErrorCode::FileTooLarge => "file-too-large",
            ErrorCode::IllegalByteSequence => "illegal-byte-sequence",
            ErrorCode::InProgress => "in-progress",
            ErrorCode::Interrupted => "interrupted",
            ErrorCode::Invalid => "invalid",
            ErrorCode::Io => "io",
            ErrorCode::IsDirectory => "is-directory",
            ErrorCode::Loop => "loop",
            ErrorCode::TooManyLinks => "too-many-links",
            ErrorCode::MessageSize => "message-size",
            ErrorCode::NameTooLong => "name-too-long",
            ErrorCode::NoDevice => "no-device",
            ErrorCode::NoEntry => "no-entry",
            ErrorCode::NoLock => "no-lock",
            ErrorCode::InsufficientMemory => "insufficient-memory",
            ErrorCode::InsufficientSpace => "insufficient-space",
            ErrorCode::NotDirectory => "not-directory",
            ErrorCode::NotEmpty => "not-empty",
            ErrorCode::NotRecoverable => "not-recoverable",
            ErrorCode::Unsupported => "unsupported",
            ErrorCode::NoTty => "no-tty",
            ErrorCode::NoSuchDevice => "no-such-device",
            ErrorCode::Overflow => "overflow",
            ErrorCode::NotPermitted => "not-permitted",
            ErrorCode::Pipe => "pipe",
            ErrorCode::ReadOnly => "read-only",
            ErrorCode::InvalidSeek => "invalid-seek",
            ErrorCode::TextFileBusy => "text-file-busy",
            ErrorCode::CrossDevice => "cross-device",
          }
        }
        pub fn message(&self) -> &'static str {
          match self {
            ErrorCode::Access => "Permission denied, similar to `EACCES` in POSIX.",
            ErrorCode::Already => "Connection already in progress, similar to `EALREADY` in POSIX.",
            ErrorCode::BadDescriptor => "Bad descriptor, similar to `EBADF` in POSIX.",
            ErrorCode::Busy => "Device or resource busy, similar to `EBUSY` in POSIX.",
            ErrorCode::Deadlock => "Resource deadlock would occur, similar to `EDEADLK` in POSIX.",
            ErrorCode::Quota => "Storage quota exceeded, similar to `EDQUOT` in POSIX.",
            ErrorCode::Exist => "File exists, similar to `EEXIST` in POSIX.",
            ErrorCode::FileTooLarge => "File too large, similar to `EFBIG` in POSIX.",
            ErrorCode::IllegalByteSequence => "Illegal byte sequence, similar to `EILSEQ` in POSIX.",
            ErrorCode::InProgress => "Operation in progress, similar to `EINPROGRESS` in POSIX.",
            ErrorCode::Interrupted => "Interrupted function, similar to `EINTR` in POSIX.",
            ErrorCode::Invalid => "Invalid argument, similar to `EINVAL` in POSIX.",
            ErrorCode::Io => "I/O error, similar to `EIO` in POSIX.",
            ErrorCode::IsDirectory => "Is a directory, similar to `EISDIR` in POSIX.",
            ErrorCode::Loop => "Too many levels of symbolic links, similar to `ELOOP` in POSIX.",
            ErrorCode::TooManyLinks => "Too many links, similar to `EMLINK` in POSIX.",
            ErrorCode::MessageSize => "Message too large, similar to `EMSGSIZE` in POSIX.",
            ErrorCode::NameTooLong => "Filename too long, similar to `ENAMETOOLONG` in POSIX.",
            ErrorCode::NoDevice => "No such device, similar to `ENODEV` in POSIX.",
            ErrorCode::NoEntry => "No such file or directory, similar to `ENOENT` in POSIX.",
            ErrorCode::NoLock => "No locks available, similar to `ENOLCK` in POSIX.",
            ErrorCode::InsufficientMemory => "Not enough space, similar to `ENOMEM` in POSIX.",
            ErrorCode::InsufficientSpace => "No space left on device, similar to `ENOSPC` in POSIX.",
            ErrorCode::NotDirectory => "Not a directory or a symbolic link to a directory, similar to `ENOTDIR` in POSIX.",
            ErrorCode::NotEmpty => "Directory not empty, similar to `ENOTEMPTY` in POSIX.",
            ErrorCode::NotRecoverable => "State not recoverable, similar to `ENOTRECOVERABLE` in POSIX.",
            ErrorCode::Unsupported => "Not supported, similar to `ENOTSUP` and `ENOSYS` in POSIX.",
            ErrorCode::NoTty => "Inappropriate I/O control operation, similar to `ENOTTY` in POSIX.",
            ErrorCode::NoSuchDevice => "No such device or address, similar to `ENXIO` in POSIX.",
            ErrorCode::Overflow => "Value too large to be stored in data type, similar to `EOVERFLOW` in POSIX.",
            ErrorCode::NotPermitted => "Operation not permitted, similar to `EPERM` in POSIX.",
            ErrorCode::Pipe => "Broken pipe, similar to `EPIPE` in POSIX.",
            ErrorCode::ReadOnly => "Read-only file system, similar to `EROFS` in POSIX.",
            ErrorCode::InvalidSeek => "Invalid seek, similar to `ESPIPE` in POSIX.",
            ErrorCode::TextFileBusy => "Text file busy, similar to `ETXTBSY` in POSIX.",
            ErrorCode::CrossDevice => "Cross-device link, similar to `EXDEV` in POSIX.",
          }
        }
      }
      impl ::core::fmt::Debug for ErrorCode{
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("ErrorCode")
          .field("code", &(*self as i32))
          .field("name", &self.name())
          .field("message", &self.message())
          .finish()
        }
      }
      impl ::core::fmt::Display for ErrorCode{
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          write!(f, "{} (error {})", self.name(), *self as i32)
        }
      }

      impl ::core::error::Error for ErrorCode {}

      impl ErrorCode{
        #[doc(hidden)]
        pub unsafe fn _lift(val: u8) -> ErrorCode{
          if !cfg!(debug_assertions) {
            return unsafe { ::core::mem::transmute(val) };
          }

          match val {
            0 => ErrorCode::Access,
            1 => ErrorCode::Already,
            2 => ErrorCode::BadDescriptor,
            3 => ErrorCode::Busy,
            4 => ErrorCode::Deadlock,
            5 => ErrorCode::Quota,
            6 => ErrorCode::Exist,
            7 => ErrorCode::FileTooLarge,
            8 => ErrorCode::IllegalByteSequence,
            9 => ErrorCode::InProgress,
            10 => ErrorCode::Interrupted,
            11 => ErrorCode::Invalid,
            12 => ErrorCode::Io,
            13 => ErrorCode::IsDirectory,
            14 => ErrorCode::Loop,
            15 => ErrorCode::TooManyLinks,
            16 => ErrorCode::MessageSize,
            17 => ErrorCode::NameTooLong,
            18 => ErrorCode::NoDevice,
            19 => ErrorCode::NoEntry,
            20 => ErrorCode::NoLock,
            21 => ErrorCode::InsufficientMemory,
            22 => ErrorCode::InsufficientSpace,
            23 => ErrorCode::NotDirectory,
            24 => ErrorCode::NotEmpty,
            25 => ErrorCode::NotRecoverable,
            26 => ErrorCode::Unsupported,
            27 => ErrorCode::NoTty,
            28 => ErrorCode::NoSuchDevice,
            29 => ErrorCode::Overflow,
            30 => ErrorCode::NotPermitted,
            31 => ErrorCode::Pipe,
            32 => ErrorCode::ReadOnly,
            33 => ErrorCode::InvalidSeek,
            34 => ErrorCode::TextFileBusy,
            35 => ErrorCode::CrossDevice,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }

      /// File or memory access pattern advisory information.
      #[repr(u8)]
      #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd, serde::Deserialize, serde::Serialize)]
      pub enum Advice {
        /// The application has no advice to give on its behavior with respect
        /// to the specified data.
        Normal,
        /// The application expects to access the specified data sequentially
        /// from lower offsets to higher offsets.
        Sequential,
        /// The application expects to access the specified data in a random
        /// order.
        Random,
        /// The application expects to access the specified data in the near
        /// future.
        WillNeed,
        /// The application expects that it will not access the specified data
        /// in the near future.
        DontNeed,
        /// The application expects to access the specified data once and then
        /// not reuse it thereafter.
        NoReuse,
      }
      impl ::core::fmt::Debug for Advice {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            Advice::Normal => {
              f.debug_tuple("Advice::Normal").finish()
            }
            Advice::Sequential => {
              f.debug_tuple("Advice::Sequential").finish()
            }
            Advice::Random => {
              f.debug_tuple("Advice::Random").finish()
            }
            Advice::WillNeed => {
              f.debug_tuple("Advice::WillNeed").finish()
            }
            Advice::DontNeed => {
              f.debug_tuple("Advice::DontNeed").finish()
            }
            Advice::NoReuse => {
              f.debug_tuple("Advice::NoReuse").finish()
            }
          }
        }
      }

      impl Advice{
        #[doc(hidden)]
        pub unsafe fn _lift(val: u8) -> Advice{
          if !cfg!(debug_assertions) {
            return unsafe { ::core::mem::transmute(val) };
          }

          match val {
            0 => Advice::Normal,
            1 => Advice::Sequential,
            2 => Advice::Random,
            3 => Advice::WillNeed,
            4 => Advice::DontNeed,
            5 => Advice::NoReuse,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }

      /// A 128-bit hash value, split into parts because wasm doesn't have a
      /// 128-bit integer type.
      #[repr(C)]
      #[derive(Clone, Copy, PartialEq, serde::Deserialize, serde::Serialize)]
      pub struct MetadataHashValue {
        /// 64 bits of a 128-bit hash value.
        pub lower: u64,
        /// Another 64 bits of a 128-bit hash value.
        pub upper: u64,
      }
      impl ::core::fmt::Debug for MetadataHashValue {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("MetadataHashValue").field("lower", &self.lower).field("upper", &self.upper).finish()
        }
      }
      /// A descriptor is a reference to a filesystem object, which may be a file,
      /// directory, named pipe, special file, or other object on which filesystem
      /// calls may be made.

      #[derive(Debug)]
      #[repr(transparent)]
      pub struct Descriptor{
        handle: _rt::Resource<Descriptor>,
      }

      impl Descriptor{
        #[doc(hidden)]
        pub unsafe fn from_handle(handle: u32) -> Self {
          Self {
            handle: unsafe { _rt::Resource::from_handle(handle) },
          }
        }

        #[doc(hidden)]
        pub fn take_handle(&self) -> u32 {
          _rt::Resource::take_handle(&self.handle)
        }

        #[doc(hidden)]
        pub fn handle(&self) -> u32 {
          _rt::Resource::handle(&self.handle)
        }
      }
      

      unsafe impl _rt::WasmResource for Descriptor{
        #[inline]
        unsafe fn drop(_handle: u32) {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:filesystem/types@0.3.0-rc-2026-01-06")]
          unsafe extern "C" {
            #[link_name = "[resource-drop]descriptor"]
            fn drop(_: i32, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn drop(_: i32, ) { unreachable!() }
          
          unsafe { drop(_handle as i32); }
        }
      }
      
      impl Descriptor {
        #[allow(unused_unsafe, clippy::all)]
        /// Return a stream for reading from a file.
        ///
        /// Multiple read, write, and append streams may be active on the same open
        /// file and they do not interfere with each other.
        ///
        /// This function returns a `stream` which provides the data received from the
        /// file, and a `future` providing additional error information in case an
        /// error is encountered.
        ///
        /// If no error is encountered, `stream.read` on the `stream` will return
        /// `read-status::closed` with no `error-context` and the future resolves to
        /// the value `ok`. If an error is encountered, `stream.read` on the
        /// `stream` returns `read-status::closed` with an `error-context` and the future
        /// resolves to `err` with an `error-code`.
        ///
        /// Note: This is similar to `pread` in POSIX.
        #[allow(async_fn_in_trait)]
        pub fn read_via_stream(&self,offset: Filesize,) -> (wit_bindgen::rt::async_support::StreamReader<u8>,wit_bindgen::rt::async_support::FutureReader<Result<(),ErrorCode>>,){
          unsafe {

            #[repr(align(4))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 8]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 8]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:filesystem/types@0.3.0-rc-2026-01-06")]
            unsafe extern "C" {
              #[link_name = "[method]descriptor.read-via-stream"]
              fn wit_import1(_: i32, _: i64, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import1(_: i32, _: i64, _: *mut u8, ) { unreachable!() }
            wit_import1((self).handle() as i32, _rt::as_i64(offset), ptr0);
            let l2 = *ptr0.add(0).cast::<i32>();
            let l3 = *ptr0.add(4).cast::<i32>();
            let result4 = (wit_bindgen::rt::async_support::StreamReader::new(l2 as u32, &super::super::super::wit_stream::vtable0::VTABLE), wit_bindgen::rt::async_support::FutureReader::new(l3 as u32, &super::super::super::wit_future::vtable1::VTABLE));
            result4
          }
        }
      }
      impl Descriptor {
        #[allow(unused_unsafe, clippy::all)]
        /// Return a stream for writing to a file, if available.
        ///
        /// May fail with an error-code describing why the file cannot be written.
        ///
        /// It is valid to write past the end of a file; the file is extended to the
        /// extent of the write, with bytes between the previous end and the start of
        /// the write set to zero.
        ///
        /// This function returns once either full contents of the stream are
        /// written or an error is encountered.
        ///
        /// Note: This is similar to `pwrite` in POSIX.
        #[allow(async_fn_in_trait)]
        pub fn write_via_stream(&self,data: wit_bindgen::rt::async_support::StreamReader<u8>,offset: Filesize,) -> Result<(),ErrorCode>{
          unsafe {

            #[repr(align(1))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 2]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:filesystem/types@0.3.0-rc-2026-01-06")]
            unsafe extern "C" {
              #[link_name = "[method]descriptor.write-via-stream"]
              fn wit_import1(_: i32, _: i32, _: i64, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import1(_: i32, _: i32, _: i64, _: *mut u8, ) { unreachable!() }
            wit_import1((self).handle() as i32, (&data).take_handle() as i32, _rt::as_i64(offset), ptr0);
            let l2 = i32::from(*ptr0.add(0).cast::<u8>());
            let result4 = match l2 {
              0 => {
                let e = ();
                Ok(e)
              }
              1 => {
                let e = {
                  let l3 = i32::from(*ptr0.add(1).cast::<u8>());

                  ErrorCode::_lift(l3 as u8)
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            };
            result4
          }
        }
      }
      impl Descriptor {
        #[allow(unused_unsafe, clippy::all)]
        /// Return a stream for appending to a file, if available.
        ///
        /// May fail with an error-code describing why the file cannot be appended.
        ///
        /// This function returns once either full contents of the stream are
        /// written or an error is encountered.
        ///
        /// Note: This is similar to `write` with `O_APPEND` in POSIX.
        #[allow(async_fn_in_trait)]
        pub fn append_via_stream(&self,data: wit_bindgen::rt::async_support::StreamReader<u8>,) -> Result<(),ErrorCode>{
          unsafe {

            #[repr(align(1))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 2]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:filesystem/types@0.3.0-rc-2026-01-06")]
            unsafe extern "C" {
              #[link_name = "[method]descriptor.append-via-stream"]
              fn wit_import1(_: i32, _: i32, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import1(_: i32, _: i32, _: *mut u8, ) { unreachable!() }
            wit_import1((self).handle() as i32, (&data).take_handle() as i32, ptr0);
            let l2 = i32::from(*ptr0.add(0).cast::<u8>());
            let result4 = match l2 {
              0 => {
                let e = ();
                Ok(e)
              }
              1 => {
                let e = {
                  let l3 = i32::from(*ptr0.add(1).cast::<u8>());

                  ErrorCode::_lift(l3 as u8)
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            };
            result4
          }
        }
      }
      impl Descriptor {
        #[allow(unused_unsafe, clippy::all)]
        /// Provide file advisory information on a descriptor.
        ///
        /// This is similar to `posix_fadvise` in POSIX.
        #[allow(async_fn_in_trait)]
        pub fn advise(&self,offset: Filesize,length: Filesize,advice: Advice,) -> Result<(),ErrorCode>{
          unsafe {

            #[repr(align(1))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 2]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:filesystem/types@0.3.0-rc-2026-01-06")]
            unsafe extern "C" {
              #[link_name = "[method]descriptor.advise"]
              fn wit_import1(_: i32, _: i64, _: i64, _: i32, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import1(_: i32, _: i64, _: i64, _: i32, _: *mut u8, ) { unreachable!() }
            wit_import1((self).handle() as i32, _rt::as_i64(offset), _rt::as_i64(length), advice.clone() as i32, ptr0);
            let l2 = i32::from(*ptr0.add(0).cast::<u8>());
            let result4 = match l2 {
              0 => {
                let e = ();
                Ok(e)
              }
              1 => {
                let e = {
                  let l3 = i32::from(*ptr0.add(1).cast::<u8>());

                  ErrorCode::_lift(l3 as u8)
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            };
            result4
          }
        }
      }
      impl Descriptor {
        #[allow(unused_unsafe, clippy::all)]
        /// Synchronize the data of a file to disk.
        ///
        /// This function succeeds with no effect if the file descriptor is not
        /// opened for writing.
        ///
        /// Note: This is similar to `fdatasync` in POSIX.
        #[allow(async_fn_in_trait)]
        pub fn sync_data(&self,) -> Result<(),ErrorCode>{
          unsafe {

            #[repr(align(1))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 2]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:filesystem/types@0.3.0-rc-2026-01-06")]
            unsafe extern "C" {
              #[link_name = "[method]descriptor.sync-data"]
              fn wit_import1(_: i32, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, ) { unreachable!() }
            wit_import1((self).handle() as i32, ptr0);
            let l2 = i32::from(*ptr0.add(0).cast::<u8>());
            let result4 = match l2 {
              0 => {
                let e = ();
                Ok(e)
              }
              1 => {
                let e = {
                  let l3 = i32::from(*ptr0.add(1).cast::<u8>());

                  ErrorCode::_lift(l3 as u8)
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            };
            result4
          }
        }
      }
      impl Descriptor {
        #[allow(unused_unsafe, clippy::all)]
        /// Get flags associated with a descriptor.
        ///
        /// Note: This returns similar flags to `fcntl(fd, F_GETFL)` in POSIX.
        ///
        /// Note: This returns the value that was the `fs_flags` value returned
        /// from `fdstat_get` in earlier versions of WASI.
        #[allow(async_fn_in_trait)]
        pub fn get_flags(&self,) -> Result<DescriptorFlags,ErrorCode>{
          unsafe {

            #[repr(align(1))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 2]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:filesystem/types@0.3.0-rc-2026-01-06")]
            unsafe extern "C" {
              #[link_name = "[method]descriptor.get-flags"]
              fn wit_import1(_: i32, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, ) { unreachable!() }
            wit_import1((self).handle() as i32, ptr0);
            let l2 = i32::from(*ptr0.add(0).cast::<u8>());
            let result5 = match l2 {
              0 => {
                let e = {
                  let l3 = i32::from(*ptr0.add(1).cast::<u8>());

                  DescriptorFlags::empty() | DescriptorFlags::from_bits_retain(((l3 as u8) << 0) as _)
                };
                Ok(e)
              }
              1 => {
                let e = {
                  let l4 = i32::from(*ptr0.add(1).cast::<u8>());

                  ErrorCode::_lift(l4 as u8)
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            };
            result5
          }
        }
      }
      impl Descriptor {
        #[allow(unused_unsafe, clippy::all)]
        /// Get the dynamic type of a descriptor.
        ///
        /// Note: This returns the same value as the `type` field of the `fd-stat`
        /// returned by `stat`, `stat-at` and similar.
        ///
        /// Note: This returns similar flags to the `st_mode & S_IFMT` value provided
        /// by `fstat` in POSIX.
        ///
        /// Note: This returns the value that was the `fs_filetype` value returned
        /// from `fdstat_get` in earlier versions of WASI.
        #[allow(async_fn_in_trait)]
        pub fn get_type(&self,) -> Result<DescriptorType,ErrorCode>{
          unsafe {

            #[repr(align(1))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 2]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:filesystem/types@0.3.0-rc-2026-01-06")]
            unsafe extern "C" {
              #[link_name = "[method]descriptor.get-type"]
              fn wit_import1(_: i32, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, ) { unreachable!() }
            wit_import1((self).handle() as i32, ptr0);
            let l2 = i32::from(*ptr0.add(0).cast::<u8>());
            let result5 = match l2 {
              0 => {
                let e = {
                  let l3 = i32::from(*ptr0.add(1).cast::<u8>());

                  DescriptorType::_lift(l3 as u8)
                };
                Ok(e)
              }
              1 => {
                let e = {
                  let l4 = i32::from(*ptr0.add(1).cast::<u8>());

                  ErrorCode::_lift(l4 as u8)
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            };
            result5
          }
        }
      }
      impl Descriptor {
        #[allow(unused_unsafe, clippy::all)]
        /// Adjust the size of an open file. If this increases the file's size, the
        /// extra bytes are filled with zeros.
        ///
        /// Note: This was called `fd_filestat_set_size` in earlier versions of WASI.
        #[allow(async_fn_in_trait)]
        pub fn set_size(&self,size: Filesize,) -> Result<(),ErrorCode>{
          unsafe {

            #[repr(align(1))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 2]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:filesystem/types@0.3.0-rc-2026-01-06")]
            unsafe extern "C" {
              #[link_name = "[method]descriptor.set-size"]
              fn wit_import1(_: i32, _: i64, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import1(_: i32, _: i64, _: *mut u8, ) { unreachable!() }
            wit_import1((self).handle() as i32, _rt::as_i64(size), ptr0);
            let l2 = i32::from(*ptr0.add(0).cast::<u8>());
            let result4 = match l2 {
              0 => {
                let e = ();
                Ok(e)
              }
              1 => {
                let e = {
                  let l3 = i32::from(*ptr0.add(1).cast::<u8>());

                  ErrorCode::_lift(l3 as u8)
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            };
            result4
          }
        }
      }
      impl Descriptor {
        #[allow(unused_unsafe, clippy::all)]
        /// Adjust the timestamps of an open file or directory.
        ///
        /// Note: This is similar to `futimens` in POSIX.
        ///
        /// Note: This was called `fd_filestat_set_times` in earlier versions of WASI.
        #[allow(async_fn_in_trait)]
        pub fn set_times(&self,data_access_timestamp: NewTimestamp,data_modification_timestamp: NewTimestamp,) -> Result<(),ErrorCode>{
          unsafe {

            #[repr(align(1))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 2]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2]);
            let (result1_0,result1_1,result1_2,) = match data_access_timestamp {
              NewTimestamp::NoChange=> {
                (0i32, 0i64, 0i32)
              }
              NewTimestamp::Now=> {
                (1i32, 0i64, 0i32)
              }
              NewTimestamp::Timestamp(e) => {
                let super::super::super::wasi::clocks::system_clock::Instant{ seconds:seconds0, nanoseconds:nanoseconds0, } = e;

                (2i32, _rt::as_i64(seconds0), _rt::as_i32(nanoseconds0))
              },
            };
            let (result3_0,result3_1,result3_2,) = match data_modification_timestamp {
              NewTimestamp::NoChange=> {
                (0i32, 0i64, 0i32)
              }
              NewTimestamp::Now=> {
                (1i32, 0i64, 0i32)
              }
              NewTimestamp::Timestamp(e) => {
                let super::super::super::wasi::clocks::system_clock::Instant{ seconds:seconds2, nanoseconds:nanoseconds2, } = e;

                (2i32, _rt::as_i64(seconds2), _rt::as_i32(nanoseconds2))
              },
            };
            let ptr4 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:filesystem/types@0.3.0-rc-2026-01-06")]
            unsafe extern "C" {
              #[link_name = "[method]descriptor.set-times"]
              fn wit_import5(_: i32, _: i32, _: i64, _: i32, _: i32, _: i64, _: i32, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import5(_: i32, _: i32, _: i64, _: i32, _: i32, _: i64, _: i32, _: *mut u8, ) { unreachable!() }
            wit_import5((self).handle() as i32, result1_0, result1_1, result1_2, result3_0, result3_1, result3_2, ptr4);
            let l6 = i32::from(*ptr4.add(0).cast::<u8>());
            let result8 = match l6 {
              0 => {
                let e = ();
                Ok(e)
              }
              1 => {
                let e = {
                  let l7 = i32::from(*ptr4.add(1).cast::<u8>());

                  ErrorCode::_lift(l7 as u8)
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            };
            result8
          }
        }
      }
      impl Descriptor {
        #[allow(unused_unsafe, clippy::all)]
        /// Read directory entries from a directory.
        ///
        /// On filesystems where directories contain entries referring to themselves
        /// and their parents, often named `.` and `..` respectively, these entries
        /// are omitted.
        ///
        /// This always returns a new stream which starts at the beginning of the
        /// directory. Multiple streams may be active on the same directory, and they
        /// do not interfere with each other.
        ///
        /// This function returns a future, which will resolve to an error code if
        /// reading full contents of the directory fails.
        #[allow(async_fn_in_trait)]
        pub fn read_directory(&self,) -> (wit_bindgen::rt::async_support::StreamReader<DirectoryEntry>,wit_bindgen::rt::async_support::FutureReader<Result<(),ErrorCode>>,){
          unsafe {

            #[repr(align(4))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 8]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 8]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:filesystem/types@0.3.0-rc-2026-01-06")]
            unsafe extern "C" {
              #[link_name = "[method]descriptor.read-directory"]
              fn wit_import1(_: i32, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, ) { unreachable!() }
            wit_import1((self).handle() as i32, ptr0);
            let l2 = *ptr0.add(0).cast::<i32>();
            let l3 = *ptr0.add(4).cast::<i32>();
            let result4 = (wit_bindgen::rt::async_support::StreamReader::new(l2 as u32, &super::super::super::wit_stream::vtable1::VTABLE), wit_bindgen::rt::async_support::FutureReader::new(l3 as u32, &super::super::super::wit_future::vtable1::VTABLE));
            result4
          }
        }
      }
      impl Descriptor {
        #[allow(unused_unsafe, clippy::all)]
        /// Synchronize the data and metadata of a file to disk.
        ///
        /// This function succeeds with no effect if the file descriptor is not
        /// opened for writing.
        ///
        /// Note: This is similar to `fsync` in POSIX.
        #[allow(async_fn_in_trait)]
        pub fn sync(&self,) -> Result<(),ErrorCode>{
          unsafe {

            #[repr(align(1))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 2]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:filesystem/types@0.3.0-rc-2026-01-06")]
            unsafe extern "C" {
              #[link_name = "[method]descriptor.sync"]
              fn wit_import1(_: i32, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, ) { unreachable!() }
            wit_import1((self).handle() as i32, ptr0);
            let l2 = i32::from(*ptr0.add(0).cast::<u8>());
            let result4 = match l2 {
              0 => {
                let e = ();
                Ok(e)
              }
              1 => {
                let e = {
                  let l3 = i32::from(*ptr0.add(1).cast::<u8>());

                  ErrorCode::_lift(l3 as u8)
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            };
            result4
          }
        }
      }
      impl Descriptor {
        #[allow(unused_unsafe, clippy::all)]
        /// Create a directory.
        ///
        /// Note: This is similar to `mkdirat` in POSIX.
        #[allow(async_fn_in_trait)]
        pub fn create_directory_at(&self,path: &str,) -> Result<(),ErrorCode>{
          unsafe {

            #[repr(align(1))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 2]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2]);
            let vec0 = path;
            let ptr0 = vec0.as_ptr().cast::<u8>();
            let len0 = vec0.len();
            let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:filesystem/types@0.3.0-rc-2026-01-06")]
            unsafe extern "C" {
              #[link_name = "[method]descriptor.create-directory-at"]
              fn wit_import2(_: i32, _: *mut u8, _: usize, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import2(_: i32, _: *mut u8, _: usize, _: *mut u8, ) { unreachable!() }
            wit_import2((self).handle() as i32, ptr0.cast_mut(), len0, ptr1);
            let l3 = i32::from(*ptr1.add(0).cast::<u8>());
            let result5 = match l3 {
              0 => {
                let e = ();
                Ok(e)
              }
              1 => {
                let e = {
                  let l4 = i32::from(*ptr1.add(1).cast::<u8>());

                  ErrorCode::_lift(l4 as u8)
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            };
            result5
          }
        }
      }
      impl Descriptor {
        #[allow(unused_unsafe, clippy::all)]
        /// Return the attributes of an open file or directory.
        ///
        /// Note: This is similar to `fstat` in POSIX, except that it does not return
        /// device and inode information. For testing whether two descriptors refer to
        /// the same underlying filesystem object, use `is-same-object`. To obtain
        /// additional data that can be used do determine whether a file has been
        /// modified, use `metadata-hash`.
        ///
        /// Note: This was called `fd_filestat_get` in earlier versions of WASI.
        #[allow(async_fn_in_trait)]
        pub fn stat(&self,) -> Result<DescriptorStat,ErrorCode>{
          unsafe {

            #[repr(align(8))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 104]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 104]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:filesystem/types@0.3.0-rc-2026-01-06")]
            unsafe extern "C" {
              #[link_name = "[method]descriptor.stat"]
              fn wit_import1(_: i32, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, ) { unreachable!() }
            wit_import1((self).handle() as i32, ptr0);
            let l2 = i32::from(*ptr0.add(0).cast::<u8>());
            let result16 = match l2 {
              0 => {
                let e = {
                  let l3 = i32::from(*ptr0.add(8).cast::<u8>());
                  let l4 = *ptr0.add(16).cast::<i64>();
                  let l5 = *ptr0.add(24).cast::<i64>();
                  let l6 = i32::from(*ptr0.add(32).cast::<u8>());
                  let l9 = i32::from(*ptr0.add(56).cast::<u8>());
                  let l12 = i32::from(*ptr0.add(80).cast::<u8>());

                  DescriptorStat{
                    type_: DescriptorType::_lift(l3 as u8),
                    link_count: l4 as u64,
                    size: l5 as u64,
                    data_access_timestamp: match l6 {
                      0 => None,
                      1 => {
                        let e = {
                          let l7 = *ptr0.add(40).cast::<i64>();
                          let l8 = *ptr0.add(48).cast::<i32>();

                          super::super::super::wasi::clocks::system_clock::Instant{
                            seconds: l7,
                            nanoseconds: l8 as u32,
                          }
                        };
                        Some(e)
                      }
                      _ => _rt::invalid_enum_discriminant(),
                    },
                    data_modification_timestamp: match l9 {
                      0 => None,
                      1 => {
                        let e = {
                          let l10 = *ptr0.add(64).cast::<i64>();
                          let l11 = *ptr0.add(72).cast::<i32>();

                          super::super::super::wasi::clocks::system_clock::Instant{
                            seconds: l10,
                            nanoseconds: l11 as u32,
                          }
                        };
                        Some(e)
                      }
                      _ => _rt::invalid_enum_discriminant(),
                    },
                    status_change_timestamp: match l12 {
                      0 => None,
                      1 => {
                        let e = {
                          let l13 = *ptr0.add(88).cast::<i64>();
                          let l14 = *ptr0.add(96).cast::<i32>();

                          super::super::super::wasi::clocks::system_clock::Instant{
                            seconds: l13,
                            nanoseconds: l14 as u32,
                          }
                        };
                        Some(e)
                      }
                      _ => _rt::invalid_enum_discriminant(),
                    },
                  }
                };
                Ok(e)
              }
              1 => {
                let e = {
                  let l15 = i32::from(*ptr0.add(8).cast::<u8>());

                  ErrorCode::_lift(l15 as u8)
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            };
            result16
          }
        }
      }
      impl Descriptor {
        #[allow(unused_unsafe, clippy::all)]
        /// Return the attributes of a file or directory.
        ///
        /// Note: This is similar to `fstatat` in POSIX, except that it does not
        /// return device and inode information. See the `stat` description for a
        /// discussion of alternatives.
        ///
        /// Note: This was called `path_filestat_get` in earlier versions of WASI.
        #[allow(async_fn_in_trait)]
        pub fn stat_at(&self,path_flags: PathFlags,path: &str,) -> Result<DescriptorStat,ErrorCode>{
          unsafe {

            #[repr(align(8))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 104]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 104]);
            let flags0 = path_flags;
            let vec1 = path;
            let ptr1 = vec1.as_ptr().cast::<u8>();
            let len1 = vec1.len();
            let ptr2 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:filesystem/types@0.3.0-rc-2026-01-06")]
            unsafe extern "C" {
              #[link_name = "[method]descriptor.stat-at"]
              fn wit_import3(_: i32, _: i32, _: *mut u8, _: usize, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import3(_: i32, _: i32, _: *mut u8, _: usize, _: *mut u8, ) { unreachable!() }
            wit_import3((self).handle() as i32, (flags0.bits() >> 0) as i32, ptr1.cast_mut(), len1, ptr2);
            let l4 = i32::from(*ptr2.add(0).cast::<u8>());
            let result18 = match l4 {
              0 => {
                let e = {
                  let l5 = i32::from(*ptr2.add(8).cast::<u8>());
                  let l6 = *ptr2.add(16).cast::<i64>();
                  let l7 = *ptr2.add(24).cast::<i64>();
                  let l8 = i32::from(*ptr2.add(32).cast::<u8>());
                  let l11 = i32::from(*ptr2.add(56).cast::<u8>());
                  let l14 = i32::from(*ptr2.add(80).cast::<u8>());

                  DescriptorStat{
                    type_: DescriptorType::_lift(l5 as u8),
                    link_count: l6 as u64,
                    size: l7 as u64,
                    data_access_timestamp: match l8 {
                      0 => None,
                      1 => {
                        let e = {
                          let l9 = *ptr2.add(40).cast::<i64>();
                          let l10 = *ptr2.add(48).cast::<i32>();

                          super::super::super::wasi::clocks::system_clock::Instant{
                            seconds: l9,
                            nanoseconds: l10 as u32,
                          }
                        };
                        Some(e)
                      }
                      _ => _rt::invalid_enum_discriminant(),
                    },
                    data_modification_timestamp: match l11 {
                      0 => None,
                      1 => {
                        let e = {
                          let l12 = *ptr2.add(64).cast::<i64>();
                          let l13 = *ptr2.add(72).cast::<i32>();

                          super::super::super::wasi::clocks::system_clock::Instant{
                            seconds: l12,
                            nanoseconds: l13 as u32,
                          }
                        };
                        Some(e)
                      }
                      _ => _rt::invalid_enum_discriminant(),
                    },
                    status_change_timestamp: match l14 {
                      0 => None,
                      1 => {
                        let e = {
                          let l15 = *ptr2.add(88).cast::<i64>();
                          let l16 = *ptr2.add(96).cast::<i32>();

                          super::super::super::wasi::clocks::system_clock::Instant{
                            seconds: l15,
                            nanoseconds: l16 as u32,
                          }
                        };
                        Some(e)
                      }
                      _ => _rt::invalid_enum_discriminant(),
                    },
                  }
                };
                Ok(e)
              }
              1 => {
                let e = {
                  let l17 = i32::from(*ptr2.add(8).cast::<u8>());

                  ErrorCode::_lift(l17 as u8)
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            };
            result18
          }
        }
      }
      impl Descriptor {
        #[allow(unused_unsafe, clippy::all)]
        /// Adjust the timestamps of a file or directory.
        ///
        /// Note: This is similar to `utimensat` in POSIX.
        ///
        /// Note: This was called `path_filestat_set_times` in earlier versions of
        /// WASI.
        #[allow(async_fn_in_trait)]
        pub fn set_times_at(&self,path_flags: PathFlags,path: &str,data_access_timestamp: NewTimestamp,data_modification_timestamp: NewTimestamp,) -> Result<(),ErrorCode>{
          unsafe {

            #[repr(align(1))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 2]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2]);
            let flags0 = path_flags;
            let vec1 = path;
            let ptr1 = vec1.as_ptr().cast::<u8>();
            let len1 = vec1.len();
            let (result3_0,result3_1,result3_2,) = match data_access_timestamp {
              NewTimestamp::NoChange=> {
                (0i32, 0i64, 0i32)
              }
              NewTimestamp::Now=> {
                (1i32, 0i64, 0i32)
              }
              NewTimestamp::Timestamp(e) => {
                let super::super::super::wasi::clocks::system_clock::Instant{ seconds:seconds2, nanoseconds:nanoseconds2, } = e;

                (2i32, _rt::as_i64(seconds2), _rt::as_i32(nanoseconds2))
              },
            };
            let (result5_0,result5_1,result5_2,) = match data_modification_timestamp {
              NewTimestamp::NoChange=> {
                (0i32, 0i64, 0i32)
              }
              NewTimestamp::Now=> {
                (1i32, 0i64, 0i32)
              }
              NewTimestamp::Timestamp(e) => {
                let super::super::super::wasi::clocks::system_clock::Instant{ seconds:seconds4, nanoseconds:nanoseconds4, } = e;

                (2i32, _rt::as_i64(seconds4), _rt::as_i32(nanoseconds4))
              },
            };
            let ptr6 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:filesystem/types@0.3.0-rc-2026-01-06")]
            unsafe extern "C" {
              #[link_name = "[method]descriptor.set-times-at"]
              fn wit_import7(_: i32, _: i32, _: *mut u8, _: usize, _: i32, _: i64, _: i32, _: i32, _: i64, _: i32, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import7(_: i32, _: i32, _: *mut u8, _: usize, _: i32, _: i64, _: i32, _: i32, _: i64, _: i32, _: *mut u8, ) { unreachable!() }
            wit_import7((self).handle() as i32, (flags0.bits() >> 0) as i32, ptr1.cast_mut(), len1, result3_0, result3_1, result3_2, result5_0, result5_1, result5_2, ptr6);
            let l8 = i32::from(*ptr6.add(0).cast::<u8>());
            let result10 = match l8 {
              0 => {
                let e = ();
                Ok(e)
              }
              1 => {
                let e = {
                  let l9 = i32::from(*ptr6.add(1).cast::<u8>());

                  ErrorCode::_lift(l9 as u8)
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            };
            result10
          }
        }
      }
      impl Descriptor {
        #[allow(unused_unsafe, clippy::all)]
        /// Create a hard link.
        ///
        /// Fails with `error-code::no-entry` if the old path does not exist,
        /// with `error-code::exist` if the new path already exists, and
        /// `error-code::not-permitted` if the old path is not a file.
        ///
        /// Note: This is similar to `linkat` in POSIX.
        #[allow(async_fn_in_trait)]
        pub fn link_at(&self,old_path_flags: PathFlags,old_path: &str,new_descriptor: &Descriptor,new_path: &str,) -> Result<(),ErrorCode>{
          unsafe {

            #[repr(align(1))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 2]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2]);
            let flags0 = old_path_flags;
            let vec1 = old_path;
            let ptr1 = vec1.as_ptr().cast::<u8>();
            let len1 = vec1.len();
            let vec2 = new_path;
            let ptr2 = vec2.as_ptr().cast::<u8>();
            let len2 = vec2.len();
            let ptr3 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:filesystem/types@0.3.0-rc-2026-01-06")]
            unsafe extern "C" {
              #[link_name = "[method]descriptor.link-at"]
              fn wit_import4(_: i32, _: i32, _: *mut u8, _: usize, _: i32, _: *mut u8, _: usize, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import4(_: i32, _: i32, _: *mut u8, _: usize, _: i32, _: *mut u8, _: usize, _: *mut u8, ) { unreachable!() }
            wit_import4((self).handle() as i32, (flags0.bits() >> 0) as i32, ptr1.cast_mut(), len1, (new_descriptor).handle() as i32, ptr2.cast_mut(), len2, ptr3);
            let l5 = i32::from(*ptr3.add(0).cast::<u8>());
            let result7 = match l5 {
              0 => {
                let e = ();
                Ok(e)
              }
              1 => {
                let e = {
                  let l6 = i32::from(*ptr3.add(1).cast::<u8>());

                  ErrorCode::_lift(l6 as u8)
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            };
            result7
          }
        }
      }
      impl Descriptor {
        #[allow(unused_unsafe, clippy::all)]
        /// Open a file or directory.
        ///
        /// If `flags` contains `descriptor-flags::mutate-directory`, and the base
        /// descriptor doesn't have `descriptor-flags::mutate-directory` set,
        /// `open-at` fails with `error-code::read-only`.
        ///
        /// If `flags` contains `write` or `mutate-directory`, or `open-flags`
        /// contains `truncate` or `create`, and the base descriptor doesn't have
        /// `descriptor-flags::mutate-directory` set, `open-at` fails with
        /// `error-code::read-only`.
        ///
        /// Note: This is similar to `openat` in POSIX.
        #[allow(async_fn_in_trait)]
        pub fn open_at(&self,path_flags: PathFlags,path: &str,open_flags: OpenFlags,flags: DescriptorFlags,) -> Result<Descriptor,ErrorCode>{
          unsafe {

            #[repr(align(4))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 8]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 8]);
            let flags0 = path_flags;
            let vec1 = path;
            let ptr1 = vec1.as_ptr().cast::<u8>();
            let len1 = vec1.len();
            let flags2 = open_flags;
            let flags3 = flags;
            let ptr4 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:filesystem/types@0.3.0-rc-2026-01-06")]
            unsafe extern "C" {
              #[link_name = "[method]descriptor.open-at"]
              fn wit_import5(_: i32, _: i32, _: *mut u8, _: usize, _: i32, _: i32, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import5(_: i32, _: i32, _: *mut u8, _: usize, _: i32, _: i32, _: *mut u8, ) { unreachable!() }
            wit_import5((self).handle() as i32, (flags0.bits() >> 0) as i32, ptr1.cast_mut(), len1, (flags2.bits() >> 0) as i32, (flags3.bits() >> 0) as i32, ptr4);
            let l6 = i32::from(*ptr4.add(0).cast::<u8>());
            let result9 = match l6 {
              0 => {
                let e = {
                  let l7 = *ptr4.add(4).cast::<i32>();

                  Descriptor::from_handle(l7 as u32)
                };
                Ok(e)
              }
              1 => {
                let e = {
                  let l8 = i32::from(*ptr4.add(4).cast::<u8>());

                  ErrorCode::_lift(l8 as u8)
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            };
            result9
          }
        }
      }
      impl Descriptor {
        #[allow(unused_unsafe, clippy::all)]
        /// Read the contents of a symbolic link.
        ///
        /// If the contents contain an absolute or rooted path in the underlying
        /// filesystem, this function fails with `error-code::not-permitted`.
        ///
        /// Note: This is similar to `readlinkat` in POSIX.
        #[allow(async_fn_in_trait)]
        pub fn readlink_at(&self,path: &str,) -> Result<_rt::String,ErrorCode>{
          unsafe {

            #[cfg_attr(target_pointer_width="64", repr(align(8)))]
            #[cfg_attr(target_pointer_width="32", repr(align(4)))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 3*::core::mem::size_of::<*const u8>()]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 3*::core::mem::size_of::<*const u8>()]);
            let vec0 = path;
            let ptr0 = vec0.as_ptr().cast::<u8>();
            let len0 = vec0.len();
            let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:filesystem/types@0.3.0-rc-2026-01-06")]
            unsafe extern "C" {
              #[link_name = "[method]descriptor.readlink-at"]
              fn wit_import2(_: i32, _: *mut u8, _: usize, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import2(_: i32, _: *mut u8, _: usize, _: *mut u8, ) { unreachable!() }
            wit_import2((self).handle() as i32, ptr0.cast_mut(), len0, ptr1);
            let l3 = i32::from(*ptr1.add(0).cast::<u8>());
            let result8 = match l3 {
              0 => {
                let e = {
                  let l4 = *ptr1.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                  let l5 = *ptr1.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>();
                  let len6 = l5;
                  let bytes6 = _rt::Vec::from_raw_parts(l4.cast(), len6, len6);

                  _rt::string_lift(bytes6)
                };
                Ok(e)
              }
              1 => {
                let e = {
                  let l7 = i32::from(*ptr1.add(::core::mem::size_of::<*const u8>()).cast::<u8>());

                  ErrorCode::_lift(l7 as u8)
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            };
            result8
          }
        }
      }
      impl Descriptor {
        #[allow(unused_unsafe, clippy::all)]
        /// Remove a directory.
        ///
        /// Return `error-code::not-empty` if the directory is not empty.
        ///
        /// Note: This is similar to `unlinkat(fd, path, AT_REMOVEDIR)` in POSIX.
        #[allow(async_fn_in_trait)]
        pub fn remove_directory_at(&self,path: &str,) -> Result<(),ErrorCode>{
          unsafe {

            #[repr(align(1))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 2]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2]);
            let vec0 = path;
            let ptr0 = vec0.as_ptr().cast::<u8>();
            let len0 = vec0.len();
            let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:filesystem/types@0.3.0-rc-2026-01-06")]
            unsafe extern "C" {
              #[link_name = "[method]descriptor.remove-directory-at"]
              fn wit_import2(_: i32, _: *mut u8, _: usize, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import2(_: i32, _: *mut u8, _: usize, _: *mut u8, ) { unreachable!() }
            wit_import2((self).handle() as i32, ptr0.cast_mut(), len0, ptr1);
            let l3 = i32::from(*ptr1.add(0).cast::<u8>());
            let result5 = match l3 {
              0 => {
                let e = ();
                Ok(e)
              }
              1 => {
                let e = {
                  let l4 = i32::from(*ptr1.add(1).cast::<u8>());

                  ErrorCode::_lift(l4 as u8)
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            };
            result5
          }
        }
      }
      impl Descriptor {
        #[allow(unused_unsafe, clippy::all)]
        /// Rename a filesystem object.
        ///
        /// Note: This is similar to `renameat` in POSIX.
        #[allow(async_fn_in_trait)]
        pub fn rename_at(&self,old_path: &str,new_descriptor: &Descriptor,new_path: &str,) -> Result<(),ErrorCode>{
          unsafe {

            #[repr(align(1))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 2]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2]);
            let vec0 = old_path;
            let ptr0 = vec0.as_ptr().cast::<u8>();
            let len0 = vec0.len();
            let vec1 = new_path;
            let ptr1 = vec1.as_ptr().cast::<u8>();
            let len1 = vec1.len();
            let ptr2 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:filesystem/types@0.3.0-rc-2026-01-06")]
            unsafe extern "C" {
              #[link_name = "[method]descriptor.rename-at"]
              fn wit_import3(_: i32, _: *mut u8, _: usize, _: i32, _: *mut u8, _: usize, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import3(_: i32, _: *mut u8, _: usize, _: i32, _: *mut u8, _: usize, _: *mut u8, ) { unreachable!() }
            wit_import3((self).handle() as i32, ptr0.cast_mut(), len0, (new_descriptor).handle() as i32, ptr1.cast_mut(), len1, ptr2);
            let l4 = i32::from(*ptr2.add(0).cast::<u8>());
            let result6 = match l4 {
              0 => {
                let e = ();
                Ok(e)
              }
              1 => {
                let e = {
                  let l5 = i32::from(*ptr2.add(1).cast::<u8>());

                  ErrorCode::_lift(l5 as u8)
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            };
            result6
          }
        }
      }
      impl Descriptor {
        #[allow(unused_unsafe, clippy::all)]
        /// Create a symbolic link (also known as a "symlink").
        ///
        /// If `old-path` starts with `/`, the function fails with
        /// `error-code::not-permitted`.
        ///
        /// Note: This is similar to `symlinkat` in POSIX.
        #[allow(async_fn_in_trait)]
        pub fn symlink_at(&self,old_path: &str,new_path: &str,) -> Result<(),ErrorCode>{
          unsafe {

            #[repr(align(1))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 2]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2]);
            let vec0 = old_path;
            let ptr0 = vec0.as_ptr().cast::<u8>();
            let len0 = vec0.len();
            let vec1 = new_path;
            let ptr1 = vec1.as_ptr().cast::<u8>();
            let len1 = vec1.len();
            let ptr2 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:filesystem/types@0.3.0-rc-2026-01-06")]
            unsafe extern "C" {
              #[link_name = "[method]descriptor.symlink-at"]
              fn wit_import3(_: i32, _: *mut u8, _: usize, _: *mut u8, _: usize, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import3(_: i32, _: *mut u8, _: usize, _: *mut u8, _: usize, _: *mut u8, ) { unreachable!() }
            wit_import3((self).handle() as i32, ptr0.cast_mut(), len0, ptr1.cast_mut(), len1, ptr2);
            let l4 = i32::from(*ptr2.add(0).cast::<u8>());
            let result6 = match l4 {
              0 => {
                let e = ();
                Ok(e)
              }
              1 => {
                let e = {
                  let l5 = i32::from(*ptr2.add(1).cast::<u8>());

                  ErrorCode::_lift(l5 as u8)
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            };
            result6
          }
        }
      }
      impl Descriptor {
        #[allow(unused_unsafe, clippy::all)]
        /// Unlink a filesystem object that is not a directory.
        ///
        /// Return `error-code::is-directory` if the path refers to a directory.
        /// Note: This is similar to `unlinkat(fd, path, 0)` in POSIX.
        #[allow(async_fn_in_trait)]
        pub fn unlink_file_at(&self,path: &str,) -> Result<(),ErrorCode>{
          unsafe {

            #[repr(align(1))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 2]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2]);
            let vec0 = path;
            let ptr0 = vec0.as_ptr().cast::<u8>();
            let len0 = vec0.len();
            let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:filesystem/types@0.3.0-rc-2026-01-06")]
            unsafe extern "C" {
              #[link_name = "[method]descriptor.unlink-file-at"]
              fn wit_import2(_: i32, _: *mut u8, _: usize, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import2(_: i32, _: *mut u8, _: usize, _: *mut u8, ) { unreachable!() }
            wit_import2((self).handle() as i32, ptr0.cast_mut(), len0, ptr1);
            let l3 = i32::from(*ptr1.add(0).cast::<u8>());
            let result5 = match l3 {
              0 => {
                let e = ();
                Ok(e)
              }
              1 => {
                let e = {
                  let l4 = i32::from(*ptr1.add(1).cast::<u8>());

                  ErrorCode::_lift(l4 as u8)
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            };
            result5
          }
        }
      }
      impl Descriptor {
        #[allow(unused_unsafe, clippy::all)]
        /// Test whether two descriptors refer to the same filesystem object.
        ///
        /// In POSIX, this corresponds to testing whether the two descriptors have the
        /// same device (`st_dev`) and inode (`st_ino` or `d_ino`) numbers.
        /// wasi-filesystem does not expose device and inode numbers, so this function
        /// may be used instead.
        #[allow(async_fn_in_trait)]
        pub fn is_same_object(&self,other: &Descriptor,) -> bool{
          unsafe {

            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:filesystem/types@0.3.0-rc-2026-01-06")]
            unsafe extern "C" {
              #[link_name = "[method]descriptor.is-same-object"]
              fn wit_import0(_: i32, _: i32, ) -> i32;
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import0(_: i32, _: i32, ) -> i32 { unreachable!() }
            let ret = wit_import0((self).handle() as i32, (other).handle() as i32);
            _rt::bool_lift(ret as u8)
          }
        }
      }
      impl Descriptor {
        #[allow(unused_unsafe, clippy::all)]
        /// Return a hash of the metadata associated with a filesystem object referred
        /// to by a descriptor.
        ///
        /// This returns a hash of the last-modification timestamp and file size, and
        /// may also include the inode number, device number, birth timestamp, and
        /// other metadata fields that may change when the file is modified or
        /// replaced. It may also include a secret value chosen by the
        /// implementation and not otherwise exposed.
        ///
        /// Implementations are encouraged to provide the following properties:
        ///
        ///  - If the file is not modified or replaced, the computed hash value should
        ///    usually not change.
        ///  - If the object is modified or replaced, the computed hash value should
        ///    usually change.
        ///  - The inputs to the hash should not be easily computable from the
        ///    computed hash.
        ///
        /// However, none of these is required.
        #[allow(async_fn_in_trait)]
        pub fn metadata_hash(&self,) -> Result<MetadataHashValue,ErrorCode>{
          unsafe {

            #[repr(align(8))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 24]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 24]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:filesystem/types@0.3.0-rc-2026-01-06")]
            unsafe extern "C" {
              #[link_name = "[method]descriptor.metadata-hash"]
              fn wit_import1(_: i32, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, ) { unreachable!() }
            wit_import1((self).handle() as i32, ptr0);
            let l2 = i32::from(*ptr0.add(0).cast::<u8>());
            let result6 = match l2 {
              0 => {
                let e = {
                  let l3 = *ptr0.add(8).cast::<i64>();
                  let l4 = *ptr0.add(16).cast::<i64>();

                  MetadataHashValue{
                    lower: l3 as u64,
                    upper: l4 as u64,
                  }
                };
                Ok(e)
              }
              1 => {
                let e = {
                  let l5 = i32::from(*ptr0.add(8).cast::<u8>());

                  ErrorCode::_lift(l5 as u8)
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            };
            result6
          }
        }
      }
      impl Descriptor {
        #[allow(unused_unsafe, clippy::all)]
        /// Return a hash of the metadata associated with a filesystem object referred
        /// to by a directory descriptor and a relative path.
        ///
        /// This performs the same hash computation as `metadata-hash`.
        #[allow(async_fn_in_trait)]
        pub fn metadata_hash_at(&self,path_flags: PathFlags,path: &str,) -> Result<MetadataHashValue,ErrorCode>{
          unsafe {

            #[repr(align(8))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 24]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 24]);
            let flags0 = path_flags;
            let vec1 = path;
            let ptr1 = vec1.as_ptr().cast::<u8>();
            let len1 = vec1.len();
            let ptr2 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:filesystem/types@0.3.0-rc-2026-01-06")]
            unsafe extern "C" {
              #[link_name = "[method]descriptor.metadata-hash-at"]
              fn wit_import3(_: i32, _: i32, _: *mut u8, _: usize, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import3(_: i32, _: i32, _: *mut u8, _: usize, _: *mut u8, ) { unreachable!() }
            wit_import3((self).handle() as i32, (flags0.bits() >> 0) as i32, ptr1.cast_mut(), len1, ptr2);
            let l4 = i32::from(*ptr2.add(0).cast::<u8>());
            let result8 = match l4 {
              0 => {
                let e = {
                  let l5 = *ptr2.add(8).cast::<i64>();
                  let l6 = *ptr2.add(16).cast::<i64>();

                  MetadataHashValue{
                    lower: l5 as u64,
                    upper: l6 as u64,
                  }
                };
                Ok(e)
              }
              1 => {
                let e = {
                  let l7 = i32::from(*ptr2.add(8).cast::<u8>());

                  ErrorCode::_lift(l7 as u8)
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            };
            result8
          }
        }
      }

    }


    #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
    pub mod preopens {
      #[used]
      #[doc(hidden)]
      static __FORCE_SECTION_REF: fn() =
      super::super::super::__link_custom_section_describing_imports;
      
      use super::super::super::_rt;
      pub type Descriptor = super::super::super::wasi::filesystem::types::Descriptor;
      #[allow(unused_unsafe, clippy::all)]
      /// Return the set of preopened directories, and their paths.
      #[allow(async_fn_in_trait)]
      pub fn get_directories() -> _rt::Vec::<(Descriptor,_rt::String,)>{
        unsafe {

          #[cfg_attr(target_pointer_width="64", repr(align(8)))]
          #[cfg_attr(target_pointer_width="32", repr(align(4)))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 2*::core::mem::size_of::<*const u8>()]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2*::core::mem::size_of::<*const u8>()]);
          let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:filesystem/preopens@0.3.0-rc-2026-01-06")]
          unsafe extern "C" {
            #[link_name = "get-directories"]
            fn wit_import1(_: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn wit_import1(_: *mut u8, ) { unreachable!() }
          wit_import1(ptr0);
          let l2 = *ptr0.add(0).cast::<*mut u8>();
          let l3 = *ptr0.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
          let base8 = l2;
          let len8 = l3;
          let mut result8 = _rt::Vec::with_capacity(len8);
          for i in 0..len8 {
            let base = base8.add(i * (3*::core::mem::size_of::<*const u8>()));
            let e8 = {
              let l4 = *base.add(0).cast::<i32>();
              let l5 = *base.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
              let l6 = *base.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>();
              let len7 = l6;
              let bytes7 = _rt::Vec::from_raw_parts(l5.cast(), len7, len7);

              (super::super::super::wasi::filesystem::types::Descriptor::from_handle(l4 as u32), _rt::string_lift(bytes7))
            };
            result8.push(e8);
          }
          _rt::cabi_dealloc(base8, len8 * (3*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>());
          let result9 = result8;
          result9
        }
      }

    }

  }
  pub mod random {
    /// WASI Random is a random data API.
    ///
    /// It is intended to be portable at least between Unix-family platforms and
    /// Windows.
    #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
    pub mod random {
      #[used]
      #[doc(hidden)]
      static __FORCE_SECTION_REF: fn() =
      super::super::super::__link_custom_section_describing_imports;
      
      use super::super::super::_rt;
      #[allow(unused_unsafe, clippy::all)]
      /// Return `len` cryptographically-secure random or pseudo-random bytes.
      ///
      /// This function must produce data at least as cryptographically secure and
      /// fast as an adequately seeded cryptographically-secure pseudo-random
      /// number generator (CSPRNG). It must not block, from the perspective of
      /// the calling program, under any circumstances, including on the first
      /// request and on requests for numbers of bytes. The returned data must
      /// always be unpredictable.
      ///
      /// This function must always return fresh data. Deterministic environments
      /// must omit this function, rather than implementing it with deterministic
      /// data.
      #[allow(async_fn_in_trait)]
      pub fn get_random_bytes(len: u64,) -> _rt::Vec::<u8>{
        unsafe {

          #[cfg_attr(target_pointer_width="64", repr(align(8)))]
          #[cfg_attr(target_pointer_width="32", repr(align(4)))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 2*::core::mem::size_of::<*const u8>()]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2*::core::mem::size_of::<*const u8>()]);
          let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:random/random@0.3.0-rc-2026-01-06")]
          unsafe extern "C" {
            #[link_name = "get-random-bytes"]
            fn wit_import1(_: i64, _: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn wit_import1(_: i64, _: *mut u8, ) { unreachable!() }
          wit_import1(_rt::as_i64(&len), ptr0);
          let l2 = *ptr0.add(0).cast::<*mut u8>();
          let l3 = *ptr0.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
          let len4 = l3;
          let result5 = <_ as From<_rt::Vec<_>>>::from(_rt::Vec::from_raw_parts(l2.cast(), len4, len4));
          result5
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Return a cryptographically-secure random or pseudo-random `u64` value.
      ///
      /// This function returns the same type of data as `get-random-bytes`,
      /// represented as a `u64`.
      #[allow(async_fn_in_trait)]
      pub fn get_random_u64() -> u64{
        unsafe {

          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:random/random@0.3.0-rc-2026-01-06")]
          unsafe extern "C" {
            #[link_name = "get-random-u64"]
            fn wit_import0() -> i64;
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn wit_import0() -> i64 { unreachable!() }
          let ret = wit_import0();
          ret as u64
        }
      }

    }

    /// The insecure interface for insecure pseudo-random numbers.
    ///
    /// It is intended to be portable at least between Unix-family platforms and
    /// Windows.
    #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
    pub mod insecure {
      #[used]
      #[doc(hidden)]
      static __FORCE_SECTION_REF: fn() =
      super::super::super::__link_custom_section_describing_imports;
      
      use super::super::super::_rt;
      #[allow(unused_unsafe, clippy::all)]
      /// Return `len` insecure pseudo-random bytes.
      ///
      /// This function is not cryptographically secure. Do not use it for
      /// anything related to security.
      ///
      /// There are no requirements on the values of the returned bytes, however
      /// implementations are encouraged to return evenly distributed values with
      /// a long period.
      #[allow(async_fn_in_trait)]
      pub fn get_insecure_random_bytes(len: u64,) -> _rt::Vec::<u8>{
        unsafe {

          #[cfg_attr(target_pointer_width="64", repr(align(8)))]
          #[cfg_attr(target_pointer_width="32", repr(align(4)))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 2*::core::mem::size_of::<*const u8>()]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2*::core::mem::size_of::<*const u8>()]);
          let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:random/insecure@0.3.0-rc-2026-01-06")]
          unsafe extern "C" {
            #[link_name = "get-insecure-random-bytes"]
            fn wit_import1(_: i64, _: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn wit_import1(_: i64, _: *mut u8, ) { unreachable!() }
          wit_import1(_rt::as_i64(&len), ptr0);
          let l2 = *ptr0.add(0).cast::<*mut u8>();
          let l3 = *ptr0.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
          let len4 = l3;
          let result5 = <_ as From<_rt::Vec<_>>>::from(_rt::Vec::from_raw_parts(l2.cast(), len4, len4));
          result5
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Return an insecure pseudo-random `u64` value.
      ///
      /// This function returns the same type of pseudo-random data as
      /// `get-insecure-random-bytes`, represented as a `u64`.
      #[allow(async_fn_in_trait)]
      pub fn get_insecure_random_u64() -> u64{
        unsafe {

          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:random/insecure@0.3.0-rc-2026-01-06")]
          unsafe extern "C" {
            #[link_name = "get-insecure-random-u64"]
            fn wit_import0() -> i64;
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn wit_import0() -> i64 { unreachable!() }
          let ret = wit_import0();
          ret as u64
        }
      }

    }

    /// The insecure-seed interface for seeding hash-map DoS resistance.
    ///
    /// It is intended to be portable at least between Unix-family platforms and
    /// Windows.
    #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
    pub mod insecure_seed {
      #[used]
      #[doc(hidden)]
      static __FORCE_SECTION_REF: fn() =
      super::super::super::__link_custom_section_describing_imports;
      
      #[allow(unused_unsafe, clippy::all)]
      /// Return a 128-bit value that may contain a pseudo-random value.
      ///
      /// The returned value is not required to be computed from a CSPRNG, and may
      /// even be entirely deterministic. Host implementations are encouraged to
      /// provide pseudo-random values to any program exposed to
      /// attacker-controlled content, to enable DoS protection built into many
      /// languages' hash-map implementations.
      ///
      /// This function is intended to only be called once, by a source language
      /// to initialize Denial Of Service (DoS) protection in its hash-map
      /// implementation.
      ///
      /// # Expected future evolution
      ///
      /// This will likely be changed to a value import, to prevent it from being
      /// called multiple times and potentially used for purposes other than DoS
      /// protection.
      #[allow(async_fn_in_trait)]
      pub fn get_insecure_seed() -> (u64,u64,){
        unsafe {

          #[repr(align(8))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 16]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 16]);
          let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:random/insecure-seed@0.3.0-rc-2026-01-06")]
          unsafe extern "C" {
            #[link_name = "get-insecure-seed"]
            fn wit_import1(_: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn wit_import1(_: *mut u8, ) { unreachable!() }
          wit_import1(ptr0);
          let l2 = *ptr0.add(0).cast::<i64>();
          let l3 = *ptr0.add(8).cast::<i64>();
          let result4 = (l2 as u64, l3 as u64);
          result4
        }
      }

    }

  }
  pub mod sockets {

    #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
    pub mod types {
      #[used]
      #[doc(hidden)]
      static __FORCE_SECTION_REF: fn() =
      super::super::super::__link_custom_section_describing_imports;
      
      use super::super::super::_rt;
      pub type Duration = super::super::super::wasi::clocks::types::Duration;
      /// Error codes.
      ///
      /// In theory, every API can return any error code.
      /// In practice, API's typically only return the errors documented per API
      /// combined with a couple of errors that are always possible:
      /// - `unknown`
      /// - `access-denied`
      /// - `not-supported`
      /// - `out-of-memory`
      ///
      /// See each individual API for what the POSIX equivalents are. They sometimes differ per API.
      #[repr(u8)]
      #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd, serde::Deserialize, serde::Serialize)]
      pub enum ErrorCode {
        /// Unknown error
        Unknown,
        /// Access denied.
        ///
        /// POSIX equivalent: EACCES, EPERM
        AccessDenied,
        /// The operation is not supported.
        ///
        /// POSIX equivalent: EOPNOTSUPP
        NotSupported,
        /// One of the arguments is invalid.
        ///
        /// POSIX equivalent: EINVAL
        InvalidArgument,
        /// Not enough memory to complete the operation.
        ///
        /// POSIX equivalent: ENOMEM, ENOBUFS, EAI_MEMORY
        OutOfMemory,
        /// The operation timed out before it could finish completely.
        Timeout,
        /// The operation is not valid in the socket's current state.
        InvalidState,
        /// A bind operation failed because the provided address is not an address that the `network` can bind to.
        AddressNotBindable,
        /// A bind operation failed because the provided address is already in use or because there are no ephemeral ports available.
        AddressInUse,
        /// The remote address is not reachable
        RemoteUnreachable,
        /// The TCP connection was forcefully rejected
        ConnectionRefused,
        /// The TCP connection was reset.
        ConnectionReset,
        /// A TCP connection was aborted.
        ConnectionAborted,
        /// The size of a datagram sent to a UDP socket exceeded the maximum
        /// supported size.
        DatagramTooLarge,
      }
      impl ErrorCode{
        pub fn name(&self) -> &'static str {
          match self {
            ErrorCode::Unknown => "unknown",
            ErrorCode::AccessDenied => "access-denied",
            ErrorCode::NotSupported => "not-supported",
            ErrorCode::InvalidArgument => "invalid-argument",
            ErrorCode::OutOfMemory => "out-of-memory",
            ErrorCode::Timeout => "timeout",
            ErrorCode::InvalidState => "invalid-state",
            ErrorCode::AddressNotBindable => "address-not-bindable",
            ErrorCode::AddressInUse => "address-in-use",
            ErrorCode::RemoteUnreachable => "remote-unreachable",
            ErrorCode::ConnectionRefused => "connection-refused",
            ErrorCode::ConnectionReset => "connection-reset",
            ErrorCode::ConnectionAborted => "connection-aborted",
            ErrorCode::DatagramTooLarge => "datagram-too-large",
          }
        }
        pub fn message(&self) -> &'static str {
          match self {
            ErrorCode::Unknown => "Unknown error",
            ErrorCode::AccessDenied => "Access denied.

            POSIX equivalent: EACCES, EPERM",
            ErrorCode::NotSupported => "The operation is not supported.

            POSIX equivalent: EOPNOTSUPP",
            ErrorCode::InvalidArgument => "One of the arguments is invalid.

            POSIX equivalent: EINVAL",
            ErrorCode::OutOfMemory => "Not enough memory to complete the operation.

            POSIX equivalent: ENOMEM, ENOBUFS, EAI_MEMORY",
            ErrorCode::Timeout => "The operation timed out before it could finish completely.",
            ErrorCode::InvalidState => "The operation is not valid in the socket's current state.",
            ErrorCode::AddressNotBindable => "A bind operation failed because the provided address is not an address that the `network` can bind to.",
            ErrorCode::AddressInUse => "A bind operation failed because the provided address is already in use or because there are no ephemeral ports available.",
            ErrorCode::RemoteUnreachable => "The remote address is not reachable",
            ErrorCode::ConnectionRefused => "The TCP connection was forcefully rejected",
            ErrorCode::ConnectionReset => "The TCP connection was reset.",
            ErrorCode::ConnectionAborted => "A TCP connection was aborted.",
            ErrorCode::DatagramTooLarge => "The size of a datagram sent to a UDP socket exceeded the maximum
            supported size.",
          }
        }
      }
      impl ::core::fmt::Debug for ErrorCode{
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("ErrorCode")
          .field("code", &(*self as i32))
          .field("name", &self.name())
          .field("message", &self.message())
          .finish()
        }
      }
      impl ::core::fmt::Display for ErrorCode{
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          write!(f, "{} (error {})", self.name(), *self as i32)
        }
      }

      impl ::core::error::Error for ErrorCode {}

      impl ErrorCode{
        #[doc(hidden)]
        pub unsafe fn _lift(val: u8) -> ErrorCode{
          if !cfg!(debug_assertions) {
            return unsafe { ::core::mem::transmute(val) };
          }

          match val {
            0 => ErrorCode::Unknown,
            1 => ErrorCode::AccessDenied,
            2 => ErrorCode::NotSupported,
            3 => ErrorCode::InvalidArgument,
            4 => ErrorCode::OutOfMemory,
            5 => ErrorCode::Timeout,
            6 => ErrorCode::InvalidState,
            7 => ErrorCode::AddressNotBindable,
            8 => ErrorCode::AddressInUse,
            9 => ErrorCode::RemoteUnreachable,
            10 => ErrorCode::ConnectionRefused,
            11 => ErrorCode::ConnectionReset,
            12 => ErrorCode::ConnectionAborted,
            13 => ErrorCode::DatagramTooLarge,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }

      #[repr(u8)]
      #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd, serde::Deserialize, serde::Serialize)]
      pub enum IpAddressFamily {
        /// Similar to `AF_INET` in POSIX.
        Ipv4,
        /// Similar to `AF_INET6` in POSIX.
        Ipv6,
      }
      impl ::core::fmt::Debug for IpAddressFamily {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            IpAddressFamily::Ipv4 => {
              f.debug_tuple("IpAddressFamily::Ipv4").finish()
            }
            IpAddressFamily::Ipv6 => {
              f.debug_tuple("IpAddressFamily::Ipv6").finish()
            }
          }
        }
      }

      impl IpAddressFamily{
        #[doc(hidden)]
        pub unsafe fn _lift(val: u8) -> IpAddressFamily{
          if !cfg!(debug_assertions) {
            return unsafe { ::core::mem::transmute(val) };
          }

          match val {
            0 => IpAddressFamily::Ipv4,
            1 => IpAddressFamily::Ipv6,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }

      pub type Ipv4Address = (u8,u8,u8,u8,);
      pub type Ipv6Address = (u16,u16,u16,u16,u16,u16,u16,u16,);
      #[derive(Clone, Copy, PartialEq, serde::Deserialize, serde::Serialize)]
      pub enum IpAddress {
        Ipv4(Ipv4Address),
        Ipv6(Ipv6Address),
      }
      impl ::core::fmt::Debug for IpAddress {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            IpAddress::Ipv4(e) => {
              f.debug_tuple("IpAddress::Ipv4").field(e).finish()
            }
            IpAddress::Ipv6(e) => {
              f.debug_tuple("IpAddress::Ipv6").field(e).finish()
            }
          }
        }
      }
      #[repr(C)]
      #[derive(Clone, Copy, PartialEq, serde::Deserialize, serde::Serialize)]
      pub struct Ipv4SocketAddress {
        /// sin_port
        pub port: u16,
        /// sin_addr
        pub address: Ipv4Address,
      }
      impl ::core::fmt::Debug for Ipv4SocketAddress {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("Ipv4SocketAddress").field("port", &self.port).field("address", &self.address).finish()
        }
      }
      #[repr(C)]
      #[derive(Clone, Copy, PartialEq, serde::Deserialize, serde::Serialize)]
      pub struct Ipv6SocketAddress {
        /// sin6_port
        pub port: u16,
        /// sin6_flowinfo
        pub flow_info: u32,
        /// sin6_addr
        pub address: Ipv6Address,
        /// sin6_scope_id
        pub scope_id: u32,
      }
      impl ::core::fmt::Debug for Ipv6SocketAddress {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("Ipv6SocketAddress").field("port", &self.port).field("flow-info", &self.flow_info).field("address", &self.address).field("scope-id", &self.scope_id).finish()
        }
      }
      #[derive(Clone, Copy, PartialEq, serde::Deserialize, serde::Serialize)]
      pub enum IpSocketAddress {
        Ipv4(Ipv4SocketAddress),
        Ipv6(Ipv6SocketAddress),
      }
      impl ::core::fmt::Debug for IpSocketAddress {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            IpSocketAddress::Ipv4(e) => {
              f.debug_tuple("IpSocketAddress::Ipv4").field(e).finish()
            }
            IpSocketAddress::Ipv6(e) => {
              f.debug_tuple("IpSocketAddress::Ipv6").field(e).finish()
            }
          }
        }
      }
      /// A TCP socket resource.
      ///
      /// The socket can be in one of the following states:
      /// - `unbound`
      /// - `bound` (See note below)
      /// - `listening`
      /// - `connecting`
      /// - `connected`
      /// - `closed`
      /// See <https://github.com/WebAssembly/wasi-sockets/blob/main/TcpSocketOperationalSemantics-0.3.0-draft.md>
      /// for more information.
      ///
      /// Note: Except where explicitly mentioned, whenever this documentation uses
      /// the term "bound" without backticks it actually means: in the `bound` state *or higher*.
      /// (i.e. `bound`, `listening`, `connecting` or `connected`)
      ///
      /// In addition to the general error codes documented on the
      /// `types::error-code` type, TCP socket methods may always return
      /// `error(invalid-state)` when in the `closed` state.

      #[derive(Debug)]
      #[repr(transparent)]
      pub struct TcpSocket{
        handle: _rt::Resource<TcpSocket>,
      }

      impl TcpSocket{
        #[doc(hidden)]
        pub unsafe fn from_handle(handle: u32) -> Self {
          Self {
            handle: unsafe { _rt::Resource::from_handle(handle) },
          }
        }

        #[doc(hidden)]
        pub fn take_handle(&self) -> u32 {
          _rt::Resource::take_handle(&self.handle)
        }

        #[doc(hidden)]
        pub fn handle(&self) -> u32 {
          _rt::Resource::handle(&self.handle)
        }
      }
      

      unsafe impl _rt::WasmResource for TcpSocket{
        #[inline]
        unsafe fn drop(_handle: u32) {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2026-01-06")]
          unsafe extern "C" {
            #[link_name = "[resource-drop]tcp-socket"]
            fn drop(_: i32, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn drop(_: i32, ) { unreachable!() }
          
          unsafe { drop(_handle as i32); }
        }
      }
      
      /// A UDP socket handle.

      #[derive(Debug)]
      #[repr(transparent)]
      pub struct UdpSocket{
        handle: _rt::Resource<UdpSocket>,
      }

      impl UdpSocket{
        #[doc(hidden)]
        pub unsafe fn from_handle(handle: u32) -> Self {
          Self {
            handle: unsafe { _rt::Resource::from_handle(handle) },
          }
        }

        #[doc(hidden)]
        pub fn take_handle(&self) -> u32 {
          _rt::Resource::take_handle(&self.handle)
        }

        #[doc(hidden)]
        pub fn handle(&self) -> u32 {
          _rt::Resource::handle(&self.handle)
        }
      }
      

      unsafe impl _rt::WasmResource for UdpSocket{
        #[inline]
        unsafe fn drop(_handle: u32) {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2026-01-06")]
          unsafe extern "C" {
            #[link_name = "[resource-drop]udp-socket"]
            fn drop(_: i32, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn drop(_: i32, ) { unreachable!() }
          
          unsafe { drop(_handle as i32); }
        }
      }
      
      impl TcpSocket {
        #[allow(unused_unsafe, clippy::all)]
        /// Create a new TCP socket.
        ///
        /// Similar to `socket(AF_INET or AF_INET6, SOCK_STREAM, IPPROTO_TCP)` in POSIX.
        /// On IPv6 sockets, IPV6_V6ONLY is enabled by default and can't be configured otherwise.
        ///
        /// Unlike POSIX, WASI sockets have no notion of a socket-level
        /// `O_NONBLOCK` flag. Instead they fully rely on the Component Model's
        /// async support.
        ///
        /// # References
        /// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/socket.html>
        /// - <https://man7.org/linux/man-pages/man2/socket.2.html>
        /// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-wsasocketw>
        /// - <https://man.freebsd.org/cgi/man.cgi?query=socket&sektion=2>
        #[allow(async_fn_in_trait)]
        pub fn create(address_family: IpAddressFamily,) -> Result<TcpSocket,ErrorCode>{
          unsafe {

            #[repr(align(4))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 8]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 8]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2026-01-06")]
            unsafe extern "C" {
              #[link_name = "[static]tcp-socket.create"]
              fn wit_import1(_: i32, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, ) { unreachable!() }
            wit_import1(address_family.clone() as i32, ptr0);
            let l2 = i32::from(*ptr0.add(0).cast::<u8>());
            let result5 = match l2 {
              0 => {
                let e = {
                  let l3 = *ptr0.add(4).cast::<i32>();

                  TcpSocket::from_handle(l3 as u32)
                };
                Ok(e)
              }
              1 => {
                let e = {
                  let l4 = i32::from(*ptr0.add(4).cast::<u8>());

                  ErrorCode::_lift(l4 as u8)
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            };
            result5
          }
        }
      }
      impl TcpSocket {
        #[allow(unused_unsafe, clippy::all)]
        /// Bind the socket to the provided IP address and port.
        ///
        /// If the IP address is zero (`0.0.0.0` in IPv4, `::` in IPv6), it is left to the implementation to decide which
        /// network interface(s) to bind to.
        /// If the TCP/UDP port is zero, the socket will be bound to a random free port.
        ///
        /// Bind can be attempted multiple times on the same socket, even with
        /// different arguments on each iteration. But never concurrently and
        /// only as long as the previous bind failed. Once a bind succeeds, the
        /// binding can't be changed anymore.
        ///
        /// # Typical errors
        /// - `invalid-argument`:          The `local-address` has the wrong address family. (EAFNOSUPPORT, EFAULT on Windows)
        /// - `invalid-argument`:          `local-address` is not a unicast address. (EINVAL)
        /// - `invalid-argument`:          `local-address` is an IPv4-mapped IPv6 address. (EINVAL)
        /// - `invalid-state`:             The socket is already bound. (EINVAL)
        /// - `address-in-use`:            No ephemeral ports available. (EADDRINUSE, ENOBUFS on Windows)
        /// - `address-in-use`:            Address is already in use. (EADDRINUSE)
        /// - `address-not-bindable`:      `local-address` is not an address that can be bound to. (EADDRNOTAVAIL)
        ///
        /// # Implementors note
        /// When binding to a non-zero port, this bind operation shouldn't be affected by the TIME_WAIT
        /// state of a recently closed socket on the same local address. In practice this means that the SO_REUSEADDR
        /// socket option should be set implicitly on all platforms, except on Windows where this is the default behavior
        /// and SO_REUSEADDR performs something different entirely.
        ///
        /// # References
        /// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/bind.html>
        /// - <https://man7.org/linux/man-pages/man2/bind.2.html>
        /// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-bind>
        /// - <https://man.freebsd.org/cgi/man.cgi?query=bind&sektion=2&format=html>
        #[allow(async_fn_in_trait)]
        pub fn bind(&self,local_address: IpSocketAddress,) -> Result<(),ErrorCode>{
          unsafe {

            #[repr(align(1))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 2]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2]);
            let (result4_0,result4_1,result4_2,result4_3,result4_4,result4_5,result4_6,result4_7,result4_8,result4_9,result4_10,result4_11,) = match local_address {
              IpSocketAddress::Ipv4(e) => {
                let Ipv4SocketAddress{ port:port0, address:address0, } = e;
                let (t1_0, t1_1, t1_2, t1_3, ) = address0;

                (0i32, _rt::as_i32(port0), _rt::as_i32(t1_0), _rt::as_i32(t1_1), _rt::as_i32(t1_2), _rt::as_i32(t1_3), 0i32, 0i32, 0i32, 0i32, 0i32, 0i32)
              },
              IpSocketAddress::Ipv6(e) => {
                let Ipv6SocketAddress{ port:port2, flow_info:flow_info2, address:address2, scope_id:scope_id2, } = e;
                let (t3_0, t3_1, t3_2, t3_3, t3_4, t3_5, t3_6, t3_7, ) = address2;

                (1i32, _rt::as_i32(port2), _rt::as_i32(flow_info2), _rt::as_i32(t3_0), _rt::as_i32(t3_1), _rt::as_i32(t3_2), _rt::as_i32(t3_3), _rt::as_i32(t3_4), _rt::as_i32(t3_5), _rt::as_i32(t3_6), _rt::as_i32(t3_7), _rt::as_i32(scope_id2))
              },
            };
            let ptr5 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2026-01-06")]
            unsafe extern "C" {
              #[link_name = "[method]tcp-socket.bind"]
              fn wit_import6(_: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import6(_: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: *mut u8, ) { unreachable!() }
            wit_import6((self).handle() as i32, result4_0, result4_1, result4_2, result4_3, result4_4, result4_5, result4_6, result4_7, result4_8, result4_9, result4_10, result4_11, ptr5);
            let l7 = i32::from(*ptr5.add(0).cast::<u8>());
            let result9 = match l7 {
              0 => {
                let e = ();
                Ok(e)
              }
              1 => {
                let e = {
                  let l8 = i32::from(*ptr5.add(1).cast::<u8>());

                  ErrorCode::_lift(l8 as u8)
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            };
            result9
          }
        }
      }
      impl TcpSocket {
        #[allow(unused_unsafe, clippy::all)]
        /// Connect to a remote endpoint.
        ///
        /// On success, the socket is transitioned into the `connected` state and this function returns a connection resource.
        ///
        /// After a failed connection attempt, the socket will be in the `closed`
        /// state and the only valid action left is to `drop` the socket. A single
        /// socket can not be used to connect more than once.
        ///
        /// # Typical errors
        /// - `invalid-argument`:          The `remote-address` has the wrong address family. (EAFNOSUPPORT)
        /// - `invalid-argument`:          `remote-address` is not a unicast address. (EINVAL, ENETUNREACH on Linux, EAFNOSUPPORT on MacOS)
        /// - `invalid-argument`:          `remote-address` is an IPv4-mapped IPv6 address. (EINVAL, EADDRNOTAVAIL on Illumos)
        /// - `invalid-argument`:          The IP address in `remote-address` is set to INADDR_ANY (`0.0.0.0` / `::`). (EADDRNOTAVAIL on Windows)
        /// - `invalid-argument`:          The port in `remote-address` is set to 0. (EADDRNOTAVAIL on Windows)
        /// - `invalid-state`:             The socket is already in the `connecting` state. (EALREADY)
        /// - `invalid-state`:             The socket is already in the `connected` state. (EISCONN)
        /// - `invalid-state`:             The socket is already in the `listening` state. (EOPNOTSUPP, EINVAL on Windows)
        /// - `timeout`:                   Connection timed out. (ETIMEDOUT)
        /// - `connection-refused`:        The connection was forcefully rejected. (ECONNREFUSED)
        /// - `connection-reset`:          The connection was reset. (ECONNRESET)
        /// - `connection-aborted`:        The connection was aborted. (ECONNABORTED)
        /// - `remote-unreachable`:        The remote address is not reachable. (EHOSTUNREACH, EHOSTDOWN, ENETUNREACH, ENETDOWN, ENONET)
        /// - `address-in-use`:            Tried to perform an implicit bind, but there were no ephemeral ports available. (EADDRINUSE, EADDRNOTAVAIL on Linux, EAGAIN on BSD)
        ///
        /// # References
        /// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/connect.html>
        /// - <https://man7.org/linux/man-pages/man2/connect.2.html>
        /// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-connect>
        /// - <https://man.freebsd.org/cgi/man.cgi?connect>
        #[allow(async_fn_in_trait)]
        pub fn connect(&self,remote_address: IpSocketAddress,) -> Result<(),ErrorCode>{
          unsafe {

            #[repr(align(1))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 2]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2]);
            let (result4_0,result4_1,result4_2,result4_3,result4_4,result4_5,result4_6,result4_7,result4_8,result4_9,result4_10,result4_11,) = match remote_address {
              IpSocketAddress::Ipv4(e) => {
                let Ipv4SocketAddress{ port:port0, address:address0, } = e;
                let (t1_0, t1_1, t1_2, t1_3, ) = address0;

                (0i32, _rt::as_i32(port0), _rt::as_i32(t1_0), _rt::as_i32(t1_1), _rt::as_i32(t1_2), _rt::as_i32(t1_3), 0i32, 0i32, 0i32, 0i32, 0i32, 0i32)
              },
              IpSocketAddress::Ipv6(e) => {
                let Ipv6SocketAddress{ port:port2, flow_info:flow_info2, address:address2, scope_id:scope_id2, } = e;
                let (t3_0, t3_1, t3_2, t3_3, t3_4, t3_5, t3_6, t3_7, ) = address2;

                (1i32, _rt::as_i32(port2), _rt::as_i32(flow_info2), _rt::as_i32(t3_0), _rt::as_i32(t3_1), _rt::as_i32(t3_2), _rt::as_i32(t3_3), _rt::as_i32(t3_4), _rt::as_i32(t3_5), _rt::as_i32(t3_6), _rt::as_i32(t3_7), _rt::as_i32(scope_id2))
              },
            };
            let ptr5 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2026-01-06")]
            unsafe extern "C" {
              #[link_name = "[method]tcp-socket.connect"]
              fn wit_import6(_: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import6(_: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: *mut u8, ) { unreachable!() }
            wit_import6((self).handle() as i32, result4_0, result4_1, result4_2, result4_3, result4_4, result4_5, result4_6, result4_7, result4_8, result4_9, result4_10, result4_11, ptr5);
            let l7 = i32::from(*ptr5.add(0).cast::<u8>());
            let result9 = match l7 {
              0 => {
                let e = ();
                Ok(e)
              }
              1 => {
                let e = {
                  let l8 = i32::from(*ptr5.add(1).cast::<u8>());

                  ErrorCode::_lift(l8 as u8)
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            };
            result9
          }
        }
      }
      impl TcpSocket {
        #[allow(unused_unsafe, clippy::all)]
        /// Start listening and return a stream of new inbound connections.
        ///
        /// Transitions the socket into the `listening` state. This can be called
        /// at most once per socket.
        ///
        /// If the socket is not already explicitly bound, this function will
        /// implicitly bind the socket to a random free port.
        ///
        /// Normally, the returned sockets are bound, in the `connected` state
        /// and immediately ready for I/O. Though, depending on exact timing and
        /// circumstances, a newly accepted connection may already be `closed`
        /// by the time the server attempts to perform its first I/O on it. This
        /// is true regardless of whether the WASI implementation uses
        /// "synthesized" sockets or not (see Implementors Notes below).
        ///
        /// The following properties are inherited from the listener socket:
        /// - `address-family`
        /// - `keep-alive-enabled`
        /// - `keep-alive-idle-time`
        /// - `keep-alive-interval`
        /// - `keep-alive-count`
        /// - `hop-limit`
        /// - `receive-buffer-size`
        /// - `send-buffer-size`
        ///
        /// # Typical errors
        /// - `invalid-state`:             The socket is already in the `connected` state. (EISCONN, EINVAL on BSD)
        /// - `invalid-state`:             The socket is already in the `listening` state.
        /// - `address-in-use`:            Tried to perform an implicit bind, but there were no ephemeral ports available. (EADDRINUSE)
        ///
        /// # Implementors note
        /// This method returns a single perpetual stream that should only close
        /// on fatal errors (if any). Yet, the POSIX' `accept` function may also
        /// return transient errors (e.g. ECONNABORTED). The exact details differ
        /// per operation system. For example, the Linux manual mentions:
        ///
        /// > Linux accept() passes already-pending network errors on the new
        /// > socket as an error code from accept(). This behavior differs from
        /// > other BSD socket implementations. For reliable operation the
        /// > application should detect the network errors defined for the
        /// > protocol after accept() and treat them like EAGAIN by retrying.
        /// > In the case of TCP/IP, these are ENETDOWN, EPROTO, ENOPROTOOPT,
        /// > EHOSTDOWN, ENONET, EHOSTUNREACH, EOPNOTSUPP, and ENETUNREACH.
        /// Source: https://man7.org/linux/man-pages/man2/accept.2.html
        ///
        /// WASI implementations have two options to handle this:
        /// - Optionally log it and then skip over non-fatal errors returned by
        ///   `accept`. Guest code never gets to see these failures. Or:
        /// - Synthesize a `tcp-socket` resource that exposes the error when
        ///   attempting to send or receive on it. Guest code then sees these
        ///   failures as regular I/O errors.
        ///
        /// In either case, the stream returned by this `listen` method remains
        /// operational.
        ///
        /// # References
        /// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/listen.html>
        /// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/accept.html>
        /// - <https://man7.org/linux/man-pages/man2/listen.2.html>
        /// - <https://man7.org/linux/man-pages/man2/accept.2.html>
        /// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-listen>
        /// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-accept>
        /// - <https://man.freebsd.org/cgi/man.cgi?query=listen&sektion=2>
        /// - <https://man.freebsd.org/cgi/man.cgi?query=accept&sektion=2>
        #[allow(async_fn_in_trait)]
        pub fn listen(&self,) -> Result<wit_bindgen::rt::async_support::StreamReader<TcpSocket>,ErrorCode>{
          unsafe {

            #[repr(align(4))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 8]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 8]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2026-01-06")]
            unsafe extern "C" {
              #[link_name = "[method]tcp-socket.listen"]
              fn wit_import1(_: i32, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, ) { unreachable!() }
            wit_import1((self).handle() as i32, ptr0);
            let l2 = i32::from(*ptr0.add(0).cast::<u8>());
            let result5 = match l2 {
              0 => {
                let e = {
                  let l3 = *ptr0.add(4).cast::<i32>();

                  wit_bindgen::rt::async_support::StreamReader::new(l3 as u32, &super::super::super::wit_stream::vtable2::VTABLE)
                };
                Ok(e)
              }
              1 => {
                let e = {
                  let l4 = i32::from(*ptr0.add(4).cast::<u8>());

                  ErrorCode::_lift(l4 as u8)
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            };
            result5
          }
        }
      }
      impl TcpSocket {
        #[allow(unused_unsafe, clippy::all)]
        /// Transmit data to peer.
        ///
        /// The caller should close the stream when it has no more data to send
        /// to the peer. Under normal circumstances this will cause a FIN packet
        /// to be sent out. Closing the stream is equivalent to calling
        /// `shutdown(SHUT_WR)` in POSIX.
        ///
        /// This function may be called at most once and returns once the full
        /// contents of the stream are transmitted or an error is encountered.
        ///
        /// # Typical errors
        /// - `invalid-state`:             The socket is not in the `connected` state. (ENOTCONN)
        /// - `connection-reset`:          The connection was reset. (ECONNRESET)
        /// - `remote-unreachable`:        The remote address is not reachable. (EHOSTUNREACH, EHOSTDOWN, ENETUNREACH, ENETDOWN, ENONET)
        ///
        ///  # References
        /// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/send.html>
        /// - <https://man7.org/linux/man-pages/man2/send.2.html>
        /// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-send>
        /// - <https://man.freebsd.org/cgi/man.cgi?query=send&sektion=2>
        #[allow(async_fn_in_trait)]
        pub fn send(&self,data: wit_bindgen::rt::async_support::StreamReader<u8>,) -> Result<(),ErrorCode>{
          unsafe {

            #[repr(align(1))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 2]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2026-01-06")]
            unsafe extern "C" {
              #[link_name = "[method]tcp-socket.send"]
              fn wit_import1(_: i32, _: i32, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import1(_: i32, _: i32, _: *mut u8, ) { unreachable!() }
            wit_import1((self).handle() as i32, (&data).take_handle() as i32, ptr0);
            let l2 = i32::from(*ptr0.add(0).cast::<u8>());
            let result4 = match l2 {
              0 => {
                let e = ();
                Ok(e)
              }
              1 => {
                let e = {
                  let l3 = i32::from(*ptr0.add(1).cast::<u8>());

                  ErrorCode::_lift(l3 as u8)
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            };
            result4
          }
        }
      }
      impl TcpSocket {
        #[allow(unused_unsafe, clippy::all)]
        /// Read data from peer.
        ///
        /// This function returns a `stream` which provides the data received from the
        /// socket, and a `future` providing additional error information in case the
        /// socket is closed abnormally.
        ///
        /// If the socket is closed normally, `stream.read` on the `stream` will return
        /// `read-status::closed` with no `error-context` and the future resolves to
        /// the value `ok`. If the socket is closed abnormally, `stream.read` on the
        /// `stream` returns `read-status::closed` with an `error-context` and the future
        /// resolves to `err` with an `error-code`.
        ///
        /// `receive` is meant to be called only once per socket. If it is called more
        /// than once, the subsequent calls return a new `stream` that fails as if it
        /// were closed abnormally.
        ///
        /// If the caller is not expecting to receive any data from the peer,
        /// they may drop the stream. Any data still in the receive queue
        /// will be discarded. This is equivalent to calling `shutdown(SHUT_RD)`
        /// in POSIX.
        ///
        /// # Typical errors
        /// - `invalid-state`:             The socket is not in the `connected` state. (ENOTCONN)
        /// - `connection-reset`:          The connection was reset. (ECONNRESET)
        /// - `remote-unreachable`:        The remote address is not reachable. (EHOSTUNREACH, EHOSTDOWN, ENETUNREACH, ENETDOWN, ENONET)
        ///
        /// # References
        /// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/recv.html>
        /// - <https://man7.org/linux/man-pages/man2/recv.2.html>
        /// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-recv>
        /// - <https://man.freebsd.org/cgi/man.cgi?query=recv&sektion=2>
        #[allow(async_fn_in_trait)]
        pub fn receive(&self,) -> (wit_bindgen::rt::async_support::StreamReader<u8>,wit_bindgen::rt::async_support::FutureReader<Result<(),ErrorCode>>,){
          unsafe {

            #[repr(align(4))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 8]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 8]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2026-01-06")]
            unsafe extern "C" {
              #[link_name = "[method]tcp-socket.receive"]
              fn wit_import1(_: i32, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, ) { unreachable!() }
            wit_import1((self).handle() as i32, ptr0);
            let l2 = *ptr0.add(0).cast::<i32>();
            let l3 = *ptr0.add(4).cast::<i32>();
            let result4 = (wit_bindgen::rt::async_support::StreamReader::new(l2 as u32, &super::super::super::wit_stream::vtable0::VTABLE), wit_bindgen::rt::async_support::FutureReader::new(l3 as u32, &super::super::super::wit_future::vtable2::VTABLE));
            result4
          }
        }
      }
      impl TcpSocket {
        #[allow(unused_unsafe, clippy::all)]
        /// Get the bound local address.
        ///
        /// POSIX mentions:
        /// > If the socket has not been bound to a local name, the value
        /// > stored in the object pointed to by `address` is unspecified.
        ///
        /// WASI is stricter and requires `get-local-address` to return `invalid-state` when the socket hasn't been bound yet.
        ///
        /// # Typical errors
        /// - `invalid-state`: The socket is not bound to any local address.
        ///
        /// # References
        /// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/getsockname.html>
        /// - <https://man7.org/linux/man-pages/man2/getsockname.2.html>
        /// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-getsockname>
        /// - <https://man.freebsd.org/cgi/man.cgi?getsockname>
        #[allow(async_fn_in_trait)]
        pub fn get_local_address(&self,) -> Result<IpSocketAddress,ErrorCode>{
          unsafe {

            #[repr(align(4))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 36]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 36]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2026-01-06")]
            unsafe extern "C" {
              #[link_name = "[method]tcp-socket.get-local-address"]
              fn wit_import1(_: i32, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, ) { unreachable!() }
            wit_import1((self).handle() as i32, ptr0);
            let l2 = i32::from(*ptr0.add(0).cast::<u8>());
            let result22 = match l2 {
              0 => {
                let e = {
                  let l3 = i32::from(*ptr0.add(4).cast::<u8>());
                  let v20 = match l3 {
                    0 => {
                      let e20 = {
                        let l4 = i32::from(*ptr0.add(8).cast::<u16>());
                        let l5 = i32::from(*ptr0.add(10).cast::<u8>());
                        let l6 = i32::from(*ptr0.add(11).cast::<u8>());
                        let l7 = i32::from(*ptr0.add(12).cast::<u8>());
                        let l8 = i32::from(*ptr0.add(13).cast::<u8>());

                        Ipv4SocketAddress{
                          port: l4 as u16,
                          address: (l5 as u8, l6 as u8, l7 as u8, l8 as u8),
                        }
                      };
                      IpSocketAddress::Ipv4(e20)
                    }
                    n => {
                      debug_assert_eq!(n, 1, "invalid enum discriminant");
                      let e20 = {
                        let l9 = i32::from(*ptr0.add(8).cast::<u16>());
                        let l10 = *ptr0.add(12).cast::<i32>();
                        let l11 = i32::from(*ptr0.add(16).cast::<u16>());
                        let l12 = i32::from(*ptr0.add(18).cast::<u16>());
                        let l13 = i32::from(*ptr0.add(20).cast::<u16>());
                        let l14 = i32::from(*ptr0.add(22).cast::<u16>());
                        let l15 = i32::from(*ptr0.add(24).cast::<u16>());
                        let l16 = i32::from(*ptr0.add(26).cast::<u16>());
                        let l17 = i32::from(*ptr0.add(28).cast::<u16>());
                        let l18 = i32::from(*ptr0.add(30).cast::<u16>());
                        let l19 = *ptr0.add(32).cast::<i32>();

                        Ipv6SocketAddress{
                          port: l9 as u16,
                          flow_info: l10 as u32,
                          address: (l11 as u16, l12 as u16, l13 as u16, l14 as u16, l15 as u16, l16 as u16, l17 as u16, l18 as u16),
                          scope_id: l19 as u32,
                        }
                      };
                      IpSocketAddress::Ipv6(e20)
                    }
                  };

                  v20
                };
                Ok(e)
              }
              1 => {
                let e = {
                  let l21 = i32::from(*ptr0.add(4).cast::<u8>());

                  ErrorCode::_lift(l21 as u8)
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            };
            result22
          }
        }
      }
      impl TcpSocket {
        #[allow(unused_unsafe, clippy::all)]
        /// Get the remote address.
        ///
        /// # Typical errors
        /// - `invalid-state`: The socket is not connected to a remote address. (ENOTCONN)
        ///
        /// # References
        /// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/getpeername.html>
        /// - <https://man7.org/linux/man-pages/man2/getpeername.2.html>
        /// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-getpeername>
        /// - <https://man.freebsd.org/cgi/man.cgi?query=getpeername&sektion=2&n=1>
        #[allow(async_fn_in_trait)]
        pub fn get_remote_address(&self,) -> Result<IpSocketAddress,ErrorCode>{
          unsafe {

            #[repr(align(4))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 36]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 36]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2026-01-06")]
            unsafe extern "C" {
              #[link_name = "[method]tcp-socket.get-remote-address"]
              fn wit_import1(_: i32, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, ) { unreachable!() }
            wit_import1((self).handle() as i32, ptr0);
            let l2 = i32::from(*ptr0.add(0).cast::<u8>());
            let result22 = match l2 {
              0 => {
                let e = {
                  let l3 = i32::from(*ptr0.add(4).cast::<u8>());
                  let v20 = match l3 {
                    0 => {
                      let e20 = {
                        let l4 = i32::from(*ptr0.add(8).cast::<u16>());
                        let l5 = i32::from(*ptr0.add(10).cast::<u8>());
                        let l6 = i32::from(*ptr0.add(11).cast::<u8>());
                        let l7 = i32::from(*ptr0.add(12).cast::<u8>());
                        let l8 = i32::from(*ptr0.add(13).cast::<u8>());

                        Ipv4SocketAddress{
                          port: l4 as u16,
                          address: (l5 as u8, l6 as u8, l7 as u8, l8 as u8),
                        }
                      };
                      IpSocketAddress::Ipv4(e20)
                    }
                    n => {
                      debug_assert_eq!(n, 1, "invalid enum discriminant");
                      let e20 = {
                        let l9 = i32::from(*ptr0.add(8).cast::<u16>());
                        let l10 = *ptr0.add(12).cast::<i32>();
                        let l11 = i32::from(*ptr0.add(16).cast::<u16>());
                        let l12 = i32::from(*ptr0.add(18).cast::<u16>());
                        let l13 = i32::from(*ptr0.add(20).cast::<u16>());
                        let l14 = i32::from(*ptr0.add(22).cast::<u16>());
                        let l15 = i32::from(*ptr0.add(24).cast::<u16>());
                        let l16 = i32::from(*ptr0.add(26).cast::<u16>());
                        let l17 = i32::from(*ptr0.add(28).cast::<u16>());
                        let l18 = i32::from(*ptr0.add(30).cast::<u16>());
                        let l19 = *ptr0.add(32).cast::<i32>();

                        Ipv6SocketAddress{
                          port: l9 as u16,
                          flow_info: l10 as u32,
                          address: (l11 as u16, l12 as u16, l13 as u16, l14 as u16, l15 as u16, l16 as u16, l17 as u16, l18 as u16),
                          scope_id: l19 as u32,
                        }
                      };
                      IpSocketAddress::Ipv6(e20)
                    }
                  };

                  v20
                };
                Ok(e)
              }
              1 => {
                let e = {
                  let l21 = i32::from(*ptr0.add(4).cast::<u8>());

                  ErrorCode::_lift(l21 as u8)
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            };
            result22
          }
        }
      }
      impl TcpSocket {
        #[allow(unused_unsafe, clippy::all)]
        /// Whether the socket is in the `listening` state.
        ///
        /// Equivalent to the SO_ACCEPTCONN socket option.
        #[allow(async_fn_in_trait)]
        pub fn get_is_listening(&self,) -> bool{
          unsafe {

            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2026-01-06")]
            unsafe extern "C" {
              #[link_name = "[method]tcp-socket.get-is-listening"]
              fn wit_import0(_: i32, ) -> i32;
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import0(_: i32, ) -> i32 { unreachable!() }
            let ret = wit_import0((self).handle() as i32);
            _rt::bool_lift(ret as u8)
          }
        }
      }
      impl TcpSocket {
        #[allow(unused_unsafe, clippy::all)]
        /// Whether this is a IPv4 or IPv6 socket.
        ///
        /// This is the value passed to the constructor.
        ///
        /// Equivalent to the SO_DOMAIN socket option.
        #[allow(async_fn_in_trait)]
        pub fn get_address_family(&self,) -> IpAddressFamily{
          unsafe {

            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2026-01-06")]
            unsafe extern "C" {
              #[link_name = "[method]tcp-socket.get-address-family"]
              fn wit_import0(_: i32, ) -> i32;
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import0(_: i32, ) -> i32 { unreachable!() }
            let ret = wit_import0((self).handle() as i32);
            IpAddressFamily::_lift(ret as u8)
          }
        }
      }
      impl TcpSocket {
        #[allow(unused_unsafe, clippy::all)]
        /// Hints the desired listen queue size. Implementations are free to ignore this.
        ///
        /// If the provided value is 0, an `invalid-argument` error is returned.
        /// Any other value will never cause an error, but it might be silently clamped and/or rounded.
        ///
        /// # Typical errors
        /// - `not-supported`:        (set) The platform does not support changing the backlog size after the initial listen.
        /// - `invalid-argument`:     (set) The provided value was 0.
        /// - `invalid-state`:        (set) The socket is in the `connecting` or `connected` state.
        #[allow(async_fn_in_trait)]
        pub fn set_listen_backlog_size(&self,value: u64,) -> Result<(),ErrorCode>{
          unsafe {

            #[repr(align(1))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 2]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2026-01-06")]
            unsafe extern "C" {
              #[link_name = "[method]tcp-socket.set-listen-backlog-size"]
              fn wit_import1(_: i32, _: i64, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import1(_: i32, _: i64, _: *mut u8, ) { unreachable!() }
            wit_import1((self).handle() as i32, _rt::as_i64(&value), ptr0);
            let l2 = i32::from(*ptr0.add(0).cast::<u8>());
            let result4 = match l2 {
              0 => {
                let e = ();
                Ok(e)
              }
              1 => {
                let e = {
                  let l3 = i32::from(*ptr0.add(1).cast::<u8>());

                  ErrorCode::_lift(l3 as u8)
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            };
            result4
          }
        }
      }
      impl TcpSocket {
        #[allow(unused_unsafe, clippy::all)]
        /// Enables or disables keepalive.
        ///
        /// The keepalive behavior can be adjusted using:
        /// - `keep-alive-idle-time`
        /// - `keep-alive-interval`
        /// - `keep-alive-count`
        /// These properties can be configured while `keep-alive-enabled` is false, but only come into effect when `keep-alive-enabled` is true.
        ///
        /// Equivalent to the SO_KEEPALIVE socket option.
        #[allow(async_fn_in_trait)]
        pub fn get_keep_alive_enabled(&self,) -> Result<bool,ErrorCode>{
          unsafe {

            #[repr(align(1))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 2]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2026-01-06")]
            unsafe extern "C" {
              #[link_name = "[method]tcp-socket.get-keep-alive-enabled"]
              fn wit_import1(_: i32, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, ) { unreachable!() }
            wit_import1((self).handle() as i32, ptr0);
            let l2 = i32::from(*ptr0.add(0).cast::<u8>());
            let result5 = match l2 {
              0 => {
                let e = {
                  let l3 = i32::from(*ptr0.add(1).cast::<u8>());

                  _rt::bool_lift(l3 as u8)
                };
                Ok(e)
              }
              1 => {
                let e = {
                  let l4 = i32::from(*ptr0.add(1).cast::<u8>());

                  ErrorCode::_lift(l4 as u8)
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            };
            result5
          }
        }
      }
      impl TcpSocket {
        #[allow(unused_unsafe, clippy::all)]
        #[allow(async_fn_in_trait)]
        pub fn set_keep_alive_enabled(&self,value: bool,) -> Result<(),ErrorCode>{
          unsafe {

            #[repr(align(1))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 2]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2026-01-06")]
            unsafe extern "C" {
              #[link_name = "[method]tcp-socket.set-keep-alive-enabled"]
              fn wit_import1(_: i32, _: i32, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import1(_: i32, _: i32, _: *mut u8, ) { unreachable!() }
            wit_import1((self).handle() as i32, match &value { true => 1, false => 0 }, ptr0);
            let l2 = i32::from(*ptr0.add(0).cast::<u8>());
            let result4 = match l2 {
              0 => {
                let e = ();
                Ok(e)
              }
              1 => {
                let e = {
                  let l3 = i32::from(*ptr0.add(1).cast::<u8>());

                  ErrorCode::_lift(l3 as u8)
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            };
            result4
          }
        }
      }
      impl TcpSocket {
        #[allow(unused_unsafe, clippy::all)]
        /// Amount of time the connection has to be idle before TCP starts sending keepalive packets.
        ///
        /// If the provided value is 0, an `invalid-argument` error is returned.
        /// Any other value will never cause an error, but it might be silently clamped and/or rounded.
        /// I.e. after setting a value, reading the same setting back may return a different value.
        ///
        /// Equivalent to the TCP_KEEPIDLE socket option. (TCP_KEEPALIVE on MacOS)
        ///
        /// # Typical errors
        /// - `invalid-argument`:     (set) The provided value was 0.
        #[allow(async_fn_in_trait)]
        pub fn get_keep_alive_idle_time(&self,) -> Result<Duration,ErrorCode>{
          unsafe {

            #[repr(align(8))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 16]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 16]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2026-01-06")]
            unsafe extern "C" {
              #[link_name = "[method]tcp-socket.get-keep-alive-idle-time"]
              fn wit_import1(_: i32, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, ) { unreachable!() }
            wit_import1((self).handle() as i32, ptr0);
            let l2 = i32::from(*ptr0.add(0).cast::<u8>());
            let result5 = match l2 {
              0 => {
                let e = {
                  let l3 = *ptr0.add(8).cast::<i64>();

                  l3 as u64
                };
                Ok(e)
              }
              1 => {
                let e = {
                  let l4 = i32::from(*ptr0.add(8).cast::<u8>());

                  ErrorCode::_lift(l4 as u8)
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            };
            result5
          }
        }
      }
      impl TcpSocket {
        #[allow(unused_unsafe, clippy::all)]
        #[allow(async_fn_in_trait)]
        pub fn set_keep_alive_idle_time(&self,value: Duration,) -> Result<(),ErrorCode>{
          unsafe {

            #[repr(align(1))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 2]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2026-01-06")]
            unsafe extern "C" {
              #[link_name = "[method]tcp-socket.set-keep-alive-idle-time"]
              fn wit_import1(_: i32, _: i64, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import1(_: i32, _: i64, _: *mut u8, ) { unreachable!() }
            wit_import1((self).handle() as i32, _rt::as_i64(value), ptr0);
            let l2 = i32::from(*ptr0.add(0).cast::<u8>());
            let result4 = match l2 {
              0 => {
                let e = ();
                Ok(e)
              }
              1 => {
                let e = {
                  let l3 = i32::from(*ptr0.add(1).cast::<u8>());

                  ErrorCode::_lift(l3 as u8)
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            };
            result4
          }
        }
      }
      impl TcpSocket {
        #[allow(unused_unsafe, clippy::all)]
        /// The time between keepalive packets.
        ///
        /// If the provided value is 0, an `invalid-argument` error is returned.
        /// Any other value will never cause an error, but it might be silently clamped and/or rounded.
        /// I.e. after setting a value, reading the same setting back may return a different value.
        ///
        /// Equivalent to the TCP_KEEPINTVL socket option.
        ///
        /// # Typical errors
        /// - `invalid-argument`:     (set) The provided value was 0.
        #[allow(async_fn_in_trait)]
        pub fn get_keep_alive_interval(&self,) -> Result<Duration,ErrorCode>{
          unsafe {

            #[repr(align(8))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 16]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 16]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2026-01-06")]
            unsafe extern "C" {
              #[link_name = "[method]tcp-socket.get-keep-alive-interval"]
              fn wit_import1(_: i32, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, ) { unreachable!() }
            wit_import1((self).handle() as i32, ptr0);
            let l2 = i32::from(*ptr0.add(0).cast::<u8>());
            let result5 = match l2 {
              0 => {
                let e = {
                  let l3 = *ptr0.add(8).cast::<i64>();

                  l3 as u64
                };
                Ok(e)
              }
              1 => {
                let e = {
                  let l4 = i32::from(*ptr0.add(8).cast::<u8>());

                  ErrorCode::_lift(l4 as u8)
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            };
            result5
          }
        }
      }
      impl TcpSocket {
        #[allow(unused_unsafe, clippy::all)]
        #[allow(async_fn_in_trait)]
        pub fn set_keep_alive_interval(&self,value: Duration,) -> Result<(),ErrorCode>{
          unsafe {

            #[repr(align(1))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 2]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2026-01-06")]
            unsafe extern "C" {
              #[link_name = "[method]tcp-socket.set-keep-alive-interval"]
              fn wit_import1(_: i32, _: i64, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import1(_: i32, _: i64, _: *mut u8, ) { unreachable!() }
            wit_import1((self).handle() as i32, _rt::as_i64(value), ptr0);
            let l2 = i32::from(*ptr0.add(0).cast::<u8>());
            let result4 = match l2 {
              0 => {
                let e = ();
                Ok(e)
              }
              1 => {
                let e = {
                  let l3 = i32::from(*ptr0.add(1).cast::<u8>());

                  ErrorCode::_lift(l3 as u8)
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            };
            result4
          }
        }
      }
      impl TcpSocket {
        #[allow(unused_unsafe, clippy::all)]
        /// The maximum amount of keepalive packets TCP should send before aborting the connection.
        ///
        /// If the provided value is 0, an `invalid-argument` error is returned.
        /// Any other value will never cause an error, but it might be silently clamped and/or rounded.
        /// I.e. after setting a value, reading the same setting back may return a different value.
        ///
        /// Equivalent to the TCP_KEEPCNT socket option.
        ///
        /// # Typical errors
        /// - `invalid-argument`:     (set) The provided value was 0.
        #[allow(async_fn_in_trait)]
        pub fn get_keep_alive_count(&self,) -> Result<u32,ErrorCode>{
          unsafe {

            #[repr(align(4))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 8]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 8]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2026-01-06")]
            unsafe extern "C" {
              #[link_name = "[method]tcp-socket.get-keep-alive-count"]
              fn wit_import1(_: i32, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, ) { unreachable!() }
            wit_import1((self).handle() as i32, ptr0);
            let l2 = i32::from(*ptr0.add(0).cast::<u8>());
            let result5 = match l2 {
              0 => {
                let e = {
                  let l3 = *ptr0.add(4).cast::<i32>();

                  l3 as u32
                };
                Ok(e)
              }
              1 => {
                let e = {
                  let l4 = i32::from(*ptr0.add(4).cast::<u8>());

                  ErrorCode::_lift(l4 as u8)
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            };
            result5
          }
        }
      }
      impl TcpSocket {
        #[allow(unused_unsafe, clippy::all)]
        #[allow(async_fn_in_trait)]
        pub fn set_keep_alive_count(&self,value: u32,) -> Result<(),ErrorCode>{
          unsafe {

            #[repr(align(1))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 2]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2026-01-06")]
            unsafe extern "C" {
              #[link_name = "[method]tcp-socket.set-keep-alive-count"]
              fn wit_import1(_: i32, _: i32, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import1(_: i32, _: i32, _: *mut u8, ) { unreachable!() }
            wit_import1((self).handle() as i32, _rt::as_i32(&value), ptr0);
            let l2 = i32::from(*ptr0.add(0).cast::<u8>());
            let result4 = match l2 {
              0 => {
                let e = ();
                Ok(e)
              }
              1 => {
                let e = {
                  let l3 = i32::from(*ptr0.add(1).cast::<u8>());

                  ErrorCode::_lift(l3 as u8)
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            };
            result4
          }
        }
      }
      impl TcpSocket {
        #[allow(unused_unsafe, clippy::all)]
        /// Equivalent to the IP_TTL & IPV6_UNICAST_HOPS socket options.
        ///
        /// If the provided value is 0, an `invalid-argument` error is returned.
        ///
        /// # Typical errors
        /// - `invalid-argument`:     (set) The TTL value must be 1 or higher.
        #[allow(async_fn_in_trait)]
        pub fn get_hop_limit(&self,) -> Result<u8,ErrorCode>{
          unsafe {

            #[repr(align(1))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 2]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2026-01-06")]
            unsafe extern "C" {
              #[link_name = "[method]tcp-socket.get-hop-limit"]
              fn wit_import1(_: i32, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, ) { unreachable!() }
            wit_import1((self).handle() as i32, ptr0);
            let l2 = i32::from(*ptr0.add(0).cast::<u8>());
            let result5 = match l2 {
              0 => {
                let e = {
                  let l3 = i32::from(*ptr0.add(1).cast::<u8>());

                  l3 as u8
                };
                Ok(e)
              }
              1 => {
                let e = {
                  let l4 = i32::from(*ptr0.add(1).cast::<u8>());

                  ErrorCode::_lift(l4 as u8)
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            };
            result5
          }
        }
      }
      impl TcpSocket {
        #[allow(unused_unsafe, clippy::all)]
        #[allow(async_fn_in_trait)]
        pub fn set_hop_limit(&self,value: u8,) -> Result<(),ErrorCode>{
          unsafe {

            #[repr(align(1))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 2]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2026-01-06")]
            unsafe extern "C" {
              #[link_name = "[method]tcp-socket.set-hop-limit"]
              fn wit_import1(_: i32, _: i32, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import1(_: i32, _: i32, _: *mut u8, ) { unreachable!() }
            wit_import1((self).handle() as i32, _rt::as_i32(&value), ptr0);
            let l2 = i32::from(*ptr0.add(0).cast::<u8>());
            let result4 = match l2 {
              0 => {
                let e = ();
                Ok(e)
              }
              1 => {
                let e = {
                  let l3 = i32::from(*ptr0.add(1).cast::<u8>());

                  ErrorCode::_lift(l3 as u8)
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            };
            result4
          }
        }
      }
      impl TcpSocket {
        #[allow(unused_unsafe, clippy::all)]
        /// The kernel buffer space reserved for sends/receives on this socket.
        ///
        /// If the provided value is 0, an `invalid-argument` error is returned.
        /// Any other value will never cause an error, but it might be silently clamped and/or rounded.
        /// I.e. after setting a value, reading the same setting back may return a different value.
        ///
        /// Equivalent to the SO_RCVBUF and SO_SNDBUF socket options.
        ///
        /// # Typical errors
        /// - `invalid-argument`:     (set) The provided value was 0.
        #[allow(async_fn_in_trait)]
        pub fn get_receive_buffer_size(&self,) -> Result<u64,ErrorCode>{
          unsafe {

            #[repr(align(8))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 16]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 16]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2026-01-06")]
            unsafe extern "C" {
              #[link_name = "[method]tcp-socket.get-receive-buffer-size"]
              fn wit_import1(_: i32, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, ) { unreachable!() }
            wit_import1((self).handle() as i32, ptr0);
            let l2 = i32::from(*ptr0.add(0).cast::<u8>());
            let result5 = match l2 {
              0 => {
                let e = {
                  let l3 = *ptr0.add(8).cast::<i64>();

                  l3 as u64
                };
                Ok(e)
              }
              1 => {
                let e = {
                  let l4 = i32::from(*ptr0.add(8).cast::<u8>());

                  ErrorCode::_lift(l4 as u8)
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            };
            result5
          }
        }
      }
      impl TcpSocket {
        #[allow(unused_unsafe, clippy::all)]
        #[allow(async_fn_in_trait)]
        pub fn set_receive_buffer_size(&self,value: u64,) -> Result<(),ErrorCode>{
          unsafe {

            #[repr(align(1))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 2]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2026-01-06")]
            unsafe extern "C" {
              #[link_name = "[method]tcp-socket.set-receive-buffer-size"]
              fn wit_import1(_: i32, _: i64, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import1(_: i32, _: i64, _: *mut u8, ) { unreachable!() }
            wit_import1((self).handle() as i32, _rt::as_i64(&value), ptr0);
            let l2 = i32::from(*ptr0.add(0).cast::<u8>());
            let result4 = match l2 {
              0 => {
                let e = ();
                Ok(e)
              }
              1 => {
                let e = {
                  let l3 = i32::from(*ptr0.add(1).cast::<u8>());

                  ErrorCode::_lift(l3 as u8)
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            };
            result4
          }
        }
      }
      impl TcpSocket {
        #[allow(unused_unsafe, clippy::all)]
        #[allow(async_fn_in_trait)]
        pub fn get_send_buffer_size(&self,) -> Result<u64,ErrorCode>{
          unsafe {

            #[repr(align(8))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 16]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 16]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2026-01-06")]
            unsafe extern "C" {
              #[link_name = "[method]tcp-socket.get-send-buffer-size"]
              fn wit_import1(_: i32, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, ) { unreachable!() }
            wit_import1((self).handle() as i32, ptr0);
            let l2 = i32::from(*ptr0.add(0).cast::<u8>());
            let result5 = match l2 {
              0 => {
                let e = {
                  let l3 = *ptr0.add(8).cast::<i64>();

                  l3 as u64
                };
                Ok(e)
              }
              1 => {
                let e = {
                  let l4 = i32::from(*ptr0.add(8).cast::<u8>());

                  ErrorCode::_lift(l4 as u8)
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            };
            result5
          }
        }
      }
      impl TcpSocket {
        #[allow(unused_unsafe, clippy::all)]
        #[allow(async_fn_in_trait)]
        pub fn set_send_buffer_size(&self,value: u64,) -> Result<(),ErrorCode>{
          unsafe {

            #[repr(align(1))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 2]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2026-01-06")]
            unsafe extern "C" {
              #[link_name = "[method]tcp-socket.set-send-buffer-size"]
              fn wit_import1(_: i32, _: i64, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import1(_: i32, _: i64, _: *mut u8, ) { unreachable!() }
            wit_import1((self).handle() as i32, _rt::as_i64(&value), ptr0);
            let l2 = i32::from(*ptr0.add(0).cast::<u8>());
            let result4 = match l2 {
              0 => {
                let e = ();
                Ok(e)
              }
              1 => {
                let e = {
                  let l3 = i32::from(*ptr0.add(1).cast::<u8>());

                  ErrorCode::_lift(l3 as u8)
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            };
            result4
          }
        }
      }
      impl UdpSocket {
        #[allow(unused_unsafe, clippy::all)]
        /// Create a new UDP socket.
        ///
        /// Similar to `socket(AF_INET or AF_INET6, SOCK_DGRAM, IPPROTO_UDP)` in POSIX.
        /// On IPv6 sockets, IPV6_V6ONLY is enabled by default and can't be configured otherwise.
        ///
        /// Unlike POSIX, WASI sockets have no notion of a socket-level
        /// `O_NONBLOCK` flag. Instead they fully rely on the Component Model's
        /// async support.
        ///
        /// # References:
        /// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/socket.html>
        /// - <https://man7.org/linux/man-pages/man2/socket.2.html>
        /// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-wsasocketw>
        /// - <https://man.freebsd.org/cgi/man.cgi?query=socket&sektion=2>
        #[allow(async_fn_in_trait)]
        pub fn create(address_family: IpAddressFamily,) -> Result<UdpSocket,ErrorCode>{
          unsafe {

            #[repr(align(4))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 8]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 8]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2026-01-06")]
            unsafe extern "C" {
              #[link_name = "[static]udp-socket.create"]
              fn wit_import1(_: i32, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, ) { unreachable!() }
            wit_import1(address_family.clone() as i32, ptr0);
            let l2 = i32::from(*ptr0.add(0).cast::<u8>());
            let result5 = match l2 {
              0 => {
                let e = {
                  let l3 = *ptr0.add(4).cast::<i32>();

                  UdpSocket::from_handle(l3 as u32)
                };
                Ok(e)
              }
              1 => {
                let e = {
                  let l4 = i32::from(*ptr0.add(4).cast::<u8>());

                  ErrorCode::_lift(l4 as u8)
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            };
            result5
          }
        }
      }
      impl UdpSocket {
        #[allow(unused_unsafe, clippy::all)]
        /// Bind the socket to the provided IP address and port.
        ///
        /// If the IP address is zero (`0.0.0.0` in IPv4, `::` in IPv6), it is left to the implementation to decide which
        /// network interface(s) to bind to.
        /// If the port is zero, the socket will be bound to a random free port.
        ///
        /// # Typical errors
        /// - `invalid-argument`:          The `local-address` has the wrong address family. (EAFNOSUPPORT, EFAULT on Windows)
        /// - `invalid-state`:             The socket is already bound. (EINVAL)
        /// - `address-in-use`:            No ephemeral ports available. (EADDRINUSE, ENOBUFS on Windows)
        /// - `address-in-use`:            Address is already in use. (EADDRINUSE)
        /// - `address-not-bindable`:      `local-address` is not an address that can be bound to. (EADDRNOTAVAIL)
        ///
        /// # References
        /// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/bind.html>
        /// - <https://man7.org/linux/man-pages/man2/bind.2.html>
        /// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-bind>
        /// - <https://man.freebsd.org/cgi/man.cgi?query=bind&sektion=2&format=html>
        #[allow(async_fn_in_trait)]
        pub fn bind(&self,local_address: IpSocketAddress,) -> Result<(),ErrorCode>{
          unsafe {

            #[repr(align(1))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 2]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2]);
            let (result4_0,result4_1,result4_2,result4_3,result4_4,result4_5,result4_6,result4_7,result4_8,result4_9,result4_10,result4_11,) = match local_address {
              IpSocketAddress::Ipv4(e) => {
                let Ipv4SocketAddress{ port:port0, address:address0, } = e;
                let (t1_0, t1_1, t1_2, t1_3, ) = address0;

                (0i32, _rt::as_i32(port0), _rt::as_i32(t1_0), _rt::as_i32(t1_1), _rt::as_i32(t1_2), _rt::as_i32(t1_3), 0i32, 0i32, 0i32, 0i32, 0i32, 0i32)
              },
              IpSocketAddress::Ipv6(e) => {
                let Ipv6SocketAddress{ port:port2, flow_info:flow_info2, address:address2, scope_id:scope_id2, } = e;
                let (t3_0, t3_1, t3_2, t3_3, t3_4, t3_5, t3_6, t3_7, ) = address2;

                (1i32, _rt::as_i32(port2), _rt::as_i32(flow_info2), _rt::as_i32(t3_0), _rt::as_i32(t3_1), _rt::as_i32(t3_2), _rt::as_i32(t3_3), _rt::as_i32(t3_4), _rt::as_i32(t3_5), _rt::as_i32(t3_6), _rt::as_i32(t3_7), _rt::as_i32(scope_id2))
              },
            };
            let ptr5 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2026-01-06")]
            unsafe extern "C" {
              #[link_name = "[method]udp-socket.bind"]
              fn wit_import6(_: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import6(_: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: *mut u8, ) { unreachable!() }
            wit_import6((self).handle() as i32, result4_0, result4_1, result4_2, result4_3, result4_4, result4_5, result4_6, result4_7, result4_8, result4_9, result4_10, result4_11, ptr5);
            let l7 = i32::from(*ptr5.add(0).cast::<u8>());
            let result9 = match l7 {
              0 => {
                let e = ();
                Ok(e)
              }
              1 => {
                let e = {
                  let l8 = i32::from(*ptr5.add(1).cast::<u8>());

                  ErrorCode::_lift(l8 as u8)
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            };
            result9
          }
        }
      }
      impl UdpSocket {
        #[allow(unused_unsafe, clippy::all)]
        /// Associate this socket with a specific peer address.
        ///
        /// On success, the `remote-address` of the socket is updated.
        /// The `local-address` may be updated as well, based on the best network
        /// path to `remote-address`. If the socket was not already explicitly
        /// bound, this function will implicitly bind the socket to a random
        /// free port.
        ///
        /// When a UDP socket is "connected", the `send` and `receive` methods
        /// are limited to communicating with that peer only:
        /// - `send` can only be used to send to this destination.
        /// - `receive` will only return datagrams sent from the provided `remote-address`.
        ///
        /// The name "connect" was kept to align with the existing POSIX
        /// terminology. Other than that, this function only changes the local
        /// socket configuration and does not generate any network traffic.
        /// The peer is not aware of this "connection".
        ///
        /// This method may be called multiple times on the same socket to change
        /// its association, but only the most recent one will be effective.
        ///
        /// # Typical errors
        /// - `invalid-argument`:          The `remote-address` has the wrong address family. (EAFNOSUPPORT)
        /// - `invalid-argument`:          The IP address in `remote-address` is set to INADDR_ANY (`0.0.0.0` / `::`). (EDESTADDRREQ, EADDRNOTAVAIL)
        /// - `invalid-argument`:          The port in `remote-address` is set to 0. (EDESTADDRREQ, EADDRNOTAVAIL)
        /// - `address-in-use`:            Tried to perform an implicit bind, but there were no ephemeral ports available. (EADDRINUSE, EADDRNOTAVAIL on Linux, EAGAIN on BSD)
        ///
        /// # Implementors note
        /// If the socket is already connected, some platforms (e.g. Linux)
        /// require a disconnect before connecting to a different peer address.
        ///
        /// # References
        /// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/connect.html>
        /// - <https://man7.org/linux/man-pages/man2/connect.2.html>
        /// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-connect>
        /// - <https://man.freebsd.org/cgi/man.cgi?connect>
        #[allow(async_fn_in_trait)]
        pub fn connect(&self,remote_address: IpSocketAddress,) -> Result<(),ErrorCode>{
          unsafe {

            #[repr(align(1))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 2]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2]);
            let (result4_0,result4_1,result4_2,result4_3,result4_4,result4_5,result4_6,result4_7,result4_8,result4_9,result4_10,result4_11,) = match remote_address {
              IpSocketAddress::Ipv4(e) => {
                let Ipv4SocketAddress{ port:port0, address:address0, } = e;
                let (t1_0, t1_1, t1_2, t1_3, ) = address0;

                (0i32, _rt::as_i32(port0), _rt::as_i32(t1_0), _rt::as_i32(t1_1), _rt::as_i32(t1_2), _rt::as_i32(t1_3), 0i32, 0i32, 0i32, 0i32, 0i32, 0i32)
              },
              IpSocketAddress::Ipv6(e) => {
                let Ipv6SocketAddress{ port:port2, flow_info:flow_info2, address:address2, scope_id:scope_id2, } = e;
                let (t3_0, t3_1, t3_2, t3_3, t3_4, t3_5, t3_6, t3_7, ) = address2;

                (1i32, _rt::as_i32(port2), _rt::as_i32(flow_info2), _rt::as_i32(t3_0), _rt::as_i32(t3_1), _rt::as_i32(t3_2), _rt::as_i32(t3_3), _rt::as_i32(t3_4), _rt::as_i32(t3_5), _rt::as_i32(t3_6), _rt::as_i32(t3_7), _rt::as_i32(scope_id2))
              },
            };
            let ptr5 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2026-01-06")]
            unsafe extern "C" {
              #[link_name = "[method]udp-socket.connect"]
              fn wit_import6(_: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import6(_: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: *mut u8, ) { unreachable!() }
            wit_import6((self).handle() as i32, result4_0, result4_1, result4_2, result4_3, result4_4, result4_5, result4_6, result4_7, result4_8, result4_9, result4_10, result4_11, ptr5);
            let l7 = i32::from(*ptr5.add(0).cast::<u8>());
            let result9 = match l7 {
              0 => {
                let e = ();
                Ok(e)
              }
              1 => {
                let e = {
                  let l8 = i32::from(*ptr5.add(1).cast::<u8>());

                  ErrorCode::_lift(l8 as u8)
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            };
            result9
          }
        }
      }
      impl UdpSocket {
        #[allow(unused_unsafe, clippy::all)]
        /// Dissociate this socket from its peer address.
        ///
        /// After calling this method, `send` & `receive` are free to communicate
        /// with any address again.
        ///
        /// The POSIX equivalent of this is calling `connect` with an `AF_UNSPEC` address.
        ///
        /// # Typical errors
        /// - `invalid-state`:           The socket is not connected.
        ///
        /// # References
        /// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/connect.html>
        /// - <https://man7.org/linux/man-pages/man2/connect.2.html>
        /// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-connect>
        /// - <https://man.freebsd.org/cgi/man.cgi?connect>
        #[allow(async_fn_in_trait)]
        pub fn disconnect(&self,) -> Result<(),ErrorCode>{
          unsafe {

            #[repr(align(1))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 2]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2026-01-06")]
            unsafe extern "C" {
              #[link_name = "[method]udp-socket.disconnect"]
              fn wit_import1(_: i32, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, ) { unreachable!() }
            wit_import1((self).handle() as i32, ptr0);
            let l2 = i32::from(*ptr0.add(0).cast::<u8>());
            let result4 = match l2 {
              0 => {
                let e = ();
                Ok(e)
              }
              1 => {
                let e = {
                  let l3 = i32::from(*ptr0.add(1).cast::<u8>());

                  ErrorCode::_lift(l3 as u8)
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            };
            result4
          }
        }
      }
      impl UdpSocket {
        #[allow(unused_unsafe, clippy::all)]
        /// Send a message on the socket to a particular peer.
        ///
        /// If the socket is connected, the peer address may be left empty. In
        /// that case this is equivalent to `send` in POSIX. Otherwise it is
        /// equivalent to `sendto`.
        ///
        /// Additionally, if the socket is connected, a `remote-address` argument
        /// _may_ be provided but then it must be identical to the address
        /// passed to `connect`.
        ///
        /// Implementations may trap if the `data` length exceeds 64 KiB.
        ///
        /// # Typical errors
        /// - `invalid-argument`:        The `remote-address` has the wrong address family. (EAFNOSUPPORT)
        /// - `invalid-argument`:        The IP address in `remote-address` is set to INADDR_ANY (`0.0.0.0` / `::`). (EDESTADDRREQ, EADDRNOTAVAIL)
        /// - `invalid-argument`:        The port in `remote-address` is set to 0. (EDESTADDRREQ, EADDRNOTAVAIL)
        /// - `invalid-argument`:        The socket is in "connected" mode and `remote-address` is `some` value that does not match the address passed to `connect`. (EISCONN)
        /// - `invalid-argument`:        The socket is not "connected" and no value for `remote-address` was provided. (EDESTADDRREQ)
        /// - `remote-unreachable`:      The remote address is not reachable. (ECONNRESET, ENETRESET on Windows, EHOSTUNREACH, EHOSTDOWN, ENETUNREACH, ENETDOWN, ENONET)
        /// - `connection-refused`:      The connection was refused. (ECONNREFUSED)
        /// - `datagram-too-large`:      The datagram is too large. (EMSGSIZE)
        ///
        /// # References
        /// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/sendto.html>
        /// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/sendmsg.html>
        /// - <https://man7.org/linux/man-pages/man2/send.2.html>
        /// - <https://man7.org/linux/man-pages/man2/sendmmsg.2.html>
        /// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-send>
        /// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-sendto>
        /// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-wsasendmsg>
        /// - <https://man.freebsd.org/cgi/man.cgi?query=send&sektion=2>
        #[allow(async_fn_in_trait)]
        pub fn send(&self,data: &[u8],remote_address: Option<IpSocketAddress>,) -> Result<(),ErrorCode>{
          unsafe {

            #[repr(align(1))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 2]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2]);
            let vec0 = data;
            let ptr0 = vec0.as_ptr().cast::<u8>();
            let len0 = vec0.len();
            let (result6_0,result6_1,result6_2,result6_3,result6_4,result6_5,result6_6,result6_7,result6_8,result6_9,result6_10,result6_11,result6_12,) = match remote_address {
              Some(e) => {
                let (result5_0,result5_1,result5_2,result5_3,result5_4,result5_5,result5_6,result5_7,result5_8,result5_9,result5_10,result5_11,) = match e {
                  IpSocketAddress::Ipv4(e) => {
                    let Ipv4SocketAddress{ port:port1, address:address1, } = e;
                    let (t2_0, t2_1, t2_2, t2_3, ) = address1;

                    (0i32, _rt::as_i32(port1), _rt::as_i32(t2_0), _rt::as_i32(t2_1), _rt::as_i32(t2_2), _rt::as_i32(t2_3), 0i32, 0i32, 0i32, 0i32, 0i32, 0i32)
                  },
                  IpSocketAddress::Ipv6(e) => {
                    let Ipv6SocketAddress{ port:port3, flow_info:flow_info3, address:address3, scope_id:scope_id3, } = e;
                    let (t4_0, t4_1, t4_2, t4_3, t4_4, t4_5, t4_6, t4_7, ) = address3;

                    (1i32, _rt::as_i32(port3), _rt::as_i32(flow_info3), _rt::as_i32(t4_0), _rt::as_i32(t4_1), _rt::as_i32(t4_2), _rt::as_i32(t4_3), _rt::as_i32(t4_4), _rt::as_i32(t4_5), _rt::as_i32(t4_6), _rt::as_i32(t4_7), _rt::as_i32(scope_id3))
                  },
                };

                (1i32, result5_0, result5_1, result5_2, result5_3, result5_4, result5_5, result5_6, result5_7, result5_8, result5_9, result5_10, result5_11)
              },
              None => {
                (0i32, 0i32, 0i32, 0i32, 0i32, 0i32, 0i32, 0i32, 0i32, 0i32, 0i32, 0i32, 0i32)
              },
            };let ptr7 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2026-01-06")]
            unsafe extern "C" {
              #[link_name = "[method]udp-socket.send"]
              fn wit_import8(_: i32, _: *mut u8, _: usize, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import8(_: i32, _: *mut u8, _: usize, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: *mut u8, ) { unreachable!() }
            wit_import8((self).handle() as i32, ptr0.cast_mut(), len0, result6_0, result6_1, result6_2, result6_3, result6_4, result6_5, result6_6, result6_7, result6_8, result6_9, result6_10, result6_11, result6_12, ptr7);
            let l9 = i32::from(*ptr7.add(0).cast::<u8>());
            let result11 = match l9 {
              0 => {
                let e = ();
                Ok(e)
              }
              1 => {
                let e = {
                  let l10 = i32::from(*ptr7.add(1).cast::<u8>());

                  ErrorCode::_lift(l10 as u8)
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            };
            result11
          }
        }
      }
      impl UdpSocket {
        #[allow(unused_unsafe, clippy::all)]
        /// Receive a message on the socket.
        ///
        /// On success, the return value contains a tuple of the received data
        /// and the address of the sender. Theoretical maximum length of the
        /// data is 64 KiB. Though in practice, it will typically be less than
        /// 1500 bytes.
        ///
        /// If the socket is connected, the sender address is guaranteed to
        /// match the remote address passed to `connect`.
        ///
        /// # Typical errors
        /// - `invalid-state`:        The socket has not been bound yet.
        /// - `remote-unreachable`:   The remote address is not reachable. (ECONNRESET, ENETRESET on Windows, EHOSTUNREACH, EHOSTDOWN, ENETUNREACH, ENETDOWN, ENONET)
        /// - `connection-refused`:   The connection was refused. (ECONNREFUSED)
        ///
        /// # References
        /// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/recvfrom.html>
        /// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/recvmsg.html>
        /// - <https://man7.org/linux/man-pages/man2/recv.2.html>
        /// - <https://man7.org/linux/man-pages/man2/recvmmsg.2.html>
        /// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-recvfrom>
        /// - <https://learn.microsoft.com/en-us/windows/win32/api/mswsock/nc-mswsock-lpfn_wsarecvmsg>
        /// - <https://man.freebsd.org/cgi/man.cgi?query=recv&sektion=2>
        #[allow(async_fn_in_trait)]
        pub fn receive(&self,) -> Result<(_rt::Vec::<u8>,IpSocketAddress,),ErrorCode>{
          unsafe {

            #[cfg_attr(target_pointer_width="64", repr(align(8)))]
            #[cfg_attr(target_pointer_width="32", repr(align(4)))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 32+3*::core::mem::size_of::<*const u8>()]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 32+3*::core::mem::size_of::<*const u8>()]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2026-01-06")]
            unsafe extern "C" {
              #[link_name = "[method]udp-socket.receive"]
              fn wit_import1(_: i32, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, ) { unreachable!() }
            wit_import1((self).handle() as i32, ptr0);
            let l2 = i32::from(*ptr0.add(0).cast::<u8>());
            let result25 = match l2 {
              0 => {
                let e = {
                  let l3 = *ptr0.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                  let l4 = *ptr0.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>();
                  let len5 = l4;
                  let l6 = i32::from(*ptr0.add(3*::core::mem::size_of::<*const u8>()).cast::<u8>());
                  let v23 = match l6 {
                    0 => {
                      let e23 = {
                        let l7 = i32::from(*ptr0.add(4+3*::core::mem::size_of::<*const u8>()).cast::<u16>());
                        let l8 = i32::from(*ptr0.add(6+3*::core::mem::size_of::<*const u8>()).cast::<u8>());
                        let l9 = i32::from(*ptr0.add(7+3*::core::mem::size_of::<*const u8>()).cast::<u8>());
                        let l10 = i32::from(*ptr0.add(8+3*::core::mem::size_of::<*const u8>()).cast::<u8>());
                        let l11 = i32::from(*ptr0.add(9+3*::core::mem::size_of::<*const u8>()).cast::<u8>());

                        Ipv4SocketAddress{
                          port: l7 as u16,
                          address: (l8 as u8, l9 as u8, l10 as u8, l11 as u8),
                        }
                      };
                      IpSocketAddress::Ipv4(e23)
                    }
                    n => {
                      debug_assert_eq!(n, 1, "invalid enum discriminant");
                      let e23 = {
                        let l12 = i32::from(*ptr0.add(4+3*::core::mem::size_of::<*const u8>()).cast::<u16>());
                        let l13 = *ptr0.add(8+3*::core::mem::size_of::<*const u8>()).cast::<i32>();
                        let l14 = i32::from(*ptr0.add(12+3*::core::mem::size_of::<*const u8>()).cast::<u16>());
                        let l15 = i32::from(*ptr0.add(14+3*::core::mem::size_of::<*const u8>()).cast::<u16>());
                        let l16 = i32::from(*ptr0.add(16+3*::core::mem::size_of::<*const u8>()).cast::<u16>());
                        let l17 = i32::from(*ptr0.add(18+3*::core::mem::size_of::<*const u8>()).cast::<u16>());
                        let l18 = i32::from(*ptr0.add(20+3*::core::mem::size_of::<*const u8>()).cast::<u16>());
                        let l19 = i32::from(*ptr0.add(22+3*::core::mem::size_of::<*const u8>()).cast::<u16>());
                        let l20 = i32::from(*ptr0.add(24+3*::core::mem::size_of::<*const u8>()).cast::<u16>());
                        let l21 = i32::from(*ptr0.add(26+3*::core::mem::size_of::<*const u8>()).cast::<u16>());
                        let l22 = *ptr0.add(28+3*::core::mem::size_of::<*const u8>()).cast::<i32>();

                        Ipv6SocketAddress{
                          port: l12 as u16,
                          flow_info: l13 as u32,
                          address: (l14 as u16, l15 as u16, l16 as u16, l17 as u16, l18 as u16, l19 as u16, l20 as u16, l21 as u16),
                          scope_id: l22 as u32,
                        }
                      };
                      IpSocketAddress::Ipv6(e23)
                    }
                  };

                  (<_ as From<_rt::Vec<_>>>::from(_rt::Vec::from_raw_parts(l3.cast(), len5, len5)), v23)
                };
                Ok(e)
              }
              1 => {
                let e = {
                  let l24 = i32::from(*ptr0.add(::core::mem::size_of::<*const u8>()).cast::<u8>());

                  ErrorCode::_lift(l24 as u8)
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            };
            result25
          }
        }
      }
      impl UdpSocket {
        #[allow(unused_unsafe, clippy::all)]
        /// Get the current bound address.
        ///
        /// POSIX mentions:
        /// > If the socket has not been bound to a local name, the value
        /// > stored in the object pointed to by `address` is unspecified.
        ///
        /// WASI is stricter and requires `get-local-address` to return `invalid-state` when the socket hasn't been bound yet.
        ///
        /// # Typical errors
        /// - `invalid-state`: The socket is not bound to any local address.
        ///
        /// # References
        /// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/getsockname.html>
        /// - <https://man7.org/linux/man-pages/man2/getsockname.2.html>
        /// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-getsockname>
        /// - <https://man.freebsd.org/cgi/man.cgi?getsockname>
        #[allow(async_fn_in_trait)]
        pub fn get_local_address(&self,) -> Result<IpSocketAddress,ErrorCode>{
          unsafe {

            #[repr(align(4))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 36]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 36]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2026-01-06")]
            unsafe extern "C" {
              #[link_name = "[method]udp-socket.get-local-address"]
              fn wit_import1(_: i32, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, ) { unreachable!() }
            wit_import1((self).handle() as i32, ptr0);
            let l2 = i32::from(*ptr0.add(0).cast::<u8>());
            let result22 = match l2 {
              0 => {
                let e = {
                  let l3 = i32::from(*ptr0.add(4).cast::<u8>());
                  let v20 = match l3 {
                    0 => {
                      let e20 = {
                        let l4 = i32::from(*ptr0.add(8).cast::<u16>());
                        let l5 = i32::from(*ptr0.add(10).cast::<u8>());
                        let l6 = i32::from(*ptr0.add(11).cast::<u8>());
                        let l7 = i32::from(*ptr0.add(12).cast::<u8>());
                        let l8 = i32::from(*ptr0.add(13).cast::<u8>());

                        Ipv4SocketAddress{
                          port: l4 as u16,
                          address: (l5 as u8, l6 as u8, l7 as u8, l8 as u8),
                        }
                      };
                      IpSocketAddress::Ipv4(e20)
                    }
                    n => {
                      debug_assert_eq!(n, 1, "invalid enum discriminant");
                      let e20 = {
                        let l9 = i32::from(*ptr0.add(8).cast::<u16>());
                        let l10 = *ptr0.add(12).cast::<i32>();
                        let l11 = i32::from(*ptr0.add(16).cast::<u16>());
                        let l12 = i32::from(*ptr0.add(18).cast::<u16>());
                        let l13 = i32::from(*ptr0.add(20).cast::<u16>());
                        let l14 = i32::from(*ptr0.add(22).cast::<u16>());
                        let l15 = i32::from(*ptr0.add(24).cast::<u16>());
                        let l16 = i32::from(*ptr0.add(26).cast::<u16>());
                        let l17 = i32::from(*ptr0.add(28).cast::<u16>());
                        let l18 = i32::from(*ptr0.add(30).cast::<u16>());
                        let l19 = *ptr0.add(32).cast::<i32>();

                        Ipv6SocketAddress{
                          port: l9 as u16,
                          flow_info: l10 as u32,
                          address: (l11 as u16, l12 as u16, l13 as u16, l14 as u16, l15 as u16, l16 as u16, l17 as u16, l18 as u16),
                          scope_id: l19 as u32,
                        }
                      };
                      IpSocketAddress::Ipv6(e20)
                    }
                  };

                  v20
                };
                Ok(e)
              }
              1 => {
                let e = {
                  let l21 = i32::from(*ptr0.add(4).cast::<u8>());

                  ErrorCode::_lift(l21 as u8)
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            };
            result22
          }
        }
      }
      impl UdpSocket {
        #[allow(unused_unsafe, clippy::all)]
        /// Get the address the socket is currently "connected" to.
        ///
        /// # Typical errors
        /// - `invalid-state`: The socket is not "connected" to a specific remote address. (ENOTCONN)
        ///
        /// # References
        /// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/getpeername.html>
        /// - <https://man7.org/linux/man-pages/man2/getpeername.2.html>
        /// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-getpeername>
        /// - <https://man.freebsd.org/cgi/man.cgi?query=getpeername&sektion=2&n=1>
        #[allow(async_fn_in_trait)]
        pub fn get_remote_address(&self,) -> Result<IpSocketAddress,ErrorCode>{
          unsafe {

            #[repr(align(4))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 36]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 36]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2026-01-06")]
            unsafe extern "C" {
              #[link_name = "[method]udp-socket.get-remote-address"]
              fn wit_import1(_: i32, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, ) { unreachable!() }
            wit_import1((self).handle() as i32, ptr0);
            let l2 = i32::from(*ptr0.add(0).cast::<u8>());
            let result22 = match l2 {
              0 => {
                let e = {
                  let l3 = i32::from(*ptr0.add(4).cast::<u8>());
                  let v20 = match l3 {
                    0 => {
                      let e20 = {
                        let l4 = i32::from(*ptr0.add(8).cast::<u16>());
                        let l5 = i32::from(*ptr0.add(10).cast::<u8>());
                        let l6 = i32::from(*ptr0.add(11).cast::<u8>());
                        let l7 = i32::from(*ptr0.add(12).cast::<u8>());
                        let l8 = i32::from(*ptr0.add(13).cast::<u8>());

                        Ipv4SocketAddress{
                          port: l4 as u16,
                          address: (l5 as u8, l6 as u8, l7 as u8, l8 as u8),
                        }
                      };
                      IpSocketAddress::Ipv4(e20)
                    }
                    n => {
                      debug_assert_eq!(n, 1, "invalid enum discriminant");
                      let e20 = {
                        let l9 = i32::from(*ptr0.add(8).cast::<u16>());
                        let l10 = *ptr0.add(12).cast::<i32>();
                        let l11 = i32::from(*ptr0.add(16).cast::<u16>());
                        let l12 = i32::from(*ptr0.add(18).cast::<u16>());
                        let l13 = i32::from(*ptr0.add(20).cast::<u16>());
                        let l14 = i32::from(*ptr0.add(22).cast::<u16>());
                        let l15 = i32::from(*ptr0.add(24).cast::<u16>());
                        let l16 = i32::from(*ptr0.add(26).cast::<u16>());
                        let l17 = i32::from(*ptr0.add(28).cast::<u16>());
                        let l18 = i32::from(*ptr0.add(30).cast::<u16>());
                        let l19 = *ptr0.add(32).cast::<i32>();

                        Ipv6SocketAddress{
                          port: l9 as u16,
                          flow_info: l10 as u32,
                          address: (l11 as u16, l12 as u16, l13 as u16, l14 as u16, l15 as u16, l16 as u16, l17 as u16, l18 as u16),
                          scope_id: l19 as u32,
                        }
                      };
                      IpSocketAddress::Ipv6(e20)
                    }
                  };

                  v20
                };
                Ok(e)
              }
              1 => {
                let e = {
                  let l21 = i32::from(*ptr0.add(4).cast::<u8>());

                  ErrorCode::_lift(l21 as u8)
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            };
            result22
          }
        }
      }
      impl UdpSocket {
        #[allow(unused_unsafe, clippy::all)]
        /// Whether this is a IPv4 or IPv6 socket.
        ///
        /// This is the value passed to the constructor.
        ///
        /// Equivalent to the SO_DOMAIN socket option.
        #[allow(async_fn_in_trait)]
        pub fn get_address_family(&self,) -> IpAddressFamily{
          unsafe {

            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2026-01-06")]
            unsafe extern "C" {
              #[link_name = "[method]udp-socket.get-address-family"]
              fn wit_import0(_: i32, ) -> i32;
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import0(_: i32, ) -> i32 { unreachable!() }
            let ret = wit_import0((self).handle() as i32);
            IpAddressFamily::_lift(ret as u8)
          }
        }
      }
      impl UdpSocket {
        #[allow(unused_unsafe, clippy::all)]
        /// Equivalent to the IP_TTL & IPV6_UNICAST_HOPS socket options.
        ///
        /// If the provided value is 0, an `invalid-argument` error is returned.
        ///
        /// # Typical errors
        /// - `invalid-argument`:     (set) The TTL value must be 1 or higher.
        #[allow(async_fn_in_trait)]
        pub fn get_unicast_hop_limit(&self,) -> Result<u8,ErrorCode>{
          unsafe {

            #[repr(align(1))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 2]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2026-01-06")]
            unsafe extern "C" {
              #[link_name = "[method]udp-socket.get-unicast-hop-limit"]
              fn wit_import1(_: i32, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, ) { unreachable!() }
            wit_import1((self).handle() as i32, ptr0);
            let l2 = i32::from(*ptr0.add(0).cast::<u8>());
            let result5 = match l2 {
              0 => {
                let e = {
                  let l3 = i32::from(*ptr0.add(1).cast::<u8>());

                  l3 as u8
                };
                Ok(e)
              }
              1 => {
                let e = {
                  let l4 = i32::from(*ptr0.add(1).cast::<u8>());

                  ErrorCode::_lift(l4 as u8)
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            };
            result5
          }
        }
      }
      impl UdpSocket {
        #[allow(unused_unsafe, clippy::all)]
        #[allow(async_fn_in_trait)]
        pub fn set_unicast_hop_limit(&self,value: u8,) -> Result<(),ErrorCode>{
          unsafe {

            #[repr(align(1))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 2]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2026-01-06")]
            unsafe extern "C" {
              #[link_name = "[method]udp-socket.set-unicast-hop-limit"]
              fn wit_import1(_: i32, _: i32, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import1(_: i32, _: i32, _: *mut u8, ) { unreachable!() }
            wit_import1((self).handle() as i32, _rt::as_i32(&value), ptr0);
            let l2 = i32::from(*ptr0.add(0).cast::<u8>());
            let result4 = match l2 {
              0 => {
                let e = ();
                Ok(e)
              }
              1 => {
                let e = {
                  let l3 = i32::from(*ptr0.add(1).cast::<u8>());

                  ErrorCode::_lift(l3 as u8)
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            };
            result4
          }
        }
      }
      impl UdpSocket {
        #[allow(unused_unsafe, clippy::all)]
        /// The kernel buffer space reserved for sends/receives on this socket.
        ///
        /// If the provided value is 0, an `invalid-argument` error is returned.
        /// Any other value will never cause an error, but it might be silently clamped and/or rounded.
        /// I.e. after setting a value, reading the same setting back may return a different value.
        ///
        /// Equivalent to the SO_RCVBUF and SO_SNDBUF socket options.
        ///
        /// # Typical errors
        /// - `invalid-argument`:     (set) The provided value was 0.
        #[allow(async_fn_in_trait)]
        pub fn get_receive_buffer_size(&self,) -> Result<u64,ErrorCode>{
          unsafe {

            #[repr(align(8))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 16]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 16]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2026-01-06")]
            unsafe extern "C" {
              #[link_name = "[method]udp-socket.get-receive-buffer-size"]
              fn wit_import1(_: i32, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, ) { unreachable!() }
            wit_import1((self).handle() as i32, ptr0);
            let l2 = i32::from(*ptr0.add(0).cast::<u8>());
            let result5 = match l2 {
              0 => {
                let e = {
                  let l3 = *ptr0.add(8).cast::<i64>();

                  l3 as u64
                };
                Ok(e)
              }
              1 => {
                let e = {
                  let l4 = i32::from(*ptr0.add(8).cast::<u8>());

                  ErrorCode::_lift(l4 as u8)
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            };
            result5
          }
        }
      }
      impl UdpSocket {
        #[allow(unused_unsafe, clippy::all)]
        #[allow(async_fn_in_trait)]
        pub fn set_receive_buffer_size(&self,value: u64,) -> Result<(),ErrorCode>{
          unsafe {

            #[repr(align(1))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 2]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2026-01-06")]
            unsafe extern "C" {
              #[link_name = "[method]udp-socket.set-receive-buffer-size"]
              fn wit_import1(_: i32, _: i64, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import1(_: i32, _: i64, _: *mut u8, ) { unreachable!() }
            wit_import1((self).handle() as i32, _rt::as_i64(&value), ptr0);
            let l2 = i32::from(*ptr0.add(0).cast::<u8>());
            let result4 = match l2 {
              0 => {
                let e = ();
                Ok(e)
              }
              1 => {
                let e = {
                  let l3 = i32::from(*ptr0.add(1).cast::<u8>());

                  ErrorCode::_lift(l3 as u8)
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            };
            result4
          }
        }
      }
      impl UdpSocket {
        #[allow(unused_unsafe, clippy::all)]
        #[allow(async_fn_in_trait)]
        pub fn get_send_buffer_size(&self,) -> Result<u64,ErrorCode>{
          unsafe {

            #[repr(align(8))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 16]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 16]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2026-01-06")]
            unsafe extern "C" {
              #[link_name = "[method]udp-socket.get-send-buffer-size"]
              fn wit_import1(_: i32, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, ) { unreachable!() }
            wit_import1((self).handle() as i32, ptr0);
            let l2 = i32::from(*ptr0.add(0).cast::<u8>());
            let result5 = match l2 {
              0 => {
                let e = {
                  let l3 = *ptr0.add(8).cast::<i64>();

                  l3 as u64
                };
                Ok(e)
              }
              1 => {
                let e = {
                  let l4 = i32::from(*ptr0.add(8).cast::<u8>());

                  ErrorCode::_lift(l4 as u8)
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            };
            result5
          }
        }
      }
      impl UdpSocket {
        #[allow(unused_unsafe, clippy::all)]
        #[allow(async_fn_in_trait)]
        pub fn set_send_buffer_size(&self,value: u64,) -> Result<(),ErrorCode>{
          unsafe {

            #[repr(align(1))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 2]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2026-01-06")]
            unsafe extern "C" {
              #[link_name = "[method]udp-socket.set-send-buffer-size"]
              fn wit_import1(_: i32, _: i64, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import1(_: i32, _: i64, _: *mut u8, ) { unreachable!() }
            wit_import1((self).handle() as i32, _rt::as_i64(&value), ptr0);
            let l2 = i32::from(*ptr0.add(0).cast::<u8>());
            let result4 = match l2 {
              0 => {
                let e = ();
                Ok(e)
              }
              1 => {
                let e = {
                  let l3 = i32::from(*ptr0.add(1).cast::<u8>());

                  ErrorCode::_lift(l3 as u8)
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            };
            result4
          }
        }
      }

    }


    #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
    pub mod ip_name_lookup {
      #[used]
      #[doc(hidden)]
      static __FORCE_SECTION_REF: fn() =
      super::super::super::__link_custom_section_describing_imports;
      
      use super::super::super::_rt;
      pub type IpAddress = super::super::super::wasi::sockets::types::IpAddress;
      /// Lookup error codes.
      #[repr(u8)]
      #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd, serde::Deserialize, serde::Serialize)]
      pub enum ErrorCode {
        /// Unknown error
        Unknown,
        /// Access denied.
        ///
        /// POSIX equivalent: EACCES, EPERM
        AccessDenied,
        /// `name` is a syntactically invalid domain name or IP address.
        ///
        /// POSIX equivalent: EINVAL
        InvalidArgument,
        /// Name does not exist or has no suitable associated IP addresses.
        ///
        /// POSIX equivalent: EAI_NONAME, EAI_NODATA, EAI_ADDRFAMILY
        NameUnresolvable,
        /// A temporary failure in name resolution occurred.
        ///
        /// POSIX equivalent: EAI_AGAIN
        TemporaryResolverFailure,
        /// A permanent failure in name resolution occurred.
        ///
        /// POSIX equivalent: EAI_FAIL
        PermanentResolverFailure,
      }
      impl ErrorCode{
        pub fn name(&self) -> &'static str {
          match self {
            ErrorCode::Unknown => "unknown",
            ErrorCode::AccessDenied => "access-denied",
            ErrorCode::InvalidArgument => "invalid-argument",
            ErrorCode::NameUnresolvable => "name-unresolvable",
            ErrorCode::TemporaryResolverFailure => "temporary-resolver-failure",
            ErrorCode::PermanentResolverFailure => "permanent-resolver-failure",
          }
        }
        pub fn message(&self) -> &'static str {
          match self {
            ErrorCode::Unknown => "Unknown error",
            ErrorCode::AccessDenied => "Access denied.

            POSIX equivalent: EACCES, EPERM",
            ErrorCode::InvalidArgument => "`name` is a syntactically invalid domain name or IP address.

            POSIX equivalent: EINVAL",
            ErrorCode::NameUnresolvable => "Name does not exist or has no suitable associated IP addresses.

            POSIX equivalent: EAI_NONAME, EAI_NODATA, EAI_ADDRFAMILY",
            ErrorCode::TemporaryResolverFailure => "A temporary failure in name resolution occurred.

            POSIX equivalent: EAI_AGAIN",
            ErrorCode::PermanentResolverFailure => "A permanent failure in name resolution occurred.

            POSIX equivalent: EAI_FAIL",
          }
        }
      }
      impl ::core::fmt::Debug for ErrorCode{
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("ErrorCode")
          .field("code", &(*self as i32))
          .field("name", &self.name())
          .field("message", &self.message())
          .finish()
        }
      }
      impl ::core::fmt::Display for ErrorCode{
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          write!(f, "{} (error {})", self.name(), *self as i32)
        }
      }

      impl ::core::error::Error for ErrorCode {}

      impl ErrorCode{
        #[doc(hidden)]
        pub unsafe fn _lift(val: u8) -> ErrorCode{
          if !cfg!(debug_assertions) {
            return unsafe { ::core::mem::transmute(val) };
          }

          match val {
            0 => ErrorCode::Unknown,
            1 => ErrorCode::AccessDenied,
            2 => ErrorCode::InvalidArgument,
            3 => ErrorCode::NameUnresolvable,
            4 => ErrorCode::TemporaryResolverFailure,
            5 => ErrorCode::PermanentResolverFailure,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }

      #[allow(unused_unsafe, clippy::all)]
      /// Resolve an internet host name to a list of IP addresses.
      ///
      /// Unicode domain names are automatically converted to ASCII using IDNA encoding.
      /// If the input is an IP address string, the address is parsed and returned
      /// as-is without making any external requests.
      ///
      /// See the wasi-socket proposal README.md for a comparison with getaddrinfo.
      ///
      /// The results are returned in connection order preference.
      ///
      /// This function never succeeds with 0 results. It either fails or succeeds
      /// with at least one address. Additionally, this function never returns
      /// IPv4-mapped IPv6 addresses.
      ///
      /// The returned future will resolve to an error code in case of failure.
      /// It will resolve to success once the returned stream is exhausted.
      ///
      /// # References:
      /// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/getaddrinfo.html>
      /// - <https://man7.org/linux/man-pages/man3/getaddrinfo.3.html>
      /// - <https://learn.microsoft.com/en-us/windows/win32/api/ws2tcpip/nf-ws2tcpip-getaddrinfo>
      /// - <https://man.freebsd.org/cgi/man.cgi?query=getaddrinfo&sektion=3>
      #[allow(async_fn_in_trait)]
      pub fn resolve_addresses(name: &str,) -> Result<_rt::Vec::<IpAddress>,ErrorCode>{
        unsafe {

          #[cfg_attr(target_pointer_width="64", repr(align(8)))]
          #[cfg_attr(target_pointer_width="32", repr(align(4)))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 3*::core::mem::size_of::<*const u8>()]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 3*::core::mem::size_of::<*const u8>()]);
          let vec0 = name;
          let ptr0 = vec0.as_ptr().cast::<u8>();
          let len0 = vec0.len();
          let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:sockets/ip-name-lookup@0.3.0-rc-2026-01-06")]
          unsafe extern "C" {
            #[link_name = "resolve-addresses"]
            fn wit_import2(_: *mut u8, _: usize, _: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn wit_import2(_: *mut u8, _: usize, _: *mut u8, ) { unreachable!() }
          wit_import2(ptr0.cast_mut(), len0, ptr1);
          let l3 = i32::from(*ptr1.add(0).cast::<u8>());
          let result22 = match l3 {
            0 => {
              let e = {
                let l4 = *ptr1.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                let l5 = *ptr1.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>();
                let base20 = l4;
                let len20 = l5;
                let mut result20 = _rt::Vec::with_capacity(len20);
                for i in 0..len20 {
                  let base = base20.add(i * 18);
                  let e20 = {
                    let l6 = i32::from(*base.add(0).cast::<u8>());
                    use super::super::super::wasi::sockets::types::IpAddress as V19;
                    let v19 = match l6 {
                      0 => {
                        let e19 = {
                          let l7 = i32::from(*base.add(2).cast::<u8>());
                          let l8 = i32::from(*base.add(3).cast::<u8>());
                          let l9 = i32::from(*base.add(4).cast::<u8>());
                          let l10 = i32::from(*base.add(5).cast::<u8>());

                          (l7 as u8, l8 as u8, l9 as u8, l10 as u8)
                        };
                        V19::Ipv4(e19)
                      }
                      n => {
                        debug_assert_eq!(n, 1, "invalid enum discriminant");
                        let e19 = {
                          let l11 = i32::from(*base.add(2).cast::<u16>());
                          let l12 = i32::from(*base.add(4).cast::<u16>());
                          let l13 = i32::from(*base.add(6).cast::<u16>());
                          let l14 = i32::from(*base.add(8).cast::<u16>());
                          let l15 = i32::from(*base.add(10).cast::<u16>());
                          let l16 = i32::from(*base.add(12).cast::<u16>());
                          let l17 = i32::from(*base.add(14).cast::<u16>());
                          let l18 = i32::from(*base.add(16).cast::<u16>());

                          (l11 as u16, l12 as u16, l13 as u16, l14 as u16, l15 as u16, l16 as u16, l17 as u16, l18 as u16)
                        };
                        V19::Ipv6(e19)
                      }
                    };

                    v19
                  };
                  result20.push(e20);
                }
                _rt::cabi_dealloc(base20, len20 * 18, 2);

                result20
              };
              Ok(e)
            }
            1 => {
              let e = {
                let l21 = i32::from(*ptr1.add(::core::mem::size_of::<*const u8>()).cast::<u8>());

                ErrorCode::_lift(l21 as u8)
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          };
          result22
        }
      }

    }

  }
}
#[allow(dead_code, clippy::all)]
pub mod exports {
  pub mod igloo {
    pub mod lib {

      #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
      pub mod core_to_extension_sp {
        #[used]
        #[doc(hidden)]
        static __FORCE_SECTION_REF: fn() =
        super::super::super::super::__link_custom_section_describing_imports;
        
        use super::super::super::super::_rt;
        pub type DeviceId = super::super::super::super::__with_name0::DeviceId;
        pub type EntityIndex = super::super::super::super::__with_name0::EntityIndex;
        pub type Component = super::super::super::super::__with_name2::Component;
        #[doc(hidden)]
        #[allow(non_snake_case, unused_unsafe)]
        pub unsafe fn _export_put_component_cabi<T: Guest>(arg0: i64,arg1: i64,arg2: i32,arg3: ::core::mem::MaybeUninit::<u64>,arg4: i64,arg5: i64,) -> *mut u8 { unsafe {#[cfg(target_arch="wasm32")]
        _rt::run_ctors_once();let result15 = {
          use super::super::super::super::__with_name2::Component as V14;
          let v14 = match arg2 {
            0 => {
              let e14 = arg3.assume_init() as i64;
              V14::Integer(e14)
            }
            1 => {
              let e14 = f64::from_bits(arg3.assume_init() as i64 as u64);
              V14::Float(e14)
            }
            2 => {
              let e14 = {
                let len0 = arg4 as usize;
                let bytes0 = _rt::Vec::from_raw_parts(arg3.as_ptr().cast::<*mut u8>().read().cast(), len0, len0);

                _rt::string_lift(bytes0)
              };
              V14::String(e14)
            }
            3 => {
              let e14 = _rt::bool_lift(arg3.assume_init() as i64 as i32 as u8);
              V14::Bool(e14)
            }
            4 => {
              let e14 = super::super::super::super::__with_name1::IglooColor{
                r: f64::from_bits(arg3.assume_init() as i64 as u64),
                g: f64::from_bits(arg4 as u64),
                b: f64::from_bits(arg5 as u64),
              };
              V14::Color(e14)
            }
            5 => {
              let e14 = super::super::super::super::__with_name1::IglooDate{
                year: arg3.assume_init() as i64 as i32 as u16,
                month: arg4 as i32 as u8,
                day: arg5 as i32 as u8,
              };
              V14::Date(e14)
            }
            6 => {
              let e14 = super::super::super::super::__with_name1::IglooTime{
                hour: arg3.assume_init() as i64 as i32 as u8,
                minute: arg4 as i32 as u8,
                second: arg5 as i32 as u8,
              };
              V14::Time(e14)
            }
            7 => {
              let e14 = {
                let len1 = arg4 as usize;

                <_ as From<_rt::Vec<_>>>::from(_rt::Vec::from_raw_parts(arg3.as_ptr().cast::<*mut u8>().read().cast(), len1, len1))
              };
              V14::IntegerList(e14)
            }
            8 => {
              let e14 = {
                let len2 = arg4 as usize;

                <_ as From<_rt::Vec<_>>>::from(_rt::Vec::from_raw_parts(arg3.as_ptr().cast::<*mut u8>().read().cast(), len2, len2))
              };
              V14::FloatList(e14)
            }
            9 => {
              let e14 = {
                let base6 = arg3.as_ptr().cast::<*mut u8>().read();
                let len6 = arg4 as usize;
                let mut result6 = _rt::Vec::with_capacity(len6);
                for i in 0..len6 {
                  let base = base6.add(i * (2*::core::mem::size_of::<*const u8>()));
                  let e6 = {
                    let l3 = *base.add(0).cast::<*mut u8>();
                    let l4 = *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
                    let len5 = l4;
                    let bytes5 = _rt::Vec::from_raw_parts(l3.cast(), len5, len5);

                    _rt::string_lift(bytes5)
                  };
                  result6.push(e6);
                }
                _rt::cabi_dealloc(base6, len6 * (2*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>());

                result6
              };
              V14::StringList(e14)
            }
            10 => {
              let e14 = {
                let base8 = arg3.as_ptr().cast::<*mut u8>().read();
                let len8 = arg4 as usize;
                let mut result8 = _rt::Vec::with_capacity(len8);
                for i in 0..len8 {
                  let base = base8.add(i * 1);
                  let e8 = {
                    let l7 = i32::from(*base.add(0).cast::<u8>());

                    _rt::bool_lift(l7 as u8)
                  };
                  result8.push(e8);
                }
                _rt::cabi_dealloc(base8, len8 * 1, 1);

                result8
              };
              V14::BooleanList(e14)
            }
            11 => {
              let e14 = {
                let len9 = arg4 as usize;

                <_ as From<_rt::Vec<_>>>::from(_rt::Vec::from_raw_parts(arg3.as_ptr().cast::<*mut u8>().read().cast(), len9, len9))
              };
              V14::ColorList(e14)
            }
            12 => {
              let e14 = {
                let len10 = arg4 as usize;

                <_ as From<_rt::Vec<_>>>::from(_rt::Vec::from_raw_parts(arg3.as_ptr().cast::<*mut u8>().read().cast(), len10, len10))
              };
              V14::DateList(e14)
            }
            13 => {
              let e14 = {
                let len11 = arg4 as usize;

                <_ as From<_rt::Vec<_>>>::from(_rt::Vec::from_raw_parts(arg3.as_ptr().cast::<*mut u8>().read().cast(), len11, len11))
              };
              V14::TimeList(e14)
            }
            14 => {
              V14::Trigger
            }
            15 => {
              let e14 = arg3.assume_init() as i64;
              V14::Timestamp(e14)
            }
            16 => {
              let e14 = arg3.assume_init() as i64;
              V14::Duration(e14)
            }
            17 => {
              let e14 = super::super::super::super::__with_name2::Weekday::_lift(arg3.assume_init() as i64 as i32 as u8);
              V14::Weekday(e14)
            }
            18 => {
              V14::Light
            }
            19 => {
              let e14 = _rt::bool_lift(arg3.assume_init() as i64 as i32 as u8);
              V14::Switch(e14)
            }
            20 => {
              let e14 = f64::from_bits(arg3.assume_init() as i64 as u64);
              V14::Dimmer(e14)
            }
            21 => {
              let e14 = _rt::bool_lift(arg3.assume_init() as i64 as i32 as u8);
              V14::Switch(e14)
            }
            22 => {
              let e14 = super::super::super::super::__with_name2::ColorMode::_lift(arg3.assume_init() as i64 as i32 as u8);
              V14::ColorMode(e14)
            }
            23 => {
              let e14 = arg3.assume_init() as i64;
              V14::ColorTemperature(e14)
            }
            24 => {
              let e14 = f64::from_bits(arg3.assume_init() as i64 as u64);
              V14::Volume(e14)
            }
            25 => {
              let e14 = _rt::bool_lift(arg3.assume_init() as i64 as i32 as u8);
              V14::Muted(e14)
            }
            26 => {
              V14::Config
            }
            27 => {
              V14::Diagnostic
            }
            28 => {
              V14::Siren
            }
            29 => {
              V14::Sensor
            }
            30 => {
              let e14 = {
                let len12 = arg4 as usize;
                let bytes12 = _rt::Vec::from_raw_parts(arg3.as_ptr().cast::<*mut u8>().read().cast(), len12, len12);

                _rt::string_lift(bytes12)
              };
              V14::Icon(e14)
            }
            31 => {
              let e14 = arg3.assume_init() as i64;
              V14::AccuracyDecimals(e14)
            }
            32 => {
              let e14 = {
                let len13 = arg4 as usize;
                let bytes13 = _rt::Vec::from_raw_parts(arg3.as_ptr().cast::<*mut u8>().read().cast(), len13, len13);

                _rt::string_lift(bytes13)
              };
              V14::DeviceClass(e14)
            }
            33 => {
              let e14 = super::super::super::super::__with_name2::SensorStateClass::_lift(arg3.assume_init() as i64 as i32 as u8);
              V14::SensorStateClass(e14)
            }
            34 => {
              let e14 = super::super::super::super::__with_name2::UnitApparentPower::_lift(arg3.assume_init() as i64 as i32 as u8);
              V14::UnitApparentPower(e14)
            }
            35 => {
              let e14 = super::super::super::super::__with_name2::UnitPower::_lift(arg3.assume_init() as i64 as i32 as u8);
              V14::UnitPower(e14)
            }
            36 => {
              let e14 = super::super::super::super::__with_name2::UnitReactivePower::_lift(arg3.assume_init() as i64 as i32 as u8);
              V14::UnitReactivePower(e14)
            }
            37 => {
              let e14 = super::super::super::super::__with_name2::UnitEnergy::_lift(arg3.assume_init() as i64 as i32 as u8);
              V14::UnitEnergy(e14)
            }
            38 => {
              let e14 = super::super::super::super::__with_name2::UnitElectricCurrent::_lift(arg3.assume_init() as i64 as i32 as u8);
              V14::UnitElectricCurrent(e14)
            }
            39 => {
              let e14 = super::super::super::super::__with_name2::UnitElectricPotential::_lift(arg3.assume_init() as i64 as i32 as u8);
              V14::UnitElectricPotential(e14)
            }
            40 => {
              let e14 = super::super::super::super::__with_name2::UnitDegree::_lift(arg3.assume_init() as i64 as i32 as u8);
              V14::UnitDegree(e14)
            }
            41 => {
              let e14 = super::super::super::super::__with_name2::UnitCurrency::_lift(arg3.assume_init() as i64 as i32 as u8);
              V14::UnitCurrency(e14)
            }
            42 => {
              let e14 = super::super::super::super::__with_name2::UnitTemperature::_lift(arg3.assume_init() as i64 as i32 as u8);
              V14::UnitTemperature(e14)
            }
            43 => {
              let e14 = super::super::super::super::__with_name2::UnitTime::_lift(arg3.assume_init() as i64 as i32 as u8);
              V14::UnitTime(e14)
            }
            44 => {
              let e14 = super::super::super::super::__with_name2::UnitLength::_lift(arg3.assume_init() as i64 as i32 as u8);
              V14::UnitLength(e14)
            }
            45 => {
              let e14 = super::super::super::super::__with_name2::UnitFrequency::_lift(arg3.assume_init() as i64 as i32 as u8);
              V14::UnitFrequency(e14)
            }
            46 => {
              let e14 = super::super::super::super::__with_name2::UnitPressure::_lift(arg3.assume_init() as i64 as i32 as u8);
              V14::UnitPressure(e14)
            }
            47 => {
              let e14 = super::super::super::super::__with_name2::UnitSoundPressure::_lift(arg3.assume_init() as i64 as i32 as u8);
              V14::UnitSoundPressure(e14)
            }
            48 => {
              let e14 = super::super::super::super::__with_name2::UnitVolume::_lift(arg3.assume_init() as i64 as i32 as u8);
              V14::UnitVolume(e14)
            }
            49 => {
              let e14 = super::super::super::super::__with_name2::UnitVolumeFlowRate::_lift(arg3.assume_init() as i64 as i32 as u8);
              V14::UnitVolumeFlowRate(e14)
            }
            50 => {
              let e14 = super::super::super::super::__with_name2::UnitArea::_lift(arg3.assume_init() as i64 as i32 as u8);
              V14::UnitArea(e14)
            }
            51 => {
              let e14 = super::super::super::super::__with_name2::UnitMass::_lift(arg3.assume_init() as i64 as i32 as u8);
              V14::UnitMass(e14)
            }
            52 => {
              let e14 = super::super::super::super::__with_name2::UnitConductivity::_lift(arg3.assume_init() as i64 as i32 as u8);
              V14::UnitConductivity(e14)
            }
            53 => {
              let e14 = super::super::super::super::__with_name2::UnitLight::_lift(arg3.assume_init() as i64 as i32 as u8);
              V14::UnitLight(e14)
            }
            54 => {
              let e14 = super::super::super::super::__with_name2::UnitUvIndex::_lift(arg3.assume_init() as i64 as i32 as u8);
              V14::UnitUvIndex(e14)
            }
            55 => {
              let e14 = super::super::super::super::__with_name2::UnitPercentage::_lift(arg3.assume_init() as i64 as i32 as u8);
              V14::UnitPercentage(e14)
            }
            56 => {
              let e14 = super::super::super::super::__with_name2::UnitIrradiation::_lift(arg3.assume_init() as i64 as i32 as u8);
              V14::UnitIrradiation(e14)
            }
            57 => {
              let e14 = super::super::super::super::__with_name2::UnitConcentration::_lift(arg3.assume_init() as i64 as i32 as u8);
              V14::UnitConcentration(e14)
            }
            58 => {
              let e14 = super::super::super::super::__with_name2::UnitSpeed::_lift(arg3.assume_init() as i64 as i32 as u8);
              V14::UnitSpeed(e14)
            }
            59 => {
              let e14 = super::super::super::super::__with_name2::UnitData::_lift(arg3.assume_init() as i64 as i32 as u8);
              V14::UnitData(e14)
            }
            60 => {
              let e14 = super::super::super::super::__with_name2::UnitDataRate::_lift(arg3.assume_init() as i64 as i32 as u8);
              V14::UnitDataRate(e14)
            }
            61 => {
              let e14 = super::super::super::super::__with_name2::FanOscillation::_lift(arg3.assume_init() as i64 as i32 as u8);
              V14::FanOscillation(e14)
            }
            62 => {
              let e14 = super::super::super::super::__with_name2::FanDirection::_lift(arg3.assume_init() as i64 as i32 as u8);
              V14::FanDirection(e14)
            }
            63 => {
              let e14 = super::super::super::super::__with_name2::FanSpeed::_lift(arg3.assume_init() as i64 as i32 as u8);
              V14::FanSpeed(e14)
            }
            64 => {
              let e14 = super::super::super::super::__with_name2::ClimateMode::_lift(arg3.assume_init() as i64 as i32 as u8);
              V14::ClimateMode(e14)
            }
            65 => {
              let e14 = super::super::super::super::__with_name2::LockState::_lift(arg3.assume_init() as i64 as i32 as u8);
              V14::LockState(e14)
            }
            66 => {
              let e14 = super::super::super::super::__with_name2::MediaState::_lift(arg3.assume_init() as i64 as i32 as u8);
              V14::MediaState(e14)
            }
            67 => {
              V14::Cover
            }
            68 => {
              let e14 = super::super::super::super::__with_name2::CoverState::_lift(arg3.assume_init() as i64 as i32 as u8);
              V14::CoverState(e14)
            }
            69 => {
              let e14 = f64::from_bits(arg3.assume_init() as i64 as u64);
              V14::Position(e14)
            }
            70 => {
              let e14 = f64::from_bits(arg3.assume_init() as i64 as u64);
              V14::Tilt(e14)
            }
            71 => {
              V14::Valve
            }
            72 => {
              let e14 = super::super::super::super::__with_name2::ValveState::_lift(arg3.assume_init() as i64 as i32 as u8);
              V14::ValveState(e14)
            }
            n => {
              debug_assert_eq!(n, 73, "invalid enum discriminant");
              let e14 = super::super::super::super::__with_name2::AlarmState::_lift(arg3.assume_init() as i64 as i32 as u8);
              V14::AlarmState(e14)
            }
          };
          T::put_component(super::super::super::super::__with_name0::DeviceId{
            packed: arg0 as u64,
          }, super::super::super::super::__with_name0::EntityIndex{
            inner: arg1 as u64,
          }, v14)
        };
        let ptr16 = (&raw mut _RET_AREA.0).cast::<u8>();
        match result15 {
          Ok(_) => { {
            *ptr16.add(0).cast::<u8>() = (0i32) as u8;
          } },
          Err(e) => { {
            *ptr16.add(0).cast::<u8>() = (1i32) as u8;
            let vec17 = (e.into_bytes()).into_boxed_slice();
            let ptr17 = vec17.as_ptr().cast::<u8>();
            let len17 = vec17.len();
            ::core::mem::forget(vec17);
            *ptr16.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>() = len17;
            *ptr16.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr17.cast_mut();
          } },
        };ptr16
      } }
      #[doc(hidden)]
      #[allow(non_snake_case)]
      pub unsafe fn __post_return_put_component<T: Guest>(arg0: *mut u8,) { unsafe {
        let l0 = i32::from(*arg0.add(0).cast::<u8>());
        match l0 {
          0 => (),
          _ => {
            let l1 = *arg0.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
            let l2 = *arg0.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>();
            _rt::cabi_dealloc(l1, l2, 1);
          },
        }
      } }
      #[doc(hidden)]
      #[allow(non_snake_case, unused_unsafe)]
      pub unsafe fn _export_delete_device_cabi<T: Guest>(arg0: i64,) -> *mut u8 { unsafe {#[cfg(target_arch="wasm32")]
      _rt::run_ctors_once();let result0 = {
        T::delete_device(super::super::super::super::__with_name0::DeviceId{
          packed: arg0 as u64,
        })
      };
      let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
      match result0 {
        Ok(_) => { {
          *ptr1.add(0).cast::<u8>() = (0i32) as u8;
        } },
        Err(e) => { {
          *ptr1.add(0).cast::<u8>() = (1i32) as u8;
          let vec2 = (e.into_bytes()).into_boxed_slice();
          let ptr2 = vec2.as_ptr().cast::<u8>();
          let len2 = vec2.len();
          ::core::mem::forget(vec2);
          *ptr1.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>() = len2;
          *ptr1.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr2.cast_mut();
        } },
      };ptr1
    } }
    #[doc(hidden)]
    #[allow(non_snake_case)]
    pub unsafe fn __post_return_delete_device<T: Guest>(arg0: *mut u8,) { unsafe {
      let l0 = i32::from(*arg0.add(0).cast::<u8>());
      match l0 {
        0 => (),
        _ => {
          let l1 = *arg0.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
          let l2 = *arg0.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>();
          _rt::cabi_dealloc(l1, l2, 1);
        },
      }
    } }
    #[doc(hidden)]
    #[allow(non_snake_case, unused_unsafe)]
    pub unsafe fn _export_custom_cabi<T: Guest>(arg0: *mut u8,arg1: usize,arg2: *mut u8,arg3: usize,) -> *mut u8 { unsafe {#[cfg(target_arch="wasm32")]
    _rt::run_ctors_once();let result2 = {
      let len0 = arg1;
      let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
      let len1 = arg3;
      let bytes1 = _rt::Vec::from_raw_parts(arg2.cast(), len1, len1);
      T::custom(_rt::string_lift(bytes0), _rt::string_lift(bytes1))
    };
    let ptr3 = (&raw mut _RET_AREA.0).cast::<u8>();
    match result2 {
      Ok(_) => { {
        *ptr3.add(0).cast::<u8>() = (0i32) as u8;
      } },
      Err(e) => { {
        *ptr3.add(0).cast::<u8>() = (1i32) as u8;
        let vec4 = (e.into_bytes()).into_boxed_slice();
        let ptr4 = vec4.as_ptr().cast::<u8>();
        let len4 = vec4.len();
        ::core::mem::forget(vec4);
        *ptr3.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>() = len4;
        *ptr3.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr4.cast_mut();
      } },
    };ptr3
  } }
  #[doc(hidden)]
  #[allow(non_snake_case)]
  pub unsafe fn __post_return_custom<T: Guest>(arg0: *mut u8,) { unsafe {
    let l0 = i32::from(*arg0.add(0).cast::<u8>());
    match l0 {
      0 => (),
      _ => {
        let l1 = *arg0.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
        let l2 = *arg0.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>();
        _rt::cabi_dealloc(l1, l2, 1);
      },
    }
  } }
  pub trait Guest {
    /// Igloo core request to put a component on the given device and entity.
    /// The change will not be applied to the device tree until the extension
    /// confirms by sending a `put-component` back
    /// (usually after response from the physical hardware device)
    ///
    /// The extension _should_ hint to the core whether the operation will
    /// succeed by returning either `Ok` or `Err`
    #[allow(async_fn_in_trait)]
    fn put_component(device_id: DeviceId,entity_index: EntityIndex,component: Component,) -> Result<(),_rt::String>;
    /// Igloo has deleted device,
    /// extension must cleanup its `Device` reference
    #[allow(async_fn_in_trait)]
    fn delete_device(device_id: DeviceId,) -> Result<(),_rt::String>;
    /// Custom function defined by extension
    #[allow(async_fn_in_trait)]
    fn custom(name: _rt::String,params: _rt::String,) -> Result<(),_rt::String>;
  }
  #[doc(hidden)]

  macro_rules! __export_igloo_lib_core_to_extension_sp_0_1_0_cabi{
    ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

      #[unsafe(export_name = "igloo:lib/core-to-extension-sp@0.1.0#put-component")]
      unsafe extern "C" fn export_put_component(arg0: i64,arg1: i64,arg2: i32,arg3: ::core::mem::MaybeUninit::<u64>,arg4: i64,arg5: i64,) -> *mut u8 {
        unsafe { $($path_to_types)*::_export_put_component_cabi::<$ty>(arg0, arg1, arg2, arg3, arg4, arg5) }
      }
      #[unsafe(export_name = "cabi_post_igloo:lib/core-to-extension-sp@0.1.0#put-component")]
      unsafe extern "C" fn _post_return_put_component(arg0: *mut u8,) {
        unsafe { $($path_to_types)*::__post_return_put_component::<$ty>(arg0) }
      }
      #[unsafe(export_name = "igloo:lib/core-to-extension-sp@0.1.0#delete-device")]
      unsafe extern "C" fn export_delete_device(arg0: i64,) -> *mut u8 {
        unsafe { $($path_to_types)*::_export_delete_device_cabi::<$ty>(arg0) }
      }
      #[unsafe(export_name = "cabi_post_igloo:lib/core-to-extension-sp@0.1.0#delete-device")]
      unsafe extern "C" fn _post_return_delete_device(arg0: *mut u8,) {
        unsafe { $($path_to_types)*::__post_return_delete_device::<$ty>(arg0) }
      }
      #[unsafe(export_name = "igloo:lib/core-to-extension-sp@0.1.0#custom")]
      unsafe extern "C" fn export_custom(arg0: *mut u8,arg1: usize,arg2: *mut u8,arg3: usize,) -> *mut u8 {
        unsafe { $($path_to_types)*::_export_custom_cabi::<$ty>(arg0, arg1, arg2, arg3) }
      }
      #[unsafe(export_name = "cabi_post_igloo:lib/core-to-extension-sp@0.1.0#custom")]
      unsafe extern "C" fn _post_return_custom(arg0: *mut u8,) {
        unsafe { $($path_to_types)*::__post_return_custom::<$ty>(arg0) }
      }
    };);
  }
  #[doc(hidden)]
  pub(crate) use __export_igloo_lib_core_to_extension_sp_0_1_0_cabi;

  #[cfg_attr(target_pointer_width="64", repr(align(8)))]
  #[cfg_attr(target_pointer_width="32", repr(align(4)))]
  struct _RetArea([::core::mem::MaybeUninit::<u8>; 3*::core::mem::size_of::<*const u8>()]);
  static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 3*::core::mem::size_of::<*const u8>()]);

}

}
}
pub mod wasi {
  pub mod cli {

    #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
    pub mod run {
      #[used]
      #[doc(hidden)]
      static __FORCE_SECTION_REF: fn() =
      super::super::super::super::__link_custom_section_describing_imports;
      
      use super::super::super::super::_rt;
      #[doc(hidden)]
      #[allow(non_snake_case, unused_unsafe)]
      pub unsafe fn _export_run_cabi<T: Guest>() -> i32 { unsafe {#[cfg(target_arch="wasm32")]
      _rt::run_ctors_once();let result0 = {
        T::run()
      };
      let result1 = match result0 {
        Ok(_) => { 0i32 },
        Err(_) => { 1i32 },
      };result1
    } }
    pub trait Guest {
      /// Run the program.
      #[allow(async_fn_in_trait)]
      fn run() -> Result<(),()>;
    }
    #[doc(hidden)]

    macro_rules! __export_wasi_cli_run_0_3_0_rc_2026_01_06_cabi{
      ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

        #[unsafe(export_name = "wasi:cli/run@0.3.0-rc-2026-01-06#run")]
        unsafe extern "C" fn export_run() -> i32 {
          unsafe { $($path_to_types)*::_export_run_cabi::<$ty>() }
        }
      };);
    }
    #[doc(hidden)]
    pub(crate) use __export_wasi_cli_run_0_3_0_rc_2026_01_06_cabi;

  }

}
}
}
mod _rt {
  #![allow(dead_code, unused_imports, clippy::all)]


  use core::fmt;
  use core::marker;
  use core::sync::atomic::{AtomicU32, Ordering::Relaxed};

  /// A type which represents a component model resource, either imported or
  /// exported into this component.
  ///
  /// This is a low-level wrapper which handles the lifetime of the resource
  /// (namely this has a destructor). The `T` provided defines the component model
  /// intrinsics that this wrapper uses.
  ///
  /// One of the chief purposes of this type is to provide `Deref` implementations
  /// to access the underlying data when it is owned.
  ///
  /// This type is primarily used in generated code for exported and imported
  /// resources.
  #[repr(transparent)]
  pub struct Resource<T: WasmResource> {
    // NB: This would ideally be `u32` but it is not. The fact that this has
    // interior mutability is not exposed in the API of this type except for the
    // `take_handle` method which is supposed to in theory be private.
    //
    // This represents, almost all the time, a valid handle value. When it's
    // invalid it's stored as `u32::MAX`.
    handle: AtomicU32,
    _marker: marker::PhantomData<T>,
  }

  /// A trait which all wasm resources implement, namely providing the ability to
  /// drop a resource.
  ///
  /// This generally is implemented by generated code, not user-facing code.
  #[allow(clippy::missing_safety_doc)]
  pub unsafe trait WasmResource {
    /// Invokes the `[resource-drop]...` intrinsic.
    unsafe fn drop(handle: u32);
  }

  impl<T: WasmResource> Resource<T> {
    #[doc(hidden)]
    pub unsafe fn from_handle(handle: u32) -> Self {
      debug_assert!(handle != 0 && handle != u32::MAX);
      Self {
        handle: AtomicU32::new(handle),
        _marker: marker::PhantomData,
      }
    }

    /// Takes ownership of the handle owned by `resource`.
    ///
    /// Note that this ideally would be `into_handle` taking `Resource<T>` by
    /// ownership. The code generator does not enable that in all situations,
    /// unfortunately, so this is provided instead.
    ///
    /// Also note that `take_handle` is in theory only ever called on values
    /// owned by a generated function. For example a generated function might
    /// take `Resource<T>` as an argument but then call `take_handle` on a
    /// reference to that argument. In that sense the dynamic nature of
    /// `take_handle` should only be exposed internally to generated code, not
    /// to user code.
    #[doc(hidden)]
    pub fn take_handle(resource: &Resource<T>) -> u32 {
      resource.handle.swap(u32::MAX, Relaxed)
    }

    #[doc(hidden)]
    pub fn handle(resource: &Resource<T>) -> u32 {
      resource.handle.load(Relaxed)
    }
  }

  impl<T: WasmResource> fmt::Debug for Resource<T> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
      f.debug_struct("Resource")
      .field("handle", &self.handle)
      .finish()
    }
  }

  impl<T: WasmResource> Drop for Resource<T> {
    fn drop(&mut self) {
      unsafe {
        match self.handle.load(Relaxed) {
          // If this handle was "taken" then don't do anything in the
          // destructor.
          u32::MAX => {}

          // ... but otherwise do actually destroy it with the imported
          // component model intrinsic as defined through `T`.
          other => T::drop(other),
        }
      }
    }
  }
  pub use alloc_crate::vec::Vec;
  pub unsafe fn string_lift(bytes: Vec<u8>) -> String {
    if cfg!(debug_assertions) {
      String::from_utf8(bytes).unwrap()
    } else {
      unsafe { String::from_utf8_unchecked(bytes) }
    }
  }
  
  pub fn as_i64<T: AsI64>(t: T) -> i64 {
    t.as_i64()
  }

  pub trait AsI64 {
    fn as_i64(self) -> i64;
  }

  impl<'a, T: Copy + AsI64> AsI64 for &'a T {
    fn as_i64(self) -> i64 {
      (*self).as_i64()
    }
  }
  
  impl AsI64 for i64 {
    #[inline]
    fn as_i64(self) -> i64 {
      self as i64
    }
  }
  
  impl AsI64 for u64 {
    #[inline]
    fn as_i64(self) -> i64 {
      self as i64
    }
  }
  
  pub fn as_f64<T: AsF64>(t: T) -> f64 {
    t.as_f64()
  }

  pub trait AsF64 {
    fn as_f64(self) -> f64;
  }

  impl<'a, T: Copy + AsF64> AsF64 for &'a T {
    fn as_f64(self) -> f64 {
      (*self).as_f64()
    }
  }
  
  impl AsF64 for f64 {
    #[inline]
    fn as_f64(self) -> f64 {
      self as f64
    }
  }
  
  pub fn as_i32<T: AsI32>(t: T) -> i32 {
    t.as_i32()
  }

  pub trait AsI32 {
    fn as_i32(self) -> i32;
  }

  impl<'a, T: Copy + AsI32> AsI32 for &'a T {
    fn as_i32(self) -> i32 {
      (*self).as_i32()
    }
  }
  
  impl AsI32 for i32 {
    #[inline]
    fn as_i32(self) -> i32 {
      self as i32
    }
  }
  
  impl AsI32 for u32 {
    #[inline]
    fn as_i32(self) -> i32 {
      self as i32
    }
  }
  
  impl AsI32 for i16 {
    #[inline]
    fn as_i32(self) -> i32 {
      self as i32
    }
  }
  
  impl AsI32 for u16 {
    #[inline]
    fn as_i32(self) -> i32 {
      self as i32
    }
  }
  
  impl AsI32 for i8 {
    #[inline]
    fn as_i32(self) -> i32 {
      self as i32
    }
  }
  
  impl AsI32 for u8 {
    #[inline]
    fn as_i32(self) -> i32 {
      self as i32
    }
  }
  
  impl AsI32 for char {
    #[inline]
    fn as_i32(self) -> i32 {
      self as i32
    }
  }
  
  impl AsI32 for usize {
    #[inline]
    fn as_i32(self) -> i32 {
      self as i32
    }
  }
  pub use alloc_crate::alloc;
  pub unsafe fn invalid_enum_discriminant<T>() -> T {
    if cfg!(debug_assertions) {
      panic!("invalid enum discriminant")
    } else {
      unsafe { core::hint::unreachable_unchecked() }
    }
  }
  pub unsafe fn cabi_dealloc(ptr: *mut u8, size: usize, align: usize) {
    if size == 0 {
      return;
    }
    unsafe {
      let layout = alloc::Layout::from_size_align_unchecked(size, align);
      alloc::dealloc(ptr, layout);
    }
  }
  pub use alloc_crate::string::String;
  pub unsafe fn bool_lift(val: u8) -> bool {
    if cfg!(debug_assertions) {
      match val {
        0 => false,
        1 => true,
        _ => panic!("invalid bool discriminant"),
      }
    } else {
      val != 0
    }
  }
  
  #[cfg(target_arch = "wasm32")]
  pub fn run_ctors_once() {
    wit_bindgen::rt::run_ctors_once();
  }
  extern crate alloc as alloc_crate;
}
pub mod wit_future {
  #![allow(dead_code, unused_variables, clippy::all)]

  #[doc(hidden)]
  pub trait FuturePayload: Unpin + Sized + 'static {
    const VTABLE: &'static wit_bindgen::rt::async_support::FutureVtable<Self>;
  }
  #[doc(hidden)]
  #[allow(unused_unsafe)]
  pub mod vtable0 {

    #[cfg(not(target_arch = "wasm32"))]
    unsafe extern "C" fn cancel_write(_: u32) -> u32 { unreachable!() }
    #[cfg(not(target_arch = "wasm32"))]
    unsafe extern "C" fn cancel_read(_: u32) -> u32 { unreachable!() }
    #[cfg(not(target_arch = "wasm32"))]
    unsafe extern "C" fn drop_writable(_: u32) { unreachable!() }
    #[cfg(not(target_arch = "wasm32"))]
    unsafe extern "C" fn drop_readable(_: u32) { unreachable!() }
    #[cfg(not(target_arch = "wasm32"))]
    unsafe extern "C" fn new() -> u64 { unreachable!() }
    #[cfg(not(target_arch = "wasm32"))]
    unsafe extern "C" fn start_read(_: u32, _: *mut u8) -> u32 { unreachable!() }
    #[cfg(not(target_arch = "wasm32"))]
    unsafe extern "C" fn start_write(_: u32, _: *const u8) -> u32 { unreachable!() }

    #[cfg(target_arch = "wasm32")]
    #[link(wasm_import_module = "wasi:cli/stdin@0.3.0-rc-2026-01-06")]
    unsafe extern "C" {
      #[link_name = "[future-new-1]read-via-stream"]
      fn new() -> u64;
      #[link_name = "[future-cancel-write-1]read-via-stream"]
      fn cancel_write(_: u32) -> u32;
      #[link_name = "[future-cancel-read-1]read-via-stream"]
      fn cancel_read(_: u32) -> u32;
      #[link_name = "[future-drop-writable-1]read-via-stream"]
      fn drop_writable(_: u32);
      #[link_name = "[future-drop-readable-1]read-via-stream"]
      fn drop_readable(_: u32);
      #[link_name = "[async-lower][future-read-1]read-via-stream"]
      fn start_read(_: u32, _: *mut u8) -> u32;
      #[link_name = "[async-lower][future-write-1]read-via-stream"]
      fn start_write(_: u32, _: *const u8) -> u32;
    }

    unsafe fn lift(ptr: *mut u8) -> Result<(),super::super::wasi::cli::stdin::ErrorCode> { unsafe { let l0 = i32::from(*ptr.add(0).cast::<u8>());

    match l0 {
      0 => {
        let e = ();
        Ok(e)
      }
      1 => {
        let e = {
          let l1 = i32::from(*ptr.add(1).cast::<u8>());

          super::super::wasi::cli::types::ErrorCode::_lift(l1 as u8)
        };
        Err(e)
      }
      _ => super::super::_rt::invalid_enum_discriminant(),
    } } }
    unsafe fn lower(value: Result<(),super::super::wasi::cli::stdin::ErrorCode>, ptr: *mut u8) { unsafe { match value {
      Ok(_) => { {
        *ptr.add(0).cast::<u8>() = (0i32) as u8;
      } },
      Err(e) => { {
        *ptr.add(0).cast::<u8>() = (1i32) as u8;
        *ptr.add(1).cast::<u8>() = (e.clone() as i32) as u8;
      } },
    }; } }
    unsafe fn dealloc_lists(ptr: *mut u8) { unsafe {  } }

    pub static VTABLE: wit_bindgen::rt::async_support::FutureVtable<Result<(),super::super::wasi::cli::stdin::ErrorCode>> = wit_bindgen::rt::async_support::FutureVtable::<Result<(),super::super::wasi::cli::stdin::ErrorCode>> {
      cancel_write,
      cancel_read,
      drop_writable,
      drop_readable,
      dealloc_lists,
      layout: unsafe {
        ::std::alloc::Layout::from_size_align_unchecked(2, 1)
      },
      lift,
      lower,
      new,
      start_read,
      start_write,
    };

    impl super::FuturePayload for Result<(),super::super::wasi::cli::stdin::ErrorCode> {
      const VTABLE: &'static wit_bindgen::rt::async_support::FutureVtable<Self> = &VTABLE;
    }
  }
  
  #[doc(hidden)]
  #[allow(unused_unsafe)]
  pub mod vtable1 {

    #[cfg(not(target_arch = "wasm32"))]
    unsafe extern "C" fn cancel_write(_: u32) -> u32 { unreachable!() }
    #[cfg(not(target_arch = "wasm32"))]
    unsafe extern "C" fn cancel_read(_: u32) -> u32 { unreachable!() }
    #[cfg(not(target_arch = "wasm32"))]
    unsafe extern "C" fn drop_writable(_: u32) { unreachable!() }
    #[cfg(not(target_arch = "wasm32"))]
    unsafe extern "C" fn drop_readable(_: u32) { unreachable!() }
    #[cfg(not(target_arch = "wasm32"))]
    unsafe extern "C" fn new() -> u64 { unreachable!() }
    #[cfg(not(target_arch = "wasm32"))]
    unsafe extern "C" fn start_read(_: u32, _: *mut u8) -> u32 { unreachable!() }
    #[cfg(not(target_arch = "wasm32"))]
    unsafe extern "C" fn start_write(_: u32, _: *const u8) -> u32 { unreachable!() }

    #[cfg(target_arch = "wasm32")]
    #[link(wasm_import_module = "wasi:filesystem/types@0.3.0-rc-2026-01-06")]
    unsafe extern "C" {
      #[link_name = "[future-new-1][method]descriptor.read-via-stream"]
      fn new() -> u64;
      #[link_name = "[future-cancel-write-1][method]descriptor.read-via-stream"]
      fn cancel_write(_: u32) -> u32;
      #[link_name = "[future-cancel-read-1][method]descriptor.read-via-stream"]
      fn cancel_read(_: u32) -> u32;
      #[link_name = "[future-drop-writable-1][method]descriptor.read-via-stream"]
      fn drop_writable(_: u32);
      #[link_name = "[future-drop-readable-1][method]descriptor.read-via-stream"]
      fn drop_readable(_: u32);
      #[link_name = "[async-lower][future-read-1][method]descriptor.read-via-stream"]
      fn start_read(_: u32, _: *mut u8) -> u32;
      #[link_name = "[async-lower][future-write-1][method]descriptor.read-via-stream"]
      fn start_write(_: u32, _: *const u8) -> u32;
    }

    unsafe fn lift(ptr: *mut u8) -> Result<(),super::super::wasi::filesystem::types::ErrorCode> { unsafe { let l0 = i32::from(*ptr.add(0).cast::<u8>());

    match l0 {
      0 => {
        let e = ();
        Ok(e)
      }
      1 => {
        let e = {
          let l1 = i32::from(*ptr.add(1).cast::<u8>());

          super::super::wasi::filesystem::types::ErrorCode::_lift(l1 as u8)
        };
        Err(e)
      }
      _ => super::super::_rt::invalid_enum_discriminant(),
    } } }
    unsafe fn lower(value: Result<(),super::super::wasi::filesystem::types::ErrorCode>, ptr: *mut u8) { unsafe { match value {
      Ok(_) => { {
        *ptr.add(0).cast::<u8>() = (0i32) as u8;
      } },
      Err(e) => { {
        *ptr.add(0).cast::<u8>() = (1i32) as u8;
        *ptr.add(1).cast::<u8>() = (e.clone() as i32) as u8;
      } },
    }; } }
    unsafe fn dealloc_lists(ptr: *mut u8) { unsafe {  } }

    pub static VTABLE: wit_bindgen::rt::async_support::FutureVtable<Result<(),super::super::wasi::filesystem::types::ErrorCode>> = wit_bindgen::rt::async_support::FutureVtable::<Result<(),super::super::wasi::filesystem::types::ErrorCode>> {
      cancel_write,
      cancel_read,
      drop_writable,
      drop_readable,
      dealloc_lists,
      layout: unsafe {
        ::std::alloc::Layout::from_size_align_unchecked(2, 1)
      },
      lift,
      lower,
      new,
      start_read,
      start_write,
    };

    impl super::FuturePayload for Result<(),super::super::wasi::filesystem::types::ErrorCode> {
      const VTABLE: &'static wit_bindgen::rt::async_support::FutureVtable<Self> = &VTABLE;
    }
  }
  
  #[doc(hidden)]
  #[allow(unused_unsafe)]
  pub mod vtable2 {

    #[cfg(not(target_arch = "wasm32"))]
    unsafe extern "C" fn cancel_write(_: u32) -> u32 { unreachable!() }
    #[cfg(not(target_arch = "wasm32"))]
    unsafe extern "C" fn cancel_read(_: u32) -> u32 { unreachable!() }
    #[cfg(not(target_arch = "wasm32"))]
    unsafe extern "C" fn drop_writable(_: u32) { unreachable!() }
    #[cfg(not(target_arch = "wasm32"))]
    unsafe extern "C" fn drop_readable(_: u32) { unreachable!() }
    #[cfg(not(target_arch = "wasm32"))]
    unsafe extern "C" fn new() -> u64 { unreachable!() }
    #[cfg(not(target_arch = "wasm32"))]
    unsafe extern "C" fn start_read(_: u32, _: *mut u8) -> u32 { unreachable!() }
    #[cfg(not(target_arch = "wasm32"))]
    unsafe extern "C" fn start_write(_: u32, _: *const u8) -> u32 { unreachable!() }

    #[cfg(target_arch = "wasm32")]
    #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2026-01-06")]
    unsafe extern "C" {
      #[link_name = "[future-new-1][method]tcp-socket.receive"]
      fn new() -> u64;
      #[link_name = "[future-cancel-write-1][method]tcp-socket.receive"]
      fn cancel_write(_: u32) -> u32;
      #[link_name = "[future-cancel-read-1][method]tcp-socket.receive"]
      fn cancel_read(_: u32) -> u32;
      #[link_name = "[future-drop-writable-1][method]tcp-socket.receive"]
      fn drop_writable(_: u32);
      #[link_name = "[future-drop-readable-1][method]tcp-socket.receive"]
      fn drop_readable(_: u32);
      #[link_name = "[async-lower][future-read-1][method]tcp-socket.receive"]
      fn start_read(_: u32, _: *mut u8) -> u32;
      #[link_name = "[async-lower][future-write-1][method]tcp-socket.receive"]
      fn start_write(_: u32, _: *const u8) -> u32;
    }

    unsafe fn lift(ptr: *mut u8) -> Result<(),super::super::wasi::sockets::types::ErrorCode> { unsafe { let l0 = i32::from(*ptr.add(0).cast::<u8>());

    match l0 {
      0 => {
        let e = ();
        Ok(e)
      }
      1 => {
        let e = {
          let l1 = i32::from(*ptr.add(1).cast::<u8>());

          super::super::wasi::sockets::types::ErrorCode::_lift(l1 as u8)
        };
        Err(e)
      }
      _ => super::super::_rt::invalid_enum_discriminant(),
    } } }
    unsafe fn lower(value: Result<(),super::super::wasi::sockets::types::ErrorCode>, ptr: *mut u8) { unsafe { match value {
      Ok(_) => { {
        *ptr.add(0).cast::<u8>() = (0i32) as u8;
      } },
      Err(e) => { {
        *ptr.add(0).cast::<u8>() = (1i32) as u8;
        *ptr.add(1).cast::<u8>() = (e.clone() as i32) as u8;
      } },
    }; } }
    unsafe fn dealloc_lists(ptr: *mut u8) { unsafe {  } }

    pub static VTABLE: wit_bindgen::rt::async_support::FutureVtable<Result<(),super::super::wasi::sockets::types::ErrorCode>> = wit_bindgen::rt::async_support::FutureVtable::<Result<(),super::super::wasi::sockets::types::ErrorCode>> {
      cancel_write,
      cancel_read,
      drop_writable,
      drop_readable,
      dealloc_lists,
      layout: unsafe {
        ::std::alloc::Layout::from_size_align_unchecked(2, 1)
      },
      lift,
      lower,
      new,
      start_read,
      start_write,
    };

    impl super::FuturePayload for Result<(),super::super::wasi::sockets::types::ErrorCode> {
      const VTABLE: &'static wit_bindgen::rt::async_support::FutureVtable<Self> = &VTABLE;
    }
  }
  /// Creates a new Component Model `future` with the specified payload type.
  ///
  /// The `default` function provided computes the default value to be sent in
  /// this future if no other value was otherwise sent.
  pub fn new<T: FuturePayload>(default: fn() -> T) -> (wit_bindgen::rt::async_support::FutureWriter<T>, wit_bindgen::rt::async_support::FutureReader<T>) {
    unsafe { wit_bindgen::rt::async_support::future_new::<T>(default, T::VTABLE) }
  }
}
pub mod wit_stream {
  #![allow(dead_code, unused_variables, clippy::all)]

  pub trait StreamPayload: Unpin + Sized + 'static {
    const VTABLE: &'static wit_bindgen::rt::async_support::StreamVtable<Self>;
  }
  #[doc(hidden)]
  #[allow(unused_unsafe)]
  pub mod vtable0 {

    #[cfg(not(target_arch = "wasm32"))]
    unsafe extern "C" fn cancel_write(_: u32) -> u32 { unreachable!() }
    #[cfg(not(target_arch = "wasm32"))]
    unsafe extern "C" fn cancel_read(_: u32) -> u32 { unreachable!() }
    #[cfg(not(target_arch = "wasm32"))]
    unsafe extern "C" fn drop_writable(_: u32) { unreachable!() }
    #[cfg(not(target_arch = "wasm32"))]
    unsafe extern "C" fn drop_readable(_: u32) { unreachable!() }
    #[cfg(not(target_arch = "wasm32"))]
    unsafe extern "C" fn new() -> u64 { unreachable!() }
    #[cfg(not(target_arch = "wasm32"))]
    unsafe extern "C" fn start_read(_: u32, _: *mut u8, _: usize) -> u32 { unreachable!() }
    #[cfg(not(target_arch = "wasm32"))]
    unsafe extern "C" fn start_write(_: u32, _: *const u8, _: usize) -> u32 { unreachable!() }

    #[cfg(target_arch = "wasm32")]
    #[link(wasm_import_module = "wasi:cli/stdin@0.3.0-rc-2026-01-06")]
    unsafe extern "C" {
      #[link_name = "[stream-new-0]read-via-stream"]
      fn new() -> u64;
      #[link_name = "[stream-cancel-write-0]read-via-stream"]
      fn cancel_write(_: u32) -> u32;
      #[link_name = "[stream-cancel-read-0]read-via-stream"]
      fn cancel_read(_: u32) -> u32;
      #[link_name = "[stream-drop-writable-0]read-via-stream"]
      fn drop_writable(_: u32);
      #[link_name = "[stream-drop-readable-0]read-via-stream"]
      fn drop_readable(_: u32);
      #[link_name = "[async-lower][stream-read-0]read-via-stream"]
      fn start_read(_: u32, _: *mut u8, _: usize) -> u32;
      #[link_name = "[async-lower][stream-write-0]read-via-stream"]
      fn start_write(_: u32, _: *const u8, _: usize) -> u32;
    }

    
    
    

    pub static VTABLE: wit_bindgen::rt::async_support::StreamVtable<u8> = wit_bindgen::rt::async_support::StreamVtable::<u8> {
      cancel_write,
      cancel_read,
      drop_writable,
      drop_readable,
      dealloc_lists: None,
      layout: unsafe {
        ::std::alloc::Layout::from_size_align_unchecked(1, 1)
      },
      lift: None,
      lower: None,
      new,
      start_read,
      start_write,
    };

    impl super::StreamPayload for u8 {
      const VTABLE: &'static wit_bindgen::rt::async_support::StreamVtable<Self> = &VTABLE;
    }
  }
  
  #[doc(hidden)]
  #[allow(unused_unsafe)]
  pub mod vtable1 {

    #[cfg(not(target_arch = "wasm32"))]
    unsafe extern "C" fn cancel_write(_: u32) -> u32 { unreachable!() }
    #[cfg(not(target_arch = "wasm32"))]
    unsafe extern "C" fn cancel_read(_: u32) -> u32 { unreachable!() }
    #[cfg(not(target_arch = "wasm32"))]
    unsafe extern "C" fn drop_writable(_: u32) { unreachable!() }
    #[cfg(not(target_arch = "wasm32"))]
    unsafe extern "C" fn drop_readable(_: u32) { unreachable!() }
    #[cfg(not(target_arch = "wasm32"))]
    unsafe extern "C" fn new() -> u64 { unreachable!() }
    #[cfg(not(target_arch = "wasm32"))]
    unsafe extern "C" fn start_read(_: u32, _: *mut u8, _: usize) -> u32 { unreachable!() }
    #[cfg(not(target_arch = "wasm32"))]
    unsafe extern "C" fn start_write(_: u32, _: *const u8, _: usize) -> u32 { unreachable!() }

    #[cfg(target_arch = "wasm32")]
    #[link(wasm_import_module = "wasi:filesystem/types@0.3.0-rc-2026-01-06")]
    unsafe extern "C" {
      #[link_name = "[stream-new-0][method]descriptor.read-directory"]
      fn new() -> u64;
      #[link_name = "[stream-cancel-write-0][method]descriptor.read-directory"]
      fn cancel_write(_: u32) -> u32;
      #[link_name = "[stream-cancel-read-0][method]descriptor.read-directory"]
      fn cancel_read(_: u32) -> u32;
      #[link_name = "[stream-drop-writable-0][method]descriptor.read-directory"]
      fn drop_writable(_: u32);
      #[link_name = "[stream-drop-readable-0][method]descriptor.read-directory"]
      fn drop_readable(_: u32);
      #[link_name = "[async-lower][stream-read-0][method]descriptor.read-directory"]
      fn start_read(_: u32, _: *mut u8, _: usize) -> u32;
      #[link_name = "[async-lower][stream-write-0][method]descriptor.read-directory"]
      fn start_write(_: u32, _: *const u8, _: usize) -> u32;
    }

    unsafe fn lift(ptr: *mut u8) -> super::super::wasi::filesystem::types::DirectoryEntry { unsafe { let l0 = i32::from(*ptr.add(0).cast::<u8>());
    let l1 = *ptr.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
    let l2 = *ptr.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>();
    let len3 = l2;
    let bytes3 = super::super::_rt::Vec::from_raw_parts(l1.cast(), len3, len3);

    super::super::wasi::filesystem::types::DirectoryEntry{
      type_: super::super::wasi::filesystem::types::DescriptorType::_lift(l0 as u8),
      name: super::super::_rt::string_lift(bytes3),
    } } }
    unsafe fn lower(value: super::super::wasi::filesystem::types::DirectoryEntry, ptr: *mut u8) { unsafe { let super::super::wasi::filesystem::types::DirectoryEntry{ type_:type_0, name:name0, } = value;
    *ptr.add(0).cast::<u8>() = (type_0.clone() as i32) as u8;
    let vec1 = (name0.into_bytes()).into_boxed_slice();
    let ptr1 = vec1.as_ptr().cast::<u8>();
    let len1 = vec1.len();
    ::core::mem::forget(vec1);
    *ptr.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>() = len1;
    *ptr.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr1.cast_mut();
  } }
  unsafe fn dealloc_lists(ptr: *mut u8) { unsafe { let l0 = *ptr.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
  let l1 = *ptr.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>();
  super::super::_rt::cabi_dealloc(l0, l1, 1);
} }

pub static VTABLE: wit_bindgen::rt::async_support::StreamVtable<super::super::wasi::filesystem::types::DirectoryEntry> = wit_bindgen::rt::async_support::StreamVtable::<super::super::wasi::filesystem::types::DirectoryEntry> {
  cancel_write,
  cancel_read,
  drop_writable,
  drop_readable,
  dealloc_lists: Some(dealloc_lists),
  layout: unsafe {
    ::std::alloc::Layout::from_size_align_unchecked(12, 4)
  },
  lift: Some(lift),
  lower: Some(lower),
  new,
  start_read,
  start_write,
};

impl super::StreamPayload for super::super::wasi::filesystem::types::DirectoryEntry {
  const VTABLE: &'static wit_bindgen::rt::async_support::StreamVtable<Self> = &VTABLE;
}
}

#[doc(hidden)]
#[allow(unused_unsafe)]
pub mod vtable2 {

  #[cfg(not(target_arch = "wasm32"))]
  unsafe extern "C" fn cancel_write(_: u32) -> u32 { unreachable!() }
  #[cfg(not(target_arch = "wasm32"))]
  unsafe extern "C" fn cancel_read(_: u32) -> u32 { unreachable!() }
  #[cfg(not(target_arch = "wasm32"))]
  unsafe extern "C" fn drop_writable(_: u32) { unreachable!() }
  #[cfg(not(target_arch = "wasm32"))]
  unsafe extern "C" fn drop_readable(_: u32) { unreachable!() }
  #[cfg(not(target_arch = "wasm32"))]
  unsafe extern "C" fn new() -> u64 { unreachable!() }
  #[cfg(not(target_arch = "wasm32"))]
  unsafe extern "C" fn start_read(_: u32, _: *mut u8, _: usize) -> u32 { unreachable!() }
  #[cfg(not(target_arch = "wasm32"))]
  unsafe extern "C" fn start_write(_: u32, _: *const u8, _: usize) -> u32 { unreachable!() }

  #[cfg(target_arch = "wasm32")]
  #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2026-01-06")]
  unsafe extern "C" {
    #[link_name = "[stream-new-0][method]tcp-socket.listen"]
    fn new() -> u64;
    #[link_name = "[stream-cancel-write-0][method]tcp-socket.listen"]
    fn cancel_write(_: u32) -> u32;
    #[link_name = "[stream-cancel-read-0][method]tcp-socket.listen"]
    fn cancel_read(_: u32) -> u32;
    #[link_name = "[stream-drop-writable-0][method]tcp-socket.listen"]
    fn drop_writable(_: u32);
    #[link_name = "[stream-drop-readable-0][method]tcp-socket.listen"]
    fn drop_readable(_: u32);
    #[link_name = "[async-lower][stream-read-0][method]tcp-socket.listen"]
    fn start_read(_: u32, _: *mut u8, _: usize) -> u32;
    #[link_name = "[async-lower][stream-write-0][method]tcp-socket.listen"]
    fn start_write(_: u32, _: *const u8, _: usize) -> u32;
  }

  unsafe fn lift(ptr: *mut u8) -> super::super::wasi::sockets::types::TcpSocket { unsafe { let l0 = *ptr.add(0).cast::<i32>();

  super::super::wasi::sockets::types::TcpSocket::from_handle(l0 as u32) } }
  unsafe fn lower(value: super::super::wasi::sockets::types::TcpSocket, ptr: *mut u8) { unsafe { *ptr.add(0).cast::<i32>() = (value).take_handle() as i32;
} }
unsafe fn dealloc_lists(ptr: *mut u8) { unsafe {  } }

pub static VTABLE: wit_bindgen::rt::async_support::StreamVtable<super::super::wasi::sockets::types::TcpSocket> = wit_bindgen::rt::async_support::StreamVtable::<super::super::wasi::sockets::types::TcpSocket> {
  cancel_write,
  cancel_read,
  drop_writable,
  drop_readable,
  dealloc_lists: Some(dealloc_lists),
  layout: unsafe {
    ::std::alloc::Layout::from_size_align_unchecked(4, 4)
  },
  lift: Some(lift),
  lower: Some(lower),
  new,
  start_read,
  start_write,
};

impl super::StreamPayload for super::super::wasi::sockets::types::TcpSocket {
  const VTABLE: &'static wit_bindgen::rt::async_support::StreamVtable<Self> = &VTABLE;
}
}
/// Creates a new Component Model `stream` with the specified payload type.
pub fn new<T: StreamPayload>() -> (wit_bindgen::rt::async_support::StreamWriter<T>, wit_bindgen::rt::async_support::StreamReader<T>) {
  unsafe { wit_bindgen::rt::async_support::stream_new::<T>(T::VTABLE) }
}
}

/// Generates `#[unsafe(no_mangle)]` functions to export the specified type as
/// the root implementation of all generated traits.
///
/// For more information see the documentation of `wit_bindgen::generate!`.
///
/// ```rust
/// # macro_rules! export{ ($($t:tt)*) => (); }
/// # trait Guest {}
/// struct MyType;
///
/// impl Guest for MyType {
///     // ...
/// }
///
/// export!(MyType);
/// ```
#[allow(unused_macros)]
#[doc(hidden)]

macro_rules! __export_extension_sp_impl {
  ($ty:ident) => (self::export!($ty with_types_in self););
  ($ty:ident with_types_in $($path_to_types_root:tt)*) => (
  $($path_to_types_root)*::exports::igloo::lib::core_to_extension_sp::__export_igloo_lib_core_to_extension_sp_0_1_0_cabi!($ty with_types_in $($path_to_types_root)*::exports::igloo::lib::core_to_extension_sp);
  $($path_to_types_root)*::exports::wasi::cli::run::__export_wasi_cli_run_0_3_0_rc_2026_01_06_cabi!($ty with_types_in $($path_to_types_root)*::exports::wasi::cli::run);
  )
}
#[doc(inline)]
pub(crate) use __export_extension_sp_impl as export;

#[cfg(target_arch = "wasm32")]
#[unsafe(link_section = "component-type:wit-bindgen:0.52.0:igloo:lib@0.1.0:extension-sp:encoded world")]
#[doc(hidden)]
#[allow(clippy::octal_escapes)]
pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 13635] = *b"\
\0asm\x0d\0\x01\0\0\x19\x16wit-component-encoding\x04\0\x07\xc0i\x01A\x02\x01AG\x01\
B\x0c\x01r\x01\x06packedw\x04\0\x09device-id\x03\0\0\x01r\x01\x06packedw\x04\0\x08\
group-id\x03\0\x02\x01r\x01\x05inners\x04\0\x0cextension-id\x03\0\x04\x01r\x01\x05\
innerw\x04\0\x0fextension-index\x03\0\x06\x01r\x01\x05inners\x04\0\x09entity-id\x03\
\0\x08\x01r\x01\x05innerw\x04\0\x0centity-index\x03\0\x0a\x03\0\x12igloo:lib/id@\
0.1.0\x05\0\x01B\x06\x01r\x03\x01ru\x01gu\x01bu\x04\0\x0bigloo-color\x03\0\0\x01\
r\x03\x04year{\x05month}\x03day}\x04\0\x0aigloo-date\x03\0\x02\x01r\x03\x04hour}\
\x06minute}\x06second}\x04\0\x0aigloo-time\x03\0\x04\x03\0\x18igloo:lib/compound\
@0.1.0\x05\x01\x02\x03\0\x01\x0bigloo-color\x02\x03\0\x01\x0aigloo-date\x02\x03\0\
\x01\x0aigloo-time\x01B]\x02\x03\x02\x01\x02\x04\0\x0bigloo-color\x03\0\0\x02\x03\
\x02\x01\x03\x04\0\x0aigloo-date\x03\0\x02\x02\x03\x02\x01\x04\x04\0\x0aigloo-ti\
me\x03\0\x04\x01m\x07\x06sunday\x06monday\x07tuesday\x09wednesday\x08thursday\x06\
friday\x08saturday\x04\0\x07weekday\x03\0\x06\x01m\x02\x05r-g-b\x0btemperature\x04\
\0\x0acolor-mode\x03\0\x08\x01m\x03\x0bmeasurement\x10total-increasing\x05total\x04\
\0\x12sensor-state-class\x03\0\x0a\x01m\x01\x0cvolt-amperes\x04\0\x13unit-appare\
nt-power\x03\0\x0c\x01m\x03\x05watts\x0akilo-watts\x0dbtus-per-hour\x04\0\x0auni\
t-power\x03\0\x0e\x01m\x01\x14volt-ampere-reactive\x04\0\x13unit-reactive-power\x03\
\0\x10\x01m\x03\x0awatt-hours\x0fkilo-watt-hours\x0fmega-watt-hours\x04\0\x0buni\
t-energy\x03\0\x12\x01m\x02\x0cmilliamperes\x07amperes\x04\0\x15unit-electric-cu\
rrent\x03\0\x14\x01m\x02\x0amillivolts\x05volts\x04\0\x17unit-electric-potential\
\x03\0\x16\x01m\x01\x07degrees\x04\0\x0bunit-degree\x03\0\x18\x01m\x03\x05euros\x07\
dollars\x05cents\x04\0\x0dunit-currency\x03\0\x1a\x01m\x03\x07celsius\x0afahrenh\
eit\x06kelvin\x04\0\x10unit-temperature\x03\0\x1c\x01m\x09\x0cmicroseconds\x0cmi\
lliseconds\x07seconds\x07minutes\x05hours\x04days\x05weeks\x06months\x05years\x04\
\0\x09unit-time\x03\0\x1e\x01m\x08\x0bmillimeters\x0bcentimeters\x06meters\x0aki\
lometers\x06inches\x04feet\x04yard\x05miles\x04\0\x0bunit-length\x03\0\x20\x01m\x04\
\x05hertz\x09kilohertz\x09megahertz\x09gigahertz\x04\0\x0eunit-frequency\x03\0\"\
\x01m\x09\x06pascal\x0bhectopascal\x0akilopascal\x03bar\x08centibar\x08millibar\x12\
millimeter-mercury\x0cinch-mercury\x03psi\x04\0\x0dunit-pressure\x03\0$\x01m\x03\
\x07decibel\x12decibel-a-weighted\x12decibels-milliwatt\x04\0\x13unit-sound-pres\
sure\x03\0&\x01m\x06\x06liters\x0bmilliliters\x0ccubic-meters\x0acubic-feet\x07g\
allons\x0bfluid-ounce\x04\0\x0bunit-volume\x03\0(\x01m\x02\x15cubic-meters-per-h\
our\x15cubic-feet-per-minute\x04\0\x15unit-volume-flow-rate\x03\0*\x01m\x01\x0ds\
quare-meters\x04\0\x09unit-area\x03\0,\x01m\x06\x05grams\x09kilograms\x0amilligr\
ams\x0amicrograms\x06ounces\x06pounds\x04\0\x09unit-mass\x03\0.\x01m\x01\x1bmicr\
osiemens-per-centimeter\x04\0\x11unit-conductivity\x03\00\x01m\x01\x03lux\x04\0\x0a\
unit-light\x03\02\x01m\x01\x08uv-index\x04\0\x0dunit-uv-index\x03\04\x01m\x01\x0a\
percentage\x04\0\x0funit-percentage\x03\06\x01m\x02\x16watts-per-square-meter\x19\
btus-per-hour-square-foot\x04\0\x10unit-irradiation\x03\08\x01m\x06\x1amicrogram\
s-per-cubic-meter\x1amilligrams-per-cubic-meter\x19micrograms-per-cubic-foot\x15\
parts-per-cubic-meter\x11parts-per-million\x11parts-per-billion\x04\0\x12unit-co\
ncentration\x03\0:\x01m\x09\x13millimeters-per-day\x14millimeters-per-hour\x0ffe\
et-per-second\x0einches-per-day\x11meters-per-second\x0finches-per-hour\x13kilom\
eters-per-hour\x05knots\x0emiles-per-hour\x04\0\x0aunit-speed\x03\0<\x01m\x15\x04\
bits\x08kilobits\x08megabits\x08gigabits\x05bytes\x09kilobytes\x09megabytes\x09g\
igabytes\x09terabytes\x09petabytes\x08exabytes\x0azettabytes\x0ayottabytes\x09ki\
bibytes\x09mebibytes\x09gibibytes\x09tebibytes\x09pebibytes\x09exbibytes\x09zebi\
bytes\x09yobibytes\x04\0\x09unit-data\x03\0>\x01m\x0b\x0fbits-per-second\x13kilo\
bits-per-second\x13megabits-per-second\x13gigabits-per-second\x10bytes-per-secon\
d\x14kilobytes-per-second\x14megabytes-per-second\x14gigabytes-per-second\x14kib\
ibytes-per-second\x14mebibytes-per-second\x14gibibytes-per-second\x04\0\x0eunit-\
data-rate\x03\0@\x01m\x05\x03off\x02on\x08vertical\x0ahorizontal\x04both\x04\0\x0f\
fan-oscillation\x03\0B\x01m\x02\x07forward\x07reverse\x04\0\x0dfan-direction\x03\
\0D\x01m\x0a\x02on\x03off\x04auto\x03low\x06medium\x04high\x06middle\x05focus\x07\
diffuse\x05quiet\x04\0\x09fan-speed\x03\0F\x01m\x08\x03off\x04auto\x04heat\x04co\
ol\x09heat-cool\x08fan-only\x03dry\x03eco\x04\0\x0cclimate-mode\x03\0H\x01m\x06\x07\
unknown\x06locked\x08unlocked\x06jammed\x07locking\x09unlocking\x04\0\x0alock-st\
ate\x03\0J\x01m\x04\x07unknown\x04idle\x07playing\x06paused\x04\0\x0bmedia-state\
\x03\0L\x01m\x06\x04idle\x07opening\x07closing\x07stopped\x04open\x06closed\x04\0\
\x0bcover-state\x03\0N\x01m\x03\x04idle\x07opening\x07closing\x04\0\x0bvalve-sta\
te\x03\0P\x01m\x0a\x08disarmed\x0aarmed-home\x0aarmed-away\x0barmed-night\x0earm\
ed-vacation\x0darmed-unknown\x07pending\x09triggered\x06arming\x09disarming\x04\0\
\x0balarm-state\x03\0R\x01px\x01pu\x01ps\x01p\x7f\x01p\x01\x01p\x03\x01p\x05\x01\
qJ\x07integer\x01x\0\x05float\x01u\0\x06string\x01s\0\x04bool\x01\x7f\0\x05color\
\x01\x01\0\x04date\x01\x03\0\x04time\x01\x05\0\x0cinteger-list\x01\xd4\0\0\x0afl\
oat-list\x01\xd5\0\0\x0bstring-list\x01\xd6\0\0\x0cboolean-list\x01\xd7\0\0\x0ac\
olor-list\x01\xd8\0\0\x09date-list\x01\xd9\0\0\x09time-list\x01\xda\0\0\x07trigg\
er\0\0\x09timestamp\x01x\0\x08duration\x01x\0\x07weekday\x01\x07\0\x05light\0\0\x06\
switch\x01\x7f\0\x06dimmer\x01u\0\x06switch\x01\x7f\0\x0acolor-mode\x01\x09\0\x11\
color-temperature\x01x\0\x06volume\x01u\0\x05muted\x01\x7f\0\x06config\0\0\x0adi\
agnostic\0\0\x05siren\0\0\x06sensor\0\0\x04icon\x01s\0\x11accuracy-decimals\x01x\
\0\x0cdevice-class\x01s\0\x12sensor-state-class\x01\x0b\0\x13unit-apparent-power\
\x01\x0d\0\x0aunit-power\x01\x0f\0\x13unit-reactive-power\x01\x11\0\x0bunit-ener\
gy\x01\x13\0\x15unit-electric-current\x01\x15\0\x17unit-electric-potential\x01\x17\
\0\x0bunit-degree\x01\x19\0\x0dunit-currency\x01\x1b\0\x10unit-temperature\x01\x1d\
\0\x09unit-time\x01\x1f\0\x0bunit-length\x01!\0\x0eunit-frequency\x01#\0\x0dunit\
-pressure\x01%\0\x13unit-sound-pressure\x01'\0\x0bunit-volume\x01)\0\x15unit-vol\
ume-flow-rate\x01+\0\x09unit-area\x01-\0\x09unit-mass\x01/\0\x11unit-conductivit\
y\x011\0\x0aunit-light\x013\0\x0dunit-uv-index\x015\0\x0funit-percentage\x017\0\x10\
unit-irradiation\x019\0\x12unit-concentration\x01;\0\x0aunit-speed\x01=\0\x09uni\
t-data\x01?\0\x0eunit-data-rate\x01\xc1\0\0\x0ffan-oscillation\x01\xc3\0\0\x0dfa\
n-direction\x01\xc5\0\0\x09fan-speed\x01\xc7\0\0\x0cclimate-mode\x01\xc9\0\0\x0a\
lock-state\x01\xcb\0\0\x0bmedia-state\x01\xcd\0\0\x05cover\0\0\x0bcover-state\x01\
\xcf\0\0\x08position\x01u\0\x04tilt\x01u\0\x05valve\0\0\x0bvalve-state\x01\xd1\0\
\0\x0balarm-state\x01\xd3\0\0\x04\0\x09component\x03\0[\x03\0\x19igloo:lib/compo\
nent@0.1.0\x05\x05\x02\x03\0\0\x09entity-id\x02\x03\0\0\x0centity-index\x02\x03\0\
\x02\x09component\x01B\x11\x02\x03\x02\x01\x06\x04\0\x09entity-id\x03\0\0\x02\x03\
\x02\x01\x07\x04\0\x0centity-index\x03\0\x02\x02\x03\x02\x01\x08\x04\0\x09compon\
ent\x03\0\x04\x01m\x01\x0einvalid-entity\x04\0\x0centity-error\x03\0\x06\x04\0\x06\
entity\x03\x01\x01h\x08\x01@\x01\x04self\x09\0\x01\x04\0\x11[method]entity.id\x01\
\x0a\x01@\x01\x04self\x09\0\x03\x04\0\x14[method]entity.index\x01\x0b\x01j\0\x01\
\x07\x01C\x02\x04self\x09\x09component\x05\0\x0c\x04\0\x1c[method]entity.put-com\
ponent\x01\x0d\x03\0\x16igloo:lib/entity@0.1.0\x05\x09\x02\x03\0\0\x09device-id\x02\
\x03\0\x03\x06entity\x01B(\x02\x03\x02\x01\x0a\x04\0\x09device-id\x03\0\0\x02\x03\
\x02\x01\x06\x04\0\x09entity-id\x03\0\x02\x02\x03\x02\x01\x08\x04\0\x09component\
\x03\0\x04\x02\x03\x02\x01\x0b\x04\0\x06entity\x03\0\x06\x01m\x01\x0einvalid-dev\
ice\x04\0\x0cdevice-error\x03\0\x08\x04\0\x06device\x03\x01\x01i\x0a\x01@\x01\x04\
names\0\x0b\x04\0\x13[constructor]device\x01\x0c\x01h\x0a\x01j\x01\x01\x01\x09\x01\
@\x01\x04self\x0d\0\x0e\x04\0\x11[method]device.id\x01\x0f\x01ks\x01j\x01\x10\x01\
\x09\x01C\x02\x04self\x0d\x03keys\0\x11\x04\0\x16[method]device.get-cfg\x01\x12\x01\
j\0\x01\x09\x01C\x03\x04self\x0d\x03keys\x05values\0\x13\x04\0\x17[method]device\
.save-cfg\x01\x14\x01C\x02\x04self\x0d\x03keys\0\x13\x04\0\x19[method]device.rem\
ove-cfg\x01\x15\x01i\x07\x01j\x01\x16\x01\x09\x01C\x02\x04self\x0d\x02id\x03\0\x17\
\x04\0\x1e[method]device.register-entity\x01\x18\x01p\x0b\x01@\0\0\x19\x04\0\x0b\
get-devices\x01\x1a\x01C\x01\x03keys\0\x10\x04\0\x07get-cfg\x01\x1b\x01C\x02\x03\
keys\x05values\x01\0\x04\0\x08save-cfg\x01\x1c\x01C\x01\x03keys\x01\0\x04\0\x0ar\
emove-cfg\x01\x1d\x03\0%igloo:lib/extension-sp-to-igloo@0.1.0\x05\x0c\x01B\x0a\x01\
o\x02ss\x01p\0\x01@\0\0\x01\x04\0\x0fget-environment\x01\x02\x01ps\x01@\0\0\x03\x04\
\0\x0dget-arguments\x01\x04\x01ks\x01@\0\0\x05\x04\0\x0fget-initial-cwd\x01\x06\x03\
\0(wasi:cli/environment@0.3.0-rc-2026-01-06\x05\x0d\x01B\x03\x01j\0\0\x01@\x01\x06\
status\0\x01\0\x04\0\x04exit\x01\x01\x03\0!wasi:cli/exit@0.3.0-rc-2026-01-06\x05\
\x0e\x01B\x02\x01m\x03\x02io\x15illegal-byte-sequence\x04pipe\x04\0\x0aerror-cod\
e\x03\0\0\x03\0\"wasi:cli/types@0.3.0-rc-2026-01-06\x05\x0f\x02\x03\0\x07\x0aerr\
or-code\x01B\x08\x02\x03\x02\x01\x10\x04\0\x0aerror-code\x03\0\0\x01f\x01}\x01j\0\
\x01\x01\x01e\x01\x03\x01o\x02\x02\x04\x01@\0\0\x05\x04\0\x0fread-via-stream\x01\
\x06\x03\0\"wasi:cli/stdin@0.3.0-rc-2026-01-06\x05\x11\x01B\x06\x02\x03\x02\x01\x10\
\x04\0\x0aerror-code\x03\0\0\x01f\x01}\x01j\0\x01\x01\x01C\x01\x04data\x02\0\x03\
\x04\0\x10write-via-stream\x01\x04\x03\0#wasi:cli/stdout@0.3.0-rc-2026-01-06\x05\
\x12\x01B\x06\x02\x03\x02\x01\x10\x04\0\x0aerror-code\x03\0\0\x01f\x01}\x01j\0\x01\
\x01\x01C\x01\x04data\x02\0\x03\x04\0\x10write-via-stream\x01\x04\x03\0#wasi:cli\
/stderr@0.3.0-rc-2026-01-06\x05\x13\x01B\x01\x04\0\x0eterminal-input\x03\x01\x03\
\0+wasi:cli/terminal-input@0.3.0-rc-2026-01-06\x05\x14\x01B\x01\x04\0\x0ftermina\
l-output\x03\x01\x03\0,wasi:cli/terminal-output@0.3.0-rc-2026-01-06\x05\x15\x02\x03\
\0\x0b\x0eterminal-input\x01B\x06\x02\x03\x02\x01\x16\x04\0\x0eterminal-input\x03\
\0\0\x01i\x01\x01k\x02\x01@\0\0\x03\x04\0\x12get-terminal-stdin\x01\x04\x03\0+wa\
si:cli/terminal-stdin@0.3.0-rc-2026-01-06\x05\x17\x02\x03\0\x0c\x0fterminal-outp\
ut\x01B\x06\x02\x03\x02\x01\x18\x04\0\x0fterminal-output\x03\0\0\x01i\x01\x01k\x02\
\x01@\0\0\x03\x04\0\x13get-terminal-stdout\x01\x04\x03\0,wasi:cli/terminal-stdou\
t@0.3.0-rc-2026-01-06\x05\x19\x01B\x06\x02\x03\x02\x01\x18\x04\0\x0fterminal-out\
put\x03\0\0\x01i\x01\x01k\x02\x01@\0\0\x03\x04\0\x13get-terminal-stderr\x01\x04\x03\
\0,wasi:cli/terminal-stderr@0.3.0-rc-2026-01-06\x05\x1a\x01B\x02\x01w\x04\0\x08d\
uration\x03\0\0\x03\0%wasi:clocks/types@0.3.0-rc-2026-01-06\x05\x1b\x02\x03\0\x10\
\x08duration\x01B\x0c\x02\x03\x02\x01\x1c\x04\0\x08duration\x03\0\0\x01w\x04\0\x04\
mark\x03\0\x02\x01@\0\0\x03\x04\0\x03now\x01\x04\x01@\0\0\x01\x04\0\x0eget-resol\
ution\x01\x05\x01C\x01\x04when\x03\x01\0\x04\0\x0await-until\x01\x06\x01C\x01\x08\
how-long\x01\x01\0\x04\0\x08wait-for\x01\x07\x03\0/wasi:clocks/monotonic-clock@0\
.3.0-rc-2026-01-06\x05\x1d\x01B\x08\x02\x03\x02\x01\x1c\x04\0\x08duration\x03\0\0\
\x01r\x02\x07secondsx\x0bnanosecondsy\x04\0\x07instant\x03\0\x02\x01@\0\0\x03\x04\
\0\x03now\x01\x04\x01@\0\0\x01\x04\0\x0eget-resolution\x01\x05\x03\0,wasi:clocks\
/system-clock@0.3.0-rc-2026-01-06\x05\x1e\x02\x03\0\x12\x07instant\x01BY\x02\x03\
\x02\x01\x1f\x04\0\x07instant\x03\0\0\x01w\x04\0\x08filesize\x03\0\x02\x01m\x08\x07\
unknown\x0cblock-device\x10character-device\x09directory\x04fifo\x0dsymbolic-lin\
k\x0cregular-file\x06socket\x04\0\x0fdescriptor-type\x03\0\x04\x01n\x06\x04read\x05\
write\x13file-integrity-sync\x13data-integrity-sync\x14requested-write-sync\x10m\
utate-directory\x04\0\x10descriptor-flags\x03\0\x06\x01n\x01\x0esymlink-follow\x04\
\0\x0apath-flags\x03\0\x08\x01n\x04\x06create\x09directory\x09exclusive\x08trunc\
ate\x04\0\x0aopen-flags\x03\0\x0a\x01w\x04\0\x0alink-count\x03\0\x0c\x01k\x01\x01\
r\x06\x04type\x05\x0alink-count\x0d\x04size\x03\x15data-access-timestamp\x0e\x1b\
data-modification-timestamp\x0e\x17status-change-timestamp\x0e\x04\0\x0fdescript\
or-stat\x03\0\x0f\x01q\x03\x09no-change\0\0\x03now\0\0\x09timestamp\x01\x01\0\x04\
\0\x0dnew-timestamp\x03\0\x11\x01r\x02\x04type\x05\x04names\x04\0\x0fdirectory-e\
ntry\x03\0\x13\x01m$\x06access\x07already\x0ebad-descriptor\x04busy\x08deadlock\x05\
quota\x05exist\x0efile-too-large\x15illegal-byte-sequence\x0bin-progress\x0binte\
rrupted\x07invalid\x02io\x0cis-directory\x04loop\x0etoo-many-links\x0cmessage-si\
ze\x0dname-too-long\x09no-device\x08no-entry\x07no-lock\x13insufficient-memory\x12\
insufficient-space\x0dnot-directory\x09not-empty\x0fnot-recoverable\x0bunsupport\
ed\x06no-tty\x0eno-such-device\x08overflow\x0dnot-permitted\x04pipe\x09read-only\
\x0cinvalid-seek\x0etext-file-busy\x0ccross-device\x04\0\x0aerror-code\x03\0\x15\
\x01m\x06\x06normal\x0asequential\x06random\x09will-need\x09dont-need\x08no-reus\
e\x04\0\x06advice\x03\0\x17\x01r\x02\x05lowerw\x05upperw\x04\0\x13metadata-hash-\
value\x03\0\x19\x04\0\x0adescriptor\x03\x01\x01h\x1b\x01f\x01}\x01j\0\x01\x16\x01\
e\x01\x1e\x01o\x02\x1d\x1f\x01@\x02\x04self\x1c\x06offset\x03\0\x20\x04\0\"[meth\
od]descriptor.read-via-stream\x01!\x01C\x03\x04self\x1c\x04data\x1d\x06offset\x03\
\0\x1e\x04\0#[method]descriptor.write-via-stream\x01\"\x01C\x02\x04self\x1c\x04d\
ata\x1d\0\x1e\x04\0$[method]descriptor.append-via-stream\x01#\x01C\x04\x04self\x1c\
\x06offset\x03\x06length\x03\x06advice\x18\0\x1e\x04\0\x19[method]descriptor.adv\
ise\x01$\x01C\x01\x04self\x1c\0\x1e\x04\0\x1c[method]descriptor.sync-data\x01%\x01\
j\x01\x07\x01\x16\x01C\x01\x04self\x1c\0&\x04\0\x1c[method]descriptor.get-flags\x01\
'\x01j\x01\x05\x01\x16\x01C\x01\x04self\x1c\0(\x04\0\x1b[method]descriptor.get-t\
ype\x01)\x01C\x02\x04self\x1c\x04size\x03\0\x1e\x04\0\x1b[method]descriptor.set-\
size\x01*\x01C\x03\x04self\x1c\x15data-access-timestamp\x12\x1bdata-modification\
-timestamp\x12\0\x1e\x04\0\x1c[method]descriptor.set-times\x01+\x01f\x01\x14\x01\
o\x02,\x1f\x01C\x01\x04self\x1c\0-\x04\0![method]descriptor.read-directory\x01.\x04\
\0\x17[method]descriptor.sync\x01%\x01C\x02\x04self\x1c\x04paths\0\x1e\x04\0&[me\
thod]descriptor.create-directory-at\x01/\x01j\x01\x10\x01\x16\x01C\x01\x04self\x1c\
\00\x04\0\x17[method]descriptor.stat\x011\x01C\x03\x04self\x1c\x0apath-flags\x09\
\x04paths\00\x04\0\x1a[method]descriptor.stat-at\x012\x01C\x05\x04self\x1c\x0apa\
th-flags\x09\x04paths\x15data-access-timestamp\x12\x1bdata-modification-timestam\
p\x12\0\x1e\x04\0\x1f[method]descriptor.set-times-at\x013\x01C\x05\x04self\x1c\x0e\
old-path-flags\x09\x08old-paths\x0enew-descriptor\x1c\x08new-paths\0\x1e\x04\0\x1a\
[method]descriptor.link-at\x014\x01i\x1b\x01j\x015\x01\x16\x01C\x05\x04self\x1c\x0a\
path-flags\x09\x04paths\x0aopen-flags\x0b\x05flags\x07\06\x04\0\x1a[method]descr\
iptor.open-at\x017\x01j\x01s\x01\x16\x01C\x02\x04self\x1c\x04paths\08\x04\0\x1e[\
method]descriptor.readlink-at\x019\x04\0&[method]descriptor.remove-directory-at\x01\
/\x01C\x04\x04self\x1c\x08old-paths\x0enew-descriptor\x1c\x08new-paths\0\x1e\x04\
\0\x1c[method]descriptor.rename-at\x01:\x01C\x03\x04self\x1c\x08old-paths\x08new\
-paths\0\x1e\x04\0\x1d[method]descriptor.symlink-at\x01;\x04\0![method]descripto\
r.unlink-file-at\x01/\x01C\x02\x04self\x1c\x05other\x1c\0\x7f\x04\0![method]desc\
riptor.is-same-object\x01<\x01j\x01\x1a\x01\x16\x01C\x01\x04self\x1c\0=\x04\0\x20\
[method]descriptor.metadata-hash\x01>\x01C\x03\x04self\x1c\x0apath-flags\x09\x04\
paths\0=\x04\0#[method]descriptor.metadata-hash-at\x01?\x03\0)wasi:filesystem/ty\
pes@0.3.0-rc-2026-01-06\x05\x20\x02\x03\0\x13\x0adescriptor\x01B\x07\x02\x03\x02\
\x01!\x04\0\x0adescriptor\x03\0\0\x01i\x01\x01o\x02\x02s\x01p\x03\x01@\0\0\x04\x04\
\0\x0fget-directories\x01\x05\x03\0,wasi:filesystem/preopens@0.3.0-rc-2026-01-06\
\x05\"\x01Bq\x02\x03\x02\x01\x1c\x04\0\x08duration\x03\0\0\x01m\x0e\x07unknown\x0d\
access-denied\x0dnot-supported\x10invalid-argument\x0dout-of-memory\x07timeout\x0d\
invalid-state\x14address-not-bindable\x0eaddress-in-use\x12remote-unreachable\x12\
connection-refused\x10connection-reset\x12connection-aborted\x12datagram-too-lar\
ge\x04\0\x0aerror-code\x03\0\x02\x01m\x02\x04ipv4\x04ipv6\x04\0\x11ip-address-fa\
mily\x03\0\x04\x01o\x04}}}}\x04\0\x0cipv4-address\x03\0\x06\x01o\x08{{{{{{{{\x04\
\0\x0cipv6-address\x03\0\x08\x01q\x02\x04ipv4\x01\x07\0\x04ipv6\x01\x09\0\x04\0\x0a\
ip-address\x03\0\x0a\x01r\x02\x04port{\x07address\x07\x04\0\x13ipv4-socket-addre\
ss\x03\0\x0c\x01r\x04\x04port{\x09flow-infoy\x07address\x09\x08scope-idy\x04\0\x13\
ipv6-socket-address\x03\0\x0e\x01q\x02\x04ipv4\x01\x0d\0\x04ipv6\x01\x0f\0\x04\0\
\x11ip-socket-address\x03\0\x10\x04\0\x0atcp-socket\x03\x01\x04\0\x0audp-socket\x03\
\x01\x01i\x12\x01j\x01\x14\x01\x03\x01@\x01\x0eaddress-family\x05\0\x15\x04\0\x19\
[static]tcp-socket.create\x01\x16\x01h\x12\x01j\0\x01\x03\x01@\x02\x04self\x17\x0d\
local-address\x11\0\x18\x04\0\x17[method]tcp-socket.bind\x01\x19\x01C\x02\x04sel\
f\x17\x0eremote-address\x11\0\x18\x04\0\x1a[method]tcp-socket.connect\x01\x1a\x01\
f\x01\x14\x01j\x01\x1b\x01\x03\x01@\x01\x04self\x17\0\x1c\x04\0\x19[method]tcp-s\
ocket.listen\x01\x1d\x01f\x01}\x01C\x02\x04self\x17\x04data\x1e\0\x18\x04\0\x17[\
method]tcp-socket.send\x01\x1f\x01e\x01\x18\x01o\x02\x1e\x20\x01@\x01\x04self\x17\
\0!\x04\0\x1a[method]tcp-socket.receive\x01\"\x01j\x01\x11\x01\x03\x01@\x01\x04s\
elf\x17\0#\x04\0$[method]tcp-socket.get-local-address\x01$\x04\0%[method]tcp-soc\
ket.get-remote-address\x01$\x01@\x01\x04self\x17\0\x7f\x04\0#[method]tcp-socket.\
get-is-listening\x01%\x01@\x01\x04self\x17\0\x05\x04\0%[method]tcp-socket.get-ad\
dress-family\x01&\x01@\x02\x04self\x17\x05valuew\0\x18\x04\0*[method]tcp-socket.\
set-listen-backlog-size\x01'\x01j\x01\x7f\x01\x03\x01@\x01\x04self\x17\0(\x04\0)\
[method]tcp-socket.get-keep-alive-enabled\x01)\x01@\x02\x04self\x17\x05value\x7f\
\0\x18\x04\0)[method]tcp-socket.set-keep-alive-enabled\x01*\x01j\x01\x01\x01\x03\
\x01@\x01\x04self\x17\0+\x04\0+[method]tcp-socket.get-keep-alive-idle-time\x01,\x01\
@\x02\x04self\x17\x05value\x01\0\x18\x04\0+[method]tcp-socket.set-keep-alive-idl\
e-time\x01-\x04\0*[method]tcp-socket.get-keep-alive-interval\x01,\x04\0*[method]\
tcp-socket.set-keep-alive-interval\x01-\x01j\x01y\x01\x03\x01@\x01\x04self\x17\0\
.\x04\0'[method]tcp-socket.get-keep-alive-count\x01/\x01@\x02\x04self\x17\x05val\
uey\0\x18\x04\0'[method]tcp-socket.set-keep-alive-count\x010\x01j\x01}\x01\x03\x01\
@\x01\x04self\x17\01\x04\0\x20[method]tcp-socket.get-hop-limit\x012\x01@\x02\x04\
self\x17\x05value}\0\x18\x04\0\x20[method]tcp-socket.set-hop-limit\x013\x01j\x01\
w\x01\x03\x01@\x01\x04self\x17\04\x04\0*[method]tcp-socket.get-receive-buffer-si\
ze\x015\x04\0*[method]tcp-socket.set-receive-buffer-size\x01'\x04\0'[method]tcp-\
socket.get-send-buffer-size\x015\x04\0'[method]tcp-socket.set-send-buffer-size\x01\
'\x01i\x13\x01j\x016\x01\x03\x01@\x01\x0eaddress-family\x05\07\x04\0\x19[static]\
udp-socket.create\x018\x01h\x13\x01@\x02\x04self9\x0dlocal-address\x11\0\x18\x04\
\0\x17[method]udp-socket.bind\x01:\x01@\x02\x04self9\x0eremote-address\x11\0\x18\
\x04\0\x1a[method]udp-socket.connect\x01;\x01@\x01\x04self9\0\x18\x04\0\x1d[meth\
od]udp-socket.disconnect\x01<\x01p}\x01k\x11\x01C\x03\x04self9\x04data=\x0eremot\
e-address>\0\x18\x04\0\x17[method]udp-socket.send\x01?\x01o\x02=\x11\x01j\x01\xc0\
\0\x01\x03\x01C\x01\x04self9\0\xc1\0\x04\0\x1a[method]udp-socket.receive\x01B\x01\
@\x01\x04self9\0#\x04\0$[method]udp-socket.get-local-address\x01C\x04\0%[method]\
udp-socket.get-remote-address\x01C\x01@\x01\x04self9\0\x05\x04\0%[method]udp-soc\
ket.get-address-family\x01D\x01@\x01\x04self9\01\x04\0([method]udp-socket.get-un\
icast-hop-limit\x01E\x01@\x02\x04self9\x05value}\0\x18\x04\0([method]udp-socket.\
set-unicast-hop-limit\x01F\x01@\x01\x04self9\04\x04\0*[method]udp-socket.get-rec\
eive-buffer-size\x01G\x01@\x02\x04self9\x05valuew\0\x18\x04\0*[method]udp-socket\
.set-receive-buffer-size\x01H\x04\0'[method]udp-socket.get-send-buffer-size\x01G\
\x04\0'[method]udp-socket.set-send-buffer-size\x01H\x03\0&wasi:sockets/types@0.3\
.0-rc-2026-01-06\x05#\x02\x03\0\x15\x0aip-address\x01B\x08\x02\x03\x02\x01$\x04\0\
\x0aip-address\x03\0\0\x01m\x06\x07unknown\x0daccess-denied\x10invalid-argument\x11\
name-unresolvable\x1atemporary-resolver-failure\x1apermanent-resolver-failure\x04\
\0\x0aerror-code\x03\0\x02\x01p\x01\x01j\x01\x04\x01\x03\x01C\x01\x04names\0\x05\
\x04\0\x11resolve-addresses\x01\x06\x03\0/wasi:sockets/ip-name-lookup@0.3.0-rc-2\
026-01-06\x05%\x01B\x05\x01p}\x01@\x01\x03lenw\0\0\x04\0\x10get-random-bytes\x01\
\x01\x01@\0\0w\x04\0\x0eget-random-u64\x01\x02\x03\0&wasi:random/random@0.3.0-rc\
-2026-01-06\x05&\x01B\x05\x01p}\x01@\x01\x03lenw\0\0\x04\0\x19get-insecure-rando\
m-bytes\x01\x01\x01@\0\0w\x04\0\x17get-insecure-random-u64\x01\x02\x03\0(wasi:ra\
ndom/insecure@0.3.0-rc-2026-01-06\x05'\x01B\x03\x01o\x02ww\x01@\0\0\0\x04\0\x11g\
et-insecure-seed\x01\x01\x03\0-wasi:random/insecure-seed@0.3.0-rc-2026-01-06\x05\
(\x01B\x0d\x02\x03\x02\x01\x0a\x04\0\x09device-id\x03\0\0\x02\x03\x02\x01\x07\x04\
\0\x0centity-index\x03\0\x02\x02\x03\x02\x01\x08\x04\0\x09component\x03\0\x04\x01\
j\0\x01s\x01C\x03\x09device-id\x01\x0centity-index\x03\x09component\x05\0\x06\x04\
\0\x0dput-component\x01\x07\x01C\x01\x09device-id\x01\0\x06\x04\0\x0ddelete-devi\
ce\x01\x08\x01C\x02\x04names\x06paramss\0\x06\x04\0\x06custom\x01\x09\x04\0$iglo\
o:lib/core-to-extension-sp@0.1.0\x05)\x01B\x03\x01j\0\0\x01C\0\0\0\x04\0\x03run\x01\
\x01\x04\0\x20wasi:cli/run@0.3.0-rc-2026-01-06\x05*\x04\0\x1cigloo:lib/extension\
-sp@0.1.0\x04\0\x0b\x12\x01\0\x0cextension-sp\x03\0\0\0G\x09producers\x01\x0cpro\
cessed-by\x02\x0dwit-component\x070.244.0\x10wit-bindgen-rust\x060.52.0";

#[inline(never)]
#[doc(hidden)]
pub fn __link_custom_section_describing_imports() {
  wit_bindgen::rt::maybe_link_cabi_realloc();
}

