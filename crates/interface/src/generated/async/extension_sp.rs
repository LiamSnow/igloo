// Generated by `wit-bindgen` 0.52.0. DO NOT EDIT!
// Options used:
//   * additional derives ["PartialEq", "serde::Serialize", "serde::Deserialize"]
//   * with "igloo:lib/id@0.1.0" = "crate::generated::shared::igloo::lib::id"
//   * with "igloo:lib/compound@0.1.0" = "crate::generated::shared::igloo::lib::compound"
//   * with "igloo:lib/component@0.1.0" = "crate::generated::shared::igloo::lib::component"
//   * generate_unused_types
//   * async: all
#[allow(unfulfilled_lint_expectations, unused_imports)]
use crate::generated::shared::igloo::lib::id as __with_name0;
#[allow(unfulfilled_lint_expectations, unused_imports)]
use crate::generated::shared::igloo::lib::compound as __with_name1;
#[allow(unfulfilled_lint_expectations, unused_imports)]
use crate::generated::shared::igloo::lib::component as __with_name2;
#[allow(dead_code, clippy::all)]
pub mod igloo {
  pub mod lib {

    #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
    pub mod entity {
      #[used]
      #[doc(hidden)]
      static __FORCE_SECTION_REF: fn() =
      super::super::super::__link_custom_section_describing_imports;
      
      use super::super::super::_rt;
      pub type EntityId = super::super::super::__with_name0::EntityId;
      pub type EntityIndex = super::super::super::__with_name0::EntityIndex;
      pub type Component = super::super::super::__with_name2::Component;
      #[repr(u8)]
      #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd, serde::Deserialize, serde::Serialize)]
      pub enum EntityError {
        InvalidEntity,
      }
      impl EntityError{
        pub fn name(&self) -> &'static str {
          match self {
            EntityError::InvalidEntity => "invalid-entity",
          }
        }
        pub fn message(&self) -> &'static str {
          match self {
            EntityError::InvalidEntity => "",
          }
        }
      }
      impl ::core::fmt::Debug for EntityError{
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("EntityError")
          .field("code", &(*self as i32))
          .field("name", &self.name())
          .field("message", &self.message())
          .finish()
        }
      }
      impl ::core::fmt::Display for EntityError{
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          write!(f, "{} (error {})", self.name(), *self as i32)
        }
      }

      impl ::core::error::Error for EntityError {}

      impl EntityError{
        #[doc(hidden)]
        pub unsafe fn _lift(val: u8) -> EntityError{
          if !cfg!(debug_assertions) {
            return unsafe { ::core::mem::transmute(val) };
          }

          match val {
            0 => EntityError::InvalidEntity,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }


      #[derive(Debug)]
      #[repr(transparent)]
      pub struct Entity{
        handle: _rt::Resource<Entity>,
      }

      impl Entity{
        #[doc(hidden)]
        pub unsafe fn from_handle(handle: u32) -> Self {
          Self {
            handle: unsafe { _rt::Resource::from_handle(handle) },
          }
        }

        #[doc(hidden)]
        pub fn take_handle(&self) -> u32 {
          _rt::Resource::take_handle(&self.handle)
        }

        #[doc(hidden)]
        pub fn handle(&self) -> u32 {
          _rt::Resource::handle(&self.handle)
        }
      }
      

      unsafe impl _rt::WasmResource for Entity{
        #[inline]
        unsafe fn drop(_handle: u32) {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "igloo:lib/entity@0.1.0")]
          unsafe extern "C" {
            #[link_name = "[resource-drop]entity"]
            fn drop(_: i32, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn drop(_: i32, ) { unreachable!() }
          
          unsafe { drop(_handle as i32); }
        }
      }
      
      impl Entity {
        #[allow(unused_unsafe, clippy::all)]
        #[allow(async_fn_in_trait)]
        pub async fn id(&self,) -> EntityId{
          unsafe {

            #[derive(Copy, Clone)]
            struct ParamsLower(
            i32, 
            );
            unsafe impl Send for ParamsLower {}
            

            use wit_bindgen::rt::async_support::Subtask as _Subtask;
            struct _MySubtask<'a> { _unused: core::marker::PhantomData<&'a ()> }
            #[allow(unused_parens)]
            unsafe impl<'a> _Subtask for _MySubtask<'a> {
              
              type Params = (&'a Entity, );
              type Results = EntityId;
              type ParamsLower = ParamsLower;
              fn abi_layout(&mut self) -> ::core::alloc::Layout {
                unsafe {
                  ::core::alloc::Layout::from_size_align_unchecked((2*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>())
                }
              }
              
              fn results_offset(&mut self) -> usize { 0 }

              unsafe fn call_import(&mut self, _params: Self::ParamsLower, _results: *mut u8) -> u32 {
                
                #[cfg(target_arch = "wasm32")]
                #[link(wasm_import_module = "igloo:lib/entity@0.1.0")]
                unsafe extern "C" {
                  #[link_name = "[async-lower][method]entity.id"]
                  fn call(_: i32, _: *mut u8, ) -> i32;
                }

                #[cfg(not(target_arch = "wasm32"))]
                unsafe extern "C" fn call(_: i32, _: *mut u8, ) -> i32 { unreachable!() }
                
                unsafe { call(_params.0,_results) as u32 }
              }
              
              unsafe fn params_dealloc_lists(&mut self, _params: Self::ParamsLower) {
                unsafe {  }
              }
              unsafe fn params_dealloc_lists_and_own(&mut self, _params: Self::ParamsLower) {
                unsafe {  }
              }
              unsafe fn params_lower(&mut self, (_lower0,): Self::Params, _ptr: *mut u8) -> Self::ParamsLower {
                unsafe {  ParamsLower((_lower0).handle() as i32,) }
              }
              unsafe fn results_lift(&mut self, _ptr: *mut u8) -> Self::Results {
                unsafe { let l0 = *_ptr.add(0).cast::<*mut u8>();
                let l1 = *_ptr.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
                let len2 = l1;
                let bytes2 = _rt::Vec::from_raw_parts(l0.cast(), len2, len2);

                super::super::super::__with_name0::EntityId{
                  inner: _rt::string_lift(bytes2),
                } }
              }
            }
            _MySubtask { _unused: core::marker::PhantomData }.call((self,)).await
          }
        }
      }
      impl Entity {
        #[allow(unused_unsafe, clippy::all)]
        #[allow(async_fn_in_trait)]
        pub async fn index(&self,) -> EntityIndex{
          unsafe {

            #[derive(Copy, Clone)]
            struct ParamsLower(
            i32, 
            );
            unsafe impl Send for ParamsLower {}
            

            use wit_bindgen::rt::async_support::Subtask as _Subtask;
            struct _MySubtask<'a> { _unused: core::marker::PhantomData<&'a ()> }
            #[allow(unused_parens)]
            unsafe impl<'a> _Subtask for _MySubtask<'a> {
              
              type Params = (&'a Entity, );
              type Results = EntityIndex;
              type ParamsLower = ParamsLower;
              fn abi_layout(&mut self) -> ::core::alloc::Layout {
                unsafe {
                  ::core::alloc::Layout::from_size_align_unchecked(8, 8)
                }
              }
              
              fn results_offset(&mut self) -> usize { 0 }

              unsafe fn call_import(&mut self, _params: Self::ParamsLower, _results: *mut u8) -> u32 {
                
                #[cfg(target_arch = "wasm32")]
                #[link(wasm_import_module = "igloo:lib/entity@0.1.0")]
                unsafe extern "C" {
                  #[link_name = "[async-lower][method]entity.index"]
                  fn call(_: i32, _: *mut u8, ) -> i32;
                }

                #[cfg(not(target_arch = "wasm32"))]
                unsafe extern "C" fn call(_: i32, _: *mut u8, ) -> i32 { unreachable!() }
                
                unsafe { call(_params.0,_results) as u32 }
              }
              
              unsafe fn params_dealloc_lists(&mut self, _params: Self::ParamsLower) {
                unsafe {  }
              }
              unsafe fn params_dealloc_lists_and_own(&mut self, _params: Self::ParamsLower) {
                unsafe {  }
              }
              unsafe fn params_lower(&mut self, (_lower0,): Self::Params, _ptr: *mut u8) -> Self::ParamsLower {
                unsafe {  ParamsLower((_lower0).handle() as i32,) }
              }
              unsafe fn results_lift(&mut self, _ptr: *mut u8) -> Self::Results {
                unsafe { let l0 = *_ptr.add(0).cast::<i64>();

                super::super::super::__with_name0::EntityIndex{
                  inner: l0 as u64,
                } }
              }
            }
            _MySubtask { _unused: core::marker::PhantomData }.call((self,)).await
          }
        }
      }
      impl Entity {
        #[allow(unused_unsafe, clippy::all)]
        /// Will either put a component on the given entity
        /// or will set the value (if it already exists)
        ///
        /// Fails if this entity is invalid
        #[allow(async_fn_in_trait)]
        pub async fn put_component(&self,component: Component,) -> Result<(),EntityError>{
          unsafe {

            #[derive(Copy, Clone)]
            struct ParamsLower(
            *mut u8, 
            );
            unsafe impl Send for ParamsLower {}
            

            use wit_bindgen::rt::async_support::Subtask as _Subtask;
            struct _MySubtask<'a> { _unused: core::marker::PhantomData<&'a ()> }
            #[allow(unused_parens)]
            unsafe impl<'a> _Subtask for _MySubtask<'a> {
              
              type Params = (&'a Entity, Component, );
              type Results = Result<(),EntityError>;
              type ParamsLower = ParamsLower;
              fn abi_layout(&mut self) -> ::core::alloc::Layout {
                unsafe {
                  ::core::alloc::Layout::from_size_align_unchecked(48, 8)
                }
              }
              
              fn results_offset(&mut self) -> usize { 40 }

              unsafe fn call_import(&mut self, _params: Self::ParamsLower, _results: *mut u8) -> u32 {
                
                #[cfg(target_arch = "wasm32")]
                #[link(wasm_import_module = "igloo:lib/entity@0.1.0")]
                unsafe extern "C" {
                  #[link_name = "[async-lower][method]entity.put-component"]
                  fn call(_: *mut u8, _: *mut u8, ) -> i32;
                }

                #[cfg(not(target_arch = "wasm32"))]
                unsafe extern "C" fn call(_: *mut u8, _: *mut u8, ) -> i32 { unreachable!() }
                
                unsafe { call(_params.0,_results) as u32 }
              }
              
              unsafe fn params_dealloc_lists(&mut self, _params: Self::ParamsLower) {
                unsafe { let l0 = i32::from(*_params.0.add(8).cast::<u8>());
                match l0 {
                  0 => (),
                  1 => (),
                  2 => {
                    let l1 = *_params.0.add(16).cast::<*mut u8>();
                    let l2 = *_params.0.add(16+1*::core::mem::size_of::<*const u8>()).cast::<usize>();
                    _rt::cabi_dealloc(l1, l2, 1);
                  },
                  3 => (),
                  4 => (),
                  5 => (),
                  6 => (),
                  7 => {
                    let l3 = *_params.0.add(16).cast::<*mut u8>();
                    let l4 = *_params.0.add(16+1*::core::mem::size_of::<*const u8>()).cast::<usize>();
                    let base5 = l3;
                    let len5 = l4;
                    _rt::cabi_dealloc(base5, len5 * 8, 8);
                  },
                  8 => {
                    let l6 = *_params.0.add(16).cast::<*mut u8>();
                    let l7 = *_params.0.add(16+1*::core::mem::size_of::<*const u8>()).cast::<usize>();
                    let base8 = l6;
                    let len8 = l7;
                    _rt::cabi_dealloc(base8, len8 * 8, 8);
                  },
                  9 => {
                    let l9 = *_params.0.add(16).cast::<*mut u8>();
                    let l10 = *_params.0.add(16+1*::core::mem::size_of::<*const u8>()).cast::<usize>();
                    let base13 = l9;
                    let len13 = l10;
                    for i in 0..len13 {
                      let base = base13.add(i * (2*::core::mem::size_of::<*const u8>()));
                      {
                        let l11 = *base.add(0).cast::<*mut u8>();
                        let l12 = *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
                        _rt::cabi_dealloc(l11, l12, 1);
                      }
                    }
                    _rt::cabi_dealloc(base13, len13 * (2*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>());
                  },
                  10 => {
                    let l14 = *_params.0.add(16).cast::<*mut u8>();
                    let l15 = *_params.0.add(16+1*::core::mem::size_of::<*const u8>()).cast::<usize>();
                    let base16 = l14;
                    let len16 = l15;
                    _rt::cabi_dealloc(base16, len16 * 1, 1);
                  },
                  11 => {
                    let l17 = *_params.0.add(16).cast::<*mut u8>();
                    let l18 = *_params.0.add(16+1*::core::mem::size_of::<*const u8>()).cast::<usize>();
                    let base19 = l17;
                    let len19 = l18;
                    _rt::cabi_dealloc(base19, len19 * 24, 8);
                  },
                  12 => {
                    let l20 = *_params.0.add(16).cast::<*mut u8>();
                    let l21 = *_params.0.add(16+1*::core::mem::size_of::<*const u8>()).cast::<usize>();
                    let base22 = l20;
                    let len22 = l21;
                    _rt::cabi_dealloc(base22, len22 * 4, 2);
                  },
                  13 => {
                    let l23 = *_params.0.add(16).cast::<*mut u8>();
                    let l24 = *_params.0.add(16+1*::core::mem::size_of::<*const u8>()).cast::<usize>();
                    let base25 = l23;
                    let len25 = l24;
                    _rt::cabi_dealloc(base25, len25 * 3, 1);
                  },
                  14 => (),
                  15 => (),
                  16 => (),
                  17 => (),
                  18 => (),
                  19 => (),
                  20 => (),
                  21 => (),
                  22 => (),
                  23 => (),
                  24 => (),
                  25 => (),
                  26 => (),
                  27 => (),
                  28 => (),
                  29 => (),
                  30 => {
                    let l26 = *_params.0.add(16).cast::<*mut u8>();
                    let l27 = *_params.0.add(16+1*::core::mem::size_of::<*const u8>()).cast::<usize>();
                    _rt::cabi_dealloc(l26, l27, 1);
                  },
                  31 => (),
                  32 => {
                    let l28 = *_params.0.add(16).cast::<*mut u8>();
                    let l29 = *_params.0.add(16+1*::core::mem::size_of::<*const u8>()).cast::<usize>();
                    _rt::cabi_dealloc(l28, l29, 1);
                  },
                  33 => (),
                  34 => (),
                  35 => (),
                  36 => (),
                  37 => (),
                  38 => (),
                  39 => (),
                  40 => (),
                  41 => (),
                  42 => (),
                  43 => (),
                  44 => (),
                  45 => (),
                  46 => (),
                  47 => (),
                  48 => (),
                  49 => (),
                  50 => (),
                  51 => (),
                  52 => (),
                  53 => (),
                  54 => (),
                  55 => (),
                  56 => (),
                  57 => (),
                  58 => (),
                  59 => (),
                  60 => (),
                  61 => (),
                  62 => (),
                  63 => (),
                  64 => (),
                  65 => (),
                  66 => (),
                  67 => (),
                  68 => (),
                  69 => (),
                  70 => (),
                  71 => (),
                  72 => (),
                  _ => (),
                }
              }
            }
            unsafe fn params_dealloc_lists_and_own(&mut self, _params: Self::ParamsLower) {
              unsafe { let l0 = i32::from(*_params.0.add(8).cast::<u8>());
              match l0 {
                0 => (),
                1 => (),
                2 => {
                  let l1 = *_params.0.add(16).cast::<*mut u8>();
                  let l2 = *_params.0.add(16+1*::core::mem::size_of::<*const u8>()).cast::<usize>();
                  _rt::cabi_dealloc(l1, l2, 1);
                },
                3 => (),
                4 => (),
                5 => (),
                6 => (),
                7 => {
                  let l3 = *_params.0.add(16).cast::<*mut u8>();
                  let l4 = *_params.0.add(16+1*::core::mem::size_of::<*const u8>()).cast::<usize>();
                  let base5 = l3;
                  let len5 = l4;
                  _rt::cabi_dealloc(base5, len5 * 8, 8);
                },
                8 => {
                  let l6 = *_params.0.add(16).cast::<*mut u8>();
                  let l7 = *_params.0.add(16+1*::core::mem::size_of::<*const u8>()).cast::<usize>();
                  let base8 = l6;
                  let len8 = l7;
                  _rt::cabi_dealloc(base8, len8 * 8, 8);
                },
                9 => {
                  let l9 = *_params.0.add(16).cast::<*mut u8>();
                  let l10 = *_params.0.add(16+1*::core::mem::size_of::<*const u8>()).cast::<usize>();
                  let base13 = l9;
                  let len13 = l10;
                  for i in 0..len13 {
                    let base = base13.add(i * (2*::core::mem::size_of::<*const u8>()));
                    {
                      let l11 = *base.add(0).cast::<*mut u8>();
                      let l12 = *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
                      _rt::cabi_dealloc(l11, l12, 1);
                    }
                  }
                  _rt::cabi_dealloc(base13, len13 * (2*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>());
                },
                10 => {
                  let l14 = *_params.0.add(16).cast::<*mut u8>();
                  let l15 = *_params.0.add(16+1*::core::mem::size_of::<*const u8>()).cast::<usize>();
                  let base16 = l14;
                  let len16 = l15;
                  _rt::cabi_dealloc(base16, len16 * 1, 1);
                },
                11 => {
                  let l17 = *_params.0.add(16).cast::<*mut u8>();
                  let l18 = *_params.0.add(16+1*::core::mem::size_of::<*const u8>()).cast::<usize>();
                  let base19 = l17;
                  let len19 = l18;
                  _rt::cabi_dealloc(base19, len19 * 24, 8);
                },
                12 => {
                  let l20 = *_params.0.add(16).cast::<*mut u8>();
                  let l21 = *_params.0.add(16+1*::core::mem::size_of::<*const u8>()).cast::<usize>();
                  let base22 = l20;
                  let len22 = l21;
                  _rt::cabi_dealloc(base22, len22 * 4, 2);
                },
                13 => {
                  let l23 = *_params.0.add(16).cast::<*mut u8>();
                  let l24 = *_params.0.add(16+1*::core::mem::size_of::<*const u8>()).cast::<usize>();
                  let base25 = l23;
                  let len25 = l24;
                  _rt::cabi_dealloc(base25, len25 * 3, 1);
                },
                14 => (),
                15 => (),
                16 => (),
                17 => (),
                18 => (),
                19 => (),
                20 => (),
                21 => (),
                22 => (),
                23 => (),
                24 => (),
                25 => (),
                26 => (),
                27 => (),
                28 => (),
                29 => (),
                30 => {
                  let l26 = *_params.0.add(16).cast::<*mut u8>();
                  let l27 = *_params.0.add(16+1*::core::mem::size_of::<*const u8>()).cast::<usize>();
                  _rt::cabi_dealloc(l26, l27, 1);
                },
                31 => (),
                32 => {
                  let l28 = *_params.0.add(16).cast::<*mut u8>();
                  let l29 = *_params.0.add(16+1*::core::mem::size_of::<*const u8>()).cast::<usize>();
                  _rt::cabi_dealloc(l28, l29, 1);
                },
                33 => (),
                34 => (),
                35 => (),
                36 => (),
                37 => (),
                38 => (),
                39 => (),
                40 => (),
                41 => (),
                42 => (),
                43 => (),
                44 => (),
                45 => (),
                46 => (),
                47 => (),
                48 => (),
                49 => (),
                50 => (),
                51 => (),
                52 => (),
                53 => (),
                54 => (),
                55 => (),
                56 => (),
                57 => (),
                58 => (),
                59 => (),
                60 => (),
                61 => (),
                62 => (),
                63 => (),
                64 => (),
                65 => (),
                66 => (),
                67 => (),
                68 => (),
                69 => (),
                70 => (),
                71 => (),
                72 => (),
                _ => (),
              }
            }
          }
          unsafe fn params_lower(&mut self, (_lower0, _lower1,): Self::Params, _ptr: *mut u8) -> Self::ParamsLower {
            let _param_ptr = unsafe { _ptr.add(0) };
            unsafe { *_param_ptr.add(0).cast::<i32>() = (_lower0).handle() as i32;
          }
          let _param_ptr = unsafe { _ptr.add(8) };
          unsafe { use super::super::super::__with_name2::Component as V14;
          match _lower1 {
            V14::Integer(e) => {
              *_param_ptr.add(0).cast::<u8>() = (0i32) as u8;
              *_param_ptr.add(8).cast::<i64>() = _rt::as_i64(e);
            },
            V14::Float(e) => {
              *_param_ptr.add(0).cast::<u8>() = (1i32) as u8;
              *_param_ptr.add(8).cast::<f64>() = _rt::as_f64(e);
            },
            V14::String(e) => {
              *_param_ptr.add(0).cast::<u8>() = (2i32) as u8;
              let vec0 = (e.into_bytes()).into_boxed_slice();
              let ptr0 = vec0.as_ptr().cast::<u8>();
              let len0 = vec0.len();
              ::core::mem::forget(vec0);
              *_param_ptr.add(8+1*::core::mem::size_of::<*const u8>()).cast::<usize>() = len0;
              *_param_ptr.add(8).cast::<*mut u8>() = ptr0.cast_mut();
            },
            V14::Bool(e) => {
              *_param_ptr.add(0).cast::<u8>() = (3i32) as u8;
              *_param_ptr.add(8).cast::<u8>() = (match e { true => 1, false => 0 }) as u8;
            },
            V14::Color(e) => {
              *_param_ptr.add(0).cast::<u8>() = (4i32) as u8;
              let super::super::super::__with_name1::IglooColor{ r:r1, g:g1, b:b1, } = e;
              *_param_ptr.add(8).cast::<f64>() = _rt::as_f64(r1);
              *_param_ptr.add(16).cast::<f64>() = _rt::as_f64(g1);
              *_param_ptr.add(24).cast::<f64>() = _rt::as_f64(b1);
            },
            V14::Date(e) => {
              *_param_ptr.add(0).cast::<u8>() = (5i32) as u8;
              let super::super::super::__with_name1::IglooDate{ year:year2, month:month2, day:day2, } = e;
              *_param_ptr.add(8).cast::<u16>() = (_rt::as_i32(year2)) as u16;
              *_param_ptr.add(10).cast::<u8>() = (_rt::as_i32(month2)) as u8;
              *_param_ptr.add(11).cast::<u8>() = (_rt::as_i32(day2)) as u8;
            },
            V14::Time(e) => {
              *_param_ptr.add(0).cast::<u8>() = (6i32) as u8;
              let super::super::super::__with_name1::IglooTime{ hour:hour3, minute:minute3, second:second3, } = e;
              *_param_ptr.add(8).cast::<u8>() = (_rt::as_i32(hour3)) as u8;
              *_param_ptr.add(9).cast::<u8>() = (_rt::as_i32(minute3)) as u8;
              *_param_ptr.add(10).cast::<u8>() = (_rt::as_i32(second3)) as u8;
            },
            V14::IntegerList(e) => {
              *_param_ptr.add(0).cast::<u8>() = (7i32) as u8;
              let vec4 = <_ as Into<_rt::Vec<_>>>::into(e).into_boxed_slice();
              let ptr4 = vec4.as_ptr().cast::<u8>();
              let len4 = vec4.len();
              ::core::mem::forget(vec4);
              *_param_ptr.add(8+1*::core::mem::size_of::<*const u8>()).cast::<usize>() = len4;
              *_param_ptr.add(8).cast::<*mut u8>() = ptr4.cast_mut();
            },
            V14::FloatList(e) => {
              *_param_ptr.add(0).cast::<u8>() = (8i32) as u8;
              let vec5 = <_ as Into<_rt::Vec<_>>>::into(e).into_boxed_slice();
              let ptr5 = vec5.as_ptr().cast::<u8>();
              let len5 = vec5.len();
              ::core::mem::forget(vec5);
              *_param_ptr.add(8+1*::core::mem::size_of::<*const u8>()).cast::<usize>() = len5;
              *_param_ptr.add(8).cast::<*mut u8>() = ptr5.cast_mut();
            },
            V14::StringList(e) => {
              *_param_ptr.add(0).cast::<u8>() = (9i32) as u8;
              let vec7 = e;
              let len7 = vec7.len();
              let layout7 = _rt::alloc::Layout::from_size_align(vec7.len() * (2*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>()).unwrap();
              let (result7, _cleanup7) = wit_bindgen::rt::Cleanup::new(layout7);if let Some(cleanup) = _cleanup7 { cleanup.forget(); }
              for (i, e) in vec7.into_iter().enumerate() {
                let base = result7.add(i * (2*::core::mem::size_of::<*const u8>()));
                {
                  let vec6 = (e.into_bytes()).into_boxed_slice();
                  let ptr6 = vec6.as_ptr().cast::<u8>();
                  let len6 = vec6.len();
                  ::core::mem::forget(vec6);
                  *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len6;
                  *base.add(0).cast::<*mut u8>() = ptr6.cast_mut();
                }
              }
              *_param_ptr.add(8+1*::core::mem::size_of::<*const u8>()).cast::<usize>() = len7;
              *_param_ptr.add(8).cast::<*mut u8>() = result7;
            },
            V14::BooleanList(e) => {
              *_param_ptr.add(0).cast::<u8>() = (10i32) as u8;
              let vec8 = e;
              let len8 = vec8.len();
              let layout8 = _rt::alloc::Layout::from_size_align(vec8.len() * 1, 1).unwrap();
              let (result8, _cleanup8) = wit_bindgen::rt::Cleanup::new(layout8);if let Some(cleanup) = _cleanup8 { cleanup.forget(); }
              for (i, e) in vec8.into_iter().enumerate() {
                let base = result8.add(i * 1);
                {
                  *base.add(0).cast::<u8>() = (match e { true => 1, false => 0 }) as u8;
                }
              }
              *_param_ptr.add(8+1*::core::mem::size_of::<*const u8>()).cast::<usize>() = len8;
              *_param_ptr.add(8).cast::<*mut u8>() = result8;
            },
            V14::ColorList(e) => {
              *_param_ptr.add(0).cast::<u8>() = (11i32) as u8;
              let vec9 = <_ as Into<_rt::Vec<_>>>::into(e).into_boxed_slice();
              let ptr9 = vec9.as_ptr().cast::<u8>();
              let len9 = vec9.len();
              ::core::mem::forget(vec9);
              *_param_ptr.add(8+1*::core::mem::size_of::<*const u8>()).cast::<usize>() = len9;
              *_param_ptr.add(8).cast::<*mut u8>() = ptr9.cast_mut();
            },
            V14::DateList(e) => {
              *_param_ptr.add(0).cast::<u8>() = (12i32) as u8;
              let vec10 = <_ as Into<_rt::Vec<_>>>::into(e).into_boxed_slice();
              let ptr10 = vec10.as_ptr().cast::<u8>();
              let len10 = vec10.len();
              ::core::mem::forget(vec10);
              *_param_ptr.add(8+1*::core::mem::size_of::<*const u8>()).cast::<usize>() = len10;
              *_param_ptr.add(8).cast::<*mut u8>() = ptr10.cast_mut();
            },
            V14::TimeList(e) => {
              *_param_ptr.add(0).cast::<u8>() = (13i32) as u8;
              let vec11 = <_ as Into<_rt::Vec<_>>>::into(e).into_boxed_slice();
              let ptr11 = vec11.as_ptr().cast::<u8>();
              let len11 = vec11.len();
              ::core::mem::forget(vec11);
              *_param_ptr.add(8+1*::core::mem::size_of::<*const u8>()).cast::<usize>() = len11;
              *_param_ptr.add(8).cast::<*mut u8>() = ptr11.cast_mut();
            },
            V14::Trigger=> {
              {
                *_param_ptr.add(0).cast::<u8>() = (14i32) as u8;
              }
            }
            V14::Timestamp(e) => {
              *_param_ptr.add(0).cast::<u8>() = (15i32) as u8;
              *_param_ptr.add(8).cast::<i64>() = _rt::as_i64(e);
            },
            V14::Duration(e) => {
              *_param_ptr.add(0).cast::<u8>() = (16i32) as u8;
              *_param_ptr.add(8).cast::<i64>() = _rt::as_i64(e);
            },
            V14::Weekday(e) => {
              *_param_ptr.add(0).cast::<u8>() = (17i32) as u8;
              *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
            },
            V14::Light=> {
              {
                *_param_ptr.add(0).cast::<u8>() = (18i32) as u8;
              }
            }
            V14::Switch(e) => {
              *_param_ptr.add(0).cast::<u8>() = (19i32) as u8;
              *_param_ptr.add(8).cast::<u8>() = (match e { true => 1, false => 0 }) as u8;
            },
            V14::Dimmer(e) => {
              *_param_ptr.add(0).cast::<u8>() = (20i32) as u8;
              *_param_ptr.add(8).cast::<f64>() = _rt::as_f64(e);
            },
            V14::Switch(e) => {
              *_param_ptr.add(0).cast::<u8>() = (21i32) as u8;
              *_param_ptr.add(8).cast::<u8>() = (match e { true => 1, false => 0 }) as u8;
            },
            V14::ColorMode(e) => {
              *_param_ptr.add(0).cast::<u8>() = (22i32) as u8;
              *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
            },
            V14::ColorTemperature(e) => {
              *_param_ptr.add(0).cast::<u8>() = (23i32) as u8;
              *_param_ptr.add(8).cast::<i64>() = _rt::as_i64(e);
            },
            V14::Volume(e) => {
              *_param_ptr.add(0).cast::<u8>() = (24i32) as u8;
              *_param_ptr.add(8).cast::<f64>() = _rt::as_f64(e);
            },
            V14::Muted(e) => {
              *_param_ptr.add(0).cast::<u8>() = (25i32) as u8;
              *_param_ptr.add(8).cast::<u8>() = (match e { true => 1, false => 0 }) as u8;
            },
            V14::Config=> {
              {
                *_param_ptr.add(0).cast::<u8>() = (26i32) as u8;
              }
            }
            V14::Diagnostic=> {
              {
                *_param_ptr.add(0).cast::<u8>() = (27i32) as u8;
              }
            }
            V14::Siren=> {
              {
                *_param_ptr.add(0).cast::<u8>() = (28i32) as u8;
              }
            }
            V14::Sensor=> {
              {
                *_param_ptr.add(0).cast::<u8>() = (29i32) as u8;
              }
            }
            V14::Icon(e) => {
              *_param_ptr.add(0).cast::<u8>() = (30i32) as u8;
              let vec12 = (e.into_bytes()).into_boxed_slice();
              let ptr12 = vec12.as_ptr().cast::<u8>();
              let len12 = vec12.len();
              ::core::mem::forget(vec12);
              *_param_ptr.add(8+1*::core::mem::size_of::<*const u8>()).cast::<usize>() = len12;
              *_param_ptr.add(8).cast::<*mut u8>() = ptr12.cast_mut();
            },
            V14::AccuracyDecimals(e) => {
              *_param_ptr.add(0).cast::<u8>() = (31i32) as u8;
              *_param_ptr.add(8).cast::<i64>() = _rt::as_i64(e);
            },
            V14::DeviceClass(e) => {
              *_param_ptr.add(0).cast::<u8>() = (32i32) as u8;
              let vec13 = (e.into_bytes()).into_boxed_slice();
              let ptr13 = vec13.as_ptr().cast::<u8>();
              let len13 = vec13.len();
              ::core::mem::forget(vec13);
              *_param_ptr.add(8+1*::core::mem::size_of::<*const u8>()).cast::<usize>() = len13;
              *_param_ptr.add(8).cast::<*mut u8>() = ptr13.cast_mut();
            },
            V14::SensorStateClass(e) => {
              *_param_ptr.add(0).cast::<u8>() = (33i32) as u8;
              *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
            },
            V14::UnitApparentPower(e) => {
              *_param_ptr.add(0).cast::<u8>() = (34i32) as u8;
              *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
            },
            V14::UnitPower(e) => {
              *_param_ptr.add(0).cast::<u8>() = (35i32) as u8;
              *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
            },
            V14::UnitReactivePower(e) => {
              *_param_ptr.add(0).cast::<u8>() = (36i32) as u8;
              *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
            },
            V14::UnitEnergy(e) => {
              *_param_ptr.add(0).cast::<u8>() = (37i32) as u8;
              *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
            },
            V14::UnitElectricCurrent(e) => {
              *_param_ptr.add(0).cast::<u8>() = (38i32) as u8;
              *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
            },
            V14::UnitElectricPotential(e) => {
              *_param_ptr.add(0).cast::<u8>() = (39i32) as u8;
              *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
            },
            V14::UnitDegree(e) => {
              *_param_ptr.add(0).cast::<u8>() = (40i32) as u8;
              *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
            },
            V14::UnitCurrency(e) => {
              *_param_ptr.add(0).cast::<u8>() = (41i32) as u8;
              *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
            },
            V14::UnitTemperature(e) => {
              *_param_ptr.add(0).cast::<u8>() = (42i32) as u8;
              *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
            },
            V14::UnitTime(e) => {
              *_param_ptr.add(0).cast::<u8>() = (43i32) as u8;
              *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
            },
            V14::UnitLength(e) => {
              *_param_ptr.add(0).cast::<u8>() = (44i32) as u8;
              *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
            },
            V14::UnitFrequency(e) => {
              *_param_ptr.add(0).cast::<u8>() = (45i32) as u8;
              *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
            },
            V14::UnitPressure(e) => {
              *_param_ptr.add(0).cast::<u8>() = (46i32) as u8;
              *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
            },
            V14::UnitSoundPressure(e) => {
              *_param_ptr.add(0).cast::<u8>() = (47i32) as u8;
              *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
            },
            V14::UnitVolume(e) => {
              *_param_ptr.add(0).cast::<u8>() = (48i32) as u8;
              *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
            },
            V14::UnitVolumeFlowRate(e) => {
              *_param_ptr.add(0).cast::<u8>() = (49i32) as u8;
              *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
            },
            V14::UnitArea(e) => {
              *_param_ptr.add(0).cast::<u8>() = (50i32) as u8;
              *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
            },
            V14::UnitMass(e) => {
              *_param_ptr.add(0).cast::<u8>() = (51i32) as u8;
              *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
            },
            V14::UnitConductivity(e) => {
              *_param_ptr.add(0).cast::<u8>() = (52i32) as u8;
              *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
            },
            V14::UnitLight(e) => {
              *_param_ptr.add(0).cast::<u8>() = (53i32) as u8;
              *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
            },
            V14::UnitUvIndex(e) => {
              *_param_ptr.add(0).cast::<u8>() = (54i32) as u8;
              *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
            },
            V14::UnitPercentage(e) => {
              *_param_ptr.add(0).cast::<u8>() = (55i32) as u8;
              *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
            },
            V14::UnitIrradiation(e) => {
              *_param_ptr.add(0).cast::<u8>() = (56i32) as u8;
              *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
            },
            V14::UnitConcentration(e) => {
              *_param_ptr.add(0).cast::<u8>() = (57i32) as u8;
              *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
            },
            V14::UnitSpeed(e) => {
              *_param_ptr.add(0).cast::<u8>() = (58i32) as u8;
              *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
            },
            V14::UnitData(e) => {
              *_param_ptr.add(0).cast::<u8>() = (59i32) as u8;
              *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
            },
            V14::UnitDataRate(e) => {
              *_param_ptr.add(0).cast::<u8>() = (60i32) as u8;
              *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
            },
            V14::FanOscillation(e) => {
              *_param_ptr.add(0).cast::<u8>() = (61i32) as u8;
              *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
            },
            V14::FanDirection(e) => {
              *_param_ptr.add(0).cast::<u8>() = (62i32) as u8;
              *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
            },
            V14::FanSpeed(e) => {
              *_param_ptr.add(0).cast::<u8>() = (63i32) as u8;
              *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
            },
            V14::ClimateMode(e) => {
              *_param_ptr.add(0).cast::<u8>() = (64i32) as u8;
              *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
            },
            V14::LockState(e) => {
              *_param_ptr.add(0).cast::<u8>() = (65i32) as u8;
              *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
            },
            V14::MediaState(e) => {
              *_param_ptr.add(0).cast::<u8>() = (66i32) as u8;
              *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
            },
            V14::Cover=> {
              {
                *_param_ptr.add(0).cast::<u8>() = (67i32) as u8;
              }
            }
            V14::CoverState(e) => {
              *_param_ptr.add(0).cast::<u8>() = (68i32) as u8;
              *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
            },
            V14::Position(e) => {
              *_param_ptr.add(0).cast::<u8>() = (69i32) as u8;
              *_param_ptr.add(8).cast::<f64>() = _rt::as_f64(e);
            },
            V14::Tilt(e) => {
              *_param_ptr.add(0).cast::<u8>() = (70i32) as u8;
              *_param_ptr.add(8).cast::<f64>() = _rt::as_f64(e);
            },
            V14::Valve=> {
              {
                *_param_ptr.add(0).cast::<u8>() = (71i32) as u8;
              }
            }
            V14::ValveState(e) => {
              *_param_ptr.add(0).cast::<u8>() = (72i32) as u8;
              *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
            },
            V14::AlarmState(e) => {
              *_param_ptr.add(0).cast::<u8>() = (73i32) as u8;
              *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
            },
          }
        }
        ParamsLower(_ptr,)
      }
      unsafe fn results_lift(&mut self, _ptr: *mut u8) -> Self::Results {
        unsafe { let l0 = i32::from(*_ptr.add(0).cast::<u8>());

        match l0 {
          0 => {
            let e = ();
            Ok(e)
          }
          1 => {
            let e = {
              let l1 = i32::from(*_ptr.add(1).cast::<u8>());

              EntityError::_lift(l1 as u8)
            };
            Err(e)
          }
          _ => _rt::invalid_enum_discriminant(),
        } }
      }
    }
    _MySubtask { _unused: core::marker::PhantomData }.call((self, component,)).await
  }
}
}

}


#[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
pub mod extension_sp_to_igloo {
  #[used]
  #[doc(hidden)]
  static __FORCE_SECTION_REF: fn() =
  super::super::super::__link_custom_section_describing_imports;
  
  use super::super::super::_rt;
  pub type DeviceId = super::super::super::__with_name0::DeviceId;
  pub type EntityId = super::super::super::__with_name0::EntityId;
  pub type Component = super::super::super::__with_name2::Component;
  pub type Entity = super::super::super::igloo::lib::entity::Entity;
  #[repr(u8)]
  #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd, serde::Deserialize, serde::Serialize)]
  pub enum DeviceError {
    InvalidDevice,
  }
  impl DeviceError{
    pub fn name(&self) -> &'static str {
      match self {
        DeviceError::InvalidDevice => "invalid-device",
      }
    }
    pub fn message(&self) -> &'static str {
      match self {
        DeviceError::InvalidDevice => "",
      }
    }
  }
  impl ::core::fmt::Debug for DeviceError{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
      f.debug_struct("DeviceError")
      .field("code", &(*self as i32))
      .field("name", &self.name())
      .field("message", &self.message())
      .finish()
    }
  }
  impl ::core::fmt::Display for DeviceError{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
      write!(f, "{} (error {})", self.name(), *self as i32)
    }
  }

  impl ::core::error::Error for DeviceError {}

  impl DeviceError{
    #[doc(hidden)]
    pub unsafe fn _lift(val: u8) -> DeviceError{
      if !cfg!(debug_assertions) {
        return unsafe { ::core::mem::transmute(val) };
      }

      match val {
        0 => DeviceError::InvalidDevice,

        _ => panic!("invalid enum discriminant"),
      }
    }
  }


  #[derive(Debug)]
  #[repr(transparent)]
  pub struct Device{
    handle: _rt::Resource<Device>,
  }

  impl Device{
    #[doc(hidden)]
    pub unsafe fn from_handle(handle: u32) -> Self {
      Self {
        handle: unsafe { _rt::Resource::from_handle(handle) },
      }
    }

    #[doc(hidden)]
    pub fn take_handle(&self) -> u32 {
      _rt::Resource::take_handle(&self.handle)
    }

    #[doc(hidden)]
    pub fn handle(&self) -> u32 {
      _rt::Resource::handle(&self.handle)
    }
  }
  

  unsafe impl _rt::WasmResource for Device{
    #[inline]
    unsafe fn drop(_handle: u32) {
      
      #[cfg(target_arch = "wasm32")]
      #[link(wasm_import_module = "igloo:lib/extension-sp-to-igloo@0.1.0")]
      unsafe extern "C" {
        #[link_name = "[resource-drop]device"]
        fn drop(_: i32, );
      }

      #[cfg(not(target_arch = "wasm32"))]
      unsafe extern "C" fn drop(_: i32, ) { unreachable!() }
      
      unsafe { drop(_handle as i32); }
    }
  }
  
  #[allow(unused_unsafe, clippy::all)]
  /// Get persisted devices
  #[allow(async_fn_in_trait)]
  pub async fn get_devices() -> _rt::Vec::<Device>{
    unsafe {

      #[derive(Copy, Clone)]
      struct ParamsLower(
      
      );
      unsafe impl Send for ParamsLower {}
      

      use wit_bindgen::rt::async_support::Subtask as _Subtask;
      struct _MySubtask<'a> { _unused: core::marker::PhantomData<&'a ()> }
      #[allow(unused_parens)]
      unsafe impl<'a> _Subtask for _MySubtask<'a> {
        
        type Params = ();
        type Results = _rt::Vec::<Device>;
        type ParamsLower = ParamsLower;
        fn abi_layout(&mut self) -> ::core::alloc::Layout {
          unsafe {
            ::core::alloc::Layout::from_size_align_unchecked((2*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>())
          }
        }
        
        fn results_offset(&mut self) -> usize { 0 }

        unsafe fn call_import(&mut self, _params: Self::ParamsLower, _results: *mut u8) -> u32 {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "igloo:lib/extension-sp-to-igloo@0.1.0")]
          unsafe extern "C" {
            #[link_name = "[async-lower]get-devices"]
            fn call(_: *mut u8, ) -> i32;
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn call(_: *mut u8, ) -> i32 { unreachable!() }
          
          unsafe { call(_results) as u32 }
        }
        
        unsafe fn params_dealloc_lists(&mut self, _params: Self::ParamsLower) {
          unsafe {  }
        }
        unsafe fn params_dealloc_lists_and_own(&mut self, _params: Self::ParamsLower) {
          unsafe {  }
        }
        unsafe fn params_lower(&mut self, (): Self::Params, _ptr: *mut u8) -> Self::ParamsLower {
          unsafe {  ParamsLower() }
        }
        unsafe fn results_lift(&mut self, _ptr: *mut u8) -> Self::Results {
          unsafe { let l0 = *_ptr.add(0).cast::<*mut u8>();
          let l1 = *_ptr.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
          let base3 = l0;
          let len3 = l1;
          let mut result3 = _rt::Vec::with_capacity(len3);
          for i in 0..len3 {
            let base = base3.add(i * 4);
            let e3 = {
              let l2 = *base.add(0).cast::<i32>();

              Device::from_handle(l2 as u32)
            };
            result3.push(e3);
          }
          _rt::cabi_dealloc(base3, len3 * 4, 4);

          result3 }
        }
      }
      _MySubtask { _unused: core::marker::PhantomData }.call(()).await
    }
  }
  #[allow(unused_unsafe, clippy::all)]
  /// Get a value from the config for the entire extension
  #[allow(async_fn_in_trait)]
  pub async fn get_cfg(key: _rt::String,) -> Option<_rt::String>{
    unsafe {

      #[derive(Copy, Clone)]
      struct ParamsLower(
      *mut u8, usize, 
      );
      unsafe impl Send for ParamsLower {}
      

      use wit_bindgen::rt::async_support::Subtask as _Subtask;
      struct _MySubtask<'a> { _unused: core::marker::PhantomData<&'a ()> }
      #[allow(unused_parens)]
      unsafe impl<'a> _Subtask for _MySubtask<'a> {
        
        type Params = (_rt::String, );
        type Results = Option<_rt::String>;
        type ParamsLower = ParamsLower;
        fn abi_layout(&mut self) -> ::core::alloc::Layout {
          unsafe {
            ::core::alloc::Layout::from_size_align_unchecked((3*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>())
          }
        }
        
        fn results_offset(&mut self) -> usize { 0 }

        unsafe fn call_import(&mut self, _params: Self::ParamsLower, _results: *mut u8) -> u32 {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "igloo:lib/extension-sp-to-igloo@0.1.0")]
          unsafe extern "C" {
            #[link_name = "[async-lower]get-cfg"]
            fn call(_: *mut u8, _: usize, _: *mut u8, ) -> i32;
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn call(_: *mut u8, _: usize, _: *mut u8, ) -> i32 { unreachable!() }
          
          unsafe { call(_params.0,_params.1,_results) as u32 }
        }
        
        unsafe fn params_dealloc_lists(&mut self, _params: Self::ParamsLower) {
          unsafe { _rt::cabi_dealloc(_params.0, _params.1, 1);
        }
      }
      unsafe fn params_dealloc_lists_and_own(&mut self, _params: Self::ParamsLower) {
        unsafe { _rt::cabi_dealloc(_params.0, _params.1, 1);
      }
    }
    unsafe fn params_lower(&mut self, (_lower0,): Self::Params, _ptr: *mut u8) -> Self::ParamsLower {
      unsafe { let vec0 = (_lower0.into_bytes()).into_boxed_slice();
      let ptr0 = vec0.as_ptr().cast::<u8>();
      let len0 = vec0.len();
      ::core::mem::forget(vec0);
      ParamsLower(ptr0.cast_mut(), len0,) }
    }
    unsafe fn results_lift(&mut self, _ptr: *mut u8) -> Self::Results {
      unsafe { let l0 = i32::from(*_ptr.add(0).cast::<u8>());

      match l0 {
        0 => None,
        1 => {
          let e = {
            let l1 = *_ptr.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
            let l2 = *_ptr.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>();
            let len3 = l2;
            let bytes3 = _rt::Vec::from_raw_parts(l1.cast(), len3, len3);

            _rt::string_lift(bytes3)
          };
          Some(e)
        }
        _ => _rt::invalid_enum_discriminant(),
      } }
    }
  }
  _MySubtask { _unused: core::marker::PhantomData }.call((key,)).await
}
}
#[allow(unused_unsafe, clippy::all)]
/// Save a value to the config for the entire extension
#[allow(async_fn_in_trait)]
pub async fn save_cfg(key: _rt::String,value: _rt::String,) -> (){
  unsafe {

    #[derive(Copy, Clone)]
    struct ParamsLower(
    *mut u8, usize, *mut u8, usize, 
    );
    unsafe impl Send for ParamsLower {}
    

    use wit_bindgen::rt::async_support::Subtask as _Subtask;
    struct _MySubtask<'a> { _unused: core::marker::PhantomData<&'a ()> }
    #[allow(unused_parens)]
    unsafe impl<'a> _Subtask for _MySubtask<'a> {
      
      type Params = (_rt::String, _rt::String, );
      type Results = ();
      type ParamsLower = ParamsLower;
      fn abi_layout(&mut self) -> ::core::alloc::Layout {
        unsafe {
          ::core::alloc::Layout::from_size_align_unchecked(0, 1)
        }
      }
      
      fn results_offset(&mut self) -> usize { 0 }

      unsafe fn call_import(&mut self, _params: Self::ParamsLower, _results: *mut u8) -> u32 {
        
        #[cfg(target_arch = "wasm32")]
        #[link(wasm_import_module = "igloo:lib/extension-sp-to-igloo@0.1.0")]
        unsafe extern "C" {
          #[link_name = "[async-lower]save-cfg"]
          fn call(_: *mut u8, _: usize, _: *mut u8, _: usize, ) -> i32;
        }

        #[cfg(not(target_arch = "wasm32"))]
        unsafe extern "C" fn call(_: *mut u8, _: usize, _: *mut u8, _: usize, ) -> i32 { unreachable!() }
        
        unsafe { call(_params.0,_params.1,_params.2,_params.3,) as u32 }
      }
      
      unsafe fn params_dealloc_lists(&mut self, _params: Self::ParamsLower) {
        unsafe { _rt::cabi_dealloc(_params.0, _params.1, 1);
        _rt::cabi_dealloc(_params.2, _params.3, 1);
      }
    }
    unsafe fn params_dealloc_lists_and_own(&mut self, _params: Self::ParamsLower) {
      unsafe { _rt::cabi_dealloc(_params.0, _params.1, 1);
      _rt::cabi_dealloc(_params.2, _params.3, 1);
    }
  }
  unsafe fn params_lower(&mut self, (_lower0, _lower1,): Self::Params, _ptr: *mut u8) -> Self::ParamsLower {
    unsafe { let vec0 = (_lower0.into_bytes()).into_boxed_slice();
    let ptr0 = vec0.as_ptr().cast::<u8>();
    let len0 = vec0.len();
    ::core::mem::forget(vec0);
    let vec1 = (_lower1.into_bytes()).into_boxed_slice();
    let ptr1 = vec1.as_ptr().cast::<u8>();
    let len1 = vec1.len();
    ::core::mem::forget(vec1);
    ParamsLower(ptr0.cast_mut(), len0, ptr1.cast_mut(), len1,) }
  }
  unsafe fn results_lift(&mut self, _ptr: *mut u8) -> Self::Results {

  }
}
_MySubtask { _unused: core::marker::PhantomData }.call((key, value,)).await
}
}
#[allow(unused_unsafe, clippy::all)]
/// Remove a value from the config for the entire extension
#[allow(async_fn_in_trait)]
pub async fn remove_cfg(key: _rt::String,) -> (){
  unsafe {

    #[derive(Copy, Clone)]
    struct ParamsLower(
    *mut u8, usize, 
    );
    unsafe impl Send for ParamsLower {}
    

    use wit_bindgen::rt::async_support::Subtask as _Subtask;
    struct _MySubtask<'a> { _unused: core::marker::PhantomData<&'a ()> }
    #[allow(unused_parens)]
    unsafe impl<'a> _Subtask for _MySubtask<'a> {
      
      type Params = (_rt::String, );
      type Results = ();
      type ParamsLower = ParamsLower;
      fn abi_layout(&mut self) -> ::core::alloc::Layout {
        unsafe {
          ::core::alloc::Layout::from_size_align_unchecked(0, 1)
        }
      }
      
      fn results_offset(&mut self) -> usize { 0 }

      unsafe fn call_import(&mut self, _params: Self::ParamsLower, _results: *mut u8) -> u32 {
        
        #[cfg(target_arch = "wasm32")]
        #[link(wasm_import_module = "igloo:lib/extension-sp-to-igloo@0.1.0")]
        unsafe extern "C" {
          #[link_name = "[async-lower]remove-cfg"]
          fn call(_: *mut u8, _: usize, ) -> i32;
        }

        #[cfg(not(target_arch = "wasm32"))]
        unsafe extern "C" fn call(_: *mut u8, _: usize, ) -> i32 { unreachable!() }
        
        unsafe { call(_params.0,_params.1,) as u32 }
      }
      
      unsafe fn params_dealloc_lists(&mut self, _params: Self::ParamsLower) {
        unsafe { _rt::cabi_dealloc(_params.0, _params.1, 1);
      }
    }
    unsafe fn params_dealloc_lists_and_own(&mut self, _params: Self::ParamsLower) {
      unsafe { _rt::cabi_dealloc(_params.0, _params.1, 1);
    }
  }
  unsafe fn params_lower(&mut self, (_lower0,): Self::Params, _ptr: *mut u8) -> Self::ParamsLower {
    unsafe { let vec0 = (_lower0.into_bytes()).into_boxed_slice();
    let ptr0 = vec0.as_ptr().cast::<u8>();
    let len0 = vec0.len();
    ::core::mem::forget(vec0);
    ParamsLower(ptr0.cast_mut(), len0,) }
  }
  unsafe fn results_lift(&mut self, _ptr: *mut u8) -> Self::Results {

  }
}
_MySubtask { _unused: core::marker::PhantomData }.call((key,)).await
}
}
impl Device {
  #[allow(unused_unsafe, clippy::all)]
  /// Requests to register new device with Igloo
  /// Infallible
  #[allow(async_fn_in_trait)]
  pub async fn new(name: _rt::String,) -> Self{
    unsafe {

      #[derive(Copy, Clone)]
      struct ParamsLower(
      *mut u8, usize, 
      );
      unsafe impl Send for ParamsLower {}
      

      use wit_bindgen::rt::async_support::Subtask as _Subtask;
      struct _MySubtask<'a> { _unused: core::marker::PhantomData<&'a ()> }
      #[allow(unused_parens)]
      unsafe impl<'a> _Subtask for _MySubtask<'a> {
        
        type Params = (_rt::String, );
        type Results = Device;
        type ParamsLower = ParamsLower;
        fn abi_layout(&mut self) -> ::core::alloc::Layout {
          unsafe {
            ::core::alloc::Layout::from_size_align_unchecked(4, 4)
          }
        }
        
        fn results_offset(&mut self) -> usize { 0 }

        unsafe fn call_import(&mut self, _params: Self::ParamsLower, _results: *mut u8) -> u32 {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "igloo:lib/extension-sp-to-igloo@0.1.0")]
          unsafe extern "C" {
            #[link_name = "[async-lower][constructor]device"]
            fn call(_: *mut u8, _: usize, _: *mut u8, ) -> i32;
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn call(_: *mut u8, _: usize, _: *mut u8, ) -> i32 { unreachable!() }
          
          unsafe { call(_params.0,_params.1,_results) as u32 }
        }
        
        unsafe fn params_dealloc_lists(&mut self, _params: Self::ParamsLower) {
          unsafe { _rt::cabi_dealloc(_params.0, _params.1, 1);
        }
      }
      unsafe fn params_dealloc_lists_and_own(&mut self, _params: Self::ParamsLower) {
        unsafe { _rt::cabi_dealloc(_params.0, _params.1, 1);
      }
    }
    unsafe fn params_lower(&mut self, (_lower0,): Self::Params, _ptr: *mut u8) -> Self::ParamsLower {
      unsafe { let vec0 = (_lower0.into_bytes()).into_boxed_slice();
      let ptr0 = vec0.as_ptr().cast::<u8>();
      let len0 = vec0.len();
      ::core::mem::forget(vec0);
      ParamsLower(ptr0.cast_mut(), len0,) }
    }
    unsafe fn results_lift(&mut self, _ptr: *mut u8) -> Self::Results {
      unsafe { let l0 = *_ptr.add(0).cast::<i32>();

      Device::from_handle(l0 as u32) }
    }
  }
  _MySubtask { _unused: core::marker::PhantomData }.call((name,)).await
}
}
}
impl Device {
  #[allow(unused_unsafe, clippy::all)]
  /// Returns the ID of the device
  #[allow(async_fn_in_trait)]
  pub async fn id(&self,) -> Result<DeviceId,DeviceError>{
    unsafe {

      #[derive(Copy, Clone)]
      struct ParamsLower(
      i32, 
      );
      unsafe impl Send for ParamsLower {}
      

      use wit_bindgen::rt::async_support::Subtask as _Subtask;
      struct _MySubtask<'a> { _unused: core::marker::PhantomData<&'a ()> }
      #[allow(unused_parens)]
      unsafe impl<'a> _Subtask for _MySubtask<'a> {
        
        type Params = (&'a Device, );
        type Results = Result<DeviceId,DeviceError>;
        type ParamsLower = ParamsLower;
        fn abi_layout(&mut self) -> ::core::alloc::Layout {
          unsafe {
            ::core::alloc::Layout::from_size_align_unchecked(16, 8)
          }
        }
        
        fn results_offset(&mut self) -> usize { 0 }

        unsafe fn call_import(&mut self, _params: Self::ParamsLower, _results: *mut u8) -> u32 {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "igloo:lib/extension-sp-to-igloo@0.1.0")]
          unsafe extern "C" {
            #[link_name = "[async-lower][method]device.id"]
            fn call(_: i32, _: *mut u8, ) -> i32;
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn call(_: i32, _: *mut u8, ) -> i32 { unreachable!() }
          
          unsafe { call(_params.0,_results) as u32 }
        }
        
        unsafe fn params_dealloc_lists(&mut self, _params: Self::ParamsLower) {
          unsafe {  }
        }
        unsafe fn params_dealloc_lists_and_own(&mut self, _params: Self::ParamsLower) {
          unsafe {  }
        }
        unsafe fn params_lower(&mut self, (_lower0,): Self::Params, _ptr: *mut u8) -> Self::ParamsLower {
          unsafe {  ParamsLower((_lower0).handle() as i32,) }
        }
        unsafe fn results_lift(&mut self, _ptr: *mut u8) -> Self::Results {
          unsafe { let l0 = i32::from(*_ptr.add(0).cast::<u8>());

          match l0 {
            0 => {
              let e = {
                let l1 = *_ptr.add(8).cast::<i64>();

                super::super::super::__with_name0::DeviceId{
                  packed: l1 as u64,
                }
              };
              Ok(e)
            }
            1 => {
              let e = {
                let l2 = i32::from(*_ptr.add(8).cast::<u8>());

                DeviceError::_lift(l2 as u8)
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          } }
        }
      }
      _MySubtask { _unused: core::marker::PhantomData }.call((self,)).await
    }
  }
}
impl Device {
  #[allow(unused_unsafe, clippy::all)]
  /// Get a value from the config for this device
  #[allow(async_fn_in_trait)]
  pub async fn get_cfg(&self,key: _rt::String,) -> Result<Option<_rt::String>,DeviceError>{
    unsafe {

      #[derive(Copy, Clone)]
      struct ParamsLower(
      i32, *mut u8, usize, 
      );
      unsafe impl Send for ParamsLower {}
      

      use wit_bindgen::rt::async_support::Subtask as _Subtask;
      struct _MySubtask<'a> { _unused: core::marker::PhantomData<&'a ()> }
      #[allow(unused_parens)]
      unsafe impl<'a> _Subtask for _MySubtask<'a> {
        
        type Params = (&'a Device, _rt::String, );
        type Results = Result<Option<_rt::String>,DeviceError>;
        type ParamsLower = ParamsLower;
        fn abi_layout(&mut self) -> ::core::alloc::Layout {
          unsafe {
            ::core::alloc::Layout::from_size_align_unchecked((4*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>())
          }
        }
        
        fn results_offset(&mut self) -> usize { 0 }

        unsafe fn call_import(&mut self, _params: Self::ParamsLower, _results: *mut u8) -> u32 {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "igloo:lib/extension-sp-to-igloo@0.1.0")]
          unsafe extern "C" {
            #[link_name = "[async-lower][method]device.get-cfg"]
            fn call(_: i32, _: *mut u8, _: usize, _: *mut u8, ) -> i32;
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn call(_: i32, _: *mut u8, _: usize, _: *mut u8, ) -> i32 { unreachable!() }
          
          unsafe { call(_params.0,_params.1,_params.2,_results) as u32 }
        }
        
        unsafe fn params_dealloc_lists(&mut self, _params: Self::ParamsLower) {
          unsafe { _rt::cabi_dealloc(_params.1, _params.2, 1);
        }
      }
      unsafe fn params_dealloc_lists_and_own(&mut self, _params: Self::ParamsLower) {
        unsafe { _rt::cabi_dealloc(_params.1, _params.2, 1);
      }
    }
    unsafe fn params_lower(&mut self, (_lower0, _lower1,): Self::Params, _ptr: *mut u8) -> Self::ParamsLower {
      unsafe { let vec0 = (_lower1.into_bytes()).into_boxed_slice();
      let ptr0 = vec0.as_ptr().cast::<u8>();
      let len0 = vec0.len();
      ::core::mem::forget(vec0);
      ParamsLower((_lower0).handle() as i32, ptr0.cast_mut(), len0,) }
    }
    unsafe fn results_lift(&mut self, _ptr: *mut u8) -> Self::Results {
      unsafe { let l0 = i32::from(*_ptr.add(0).cast::<u8>());

      match l0 {
        0 => {
          let e = {
            let l1 = i32::from(*_ptr.add(::core::mem::size_of::<*const u8>()).cast::<u8>());

            match l1 {
              0 => None,
              1 => {
                let e = {
                  let l2 = *_ptr.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                  let l3 = *_ptr.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>();
                  let len4 = l3;
                  let bytes4 = _rt::Vec::from_raw_parts(l2.cast(), len4, len4);

                  _rt::string_lift(bytes4)
                };
                Some(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            }
          };
          Ok(e)
        }
        1 => {
          let e = {
            let l5 = i32::from(*_ptr.add(::core::mem::size_of::<*const u8>()).cast::<u8>());

            DeviceError::_lift(l5 as u8)
          };
          Err(e)
        }
        _ => _rt::invalid_enum_discriminant(),
      } }
    }
  }
  _MySubtask { _unused: core::marker::PhantomData }.call((self, key,)).await
}
}
}
impl Device {
  #[allow(unused_unsafe, clippy::all)]
  /// Save a value to the config for this device
  #[allow(async_fn_in_trait)]
  pub async fn save_cfg(&self,key: _rt::String,value: _rt::String,) -> Result<(),DeviceError>{
    unsafe {

      #[derive(Copy, Clone)]
      struct ParamsLower(
      *mut u8, 
      );
      unsafe impl Send for ParamsLower {}
      

      use wit_bindgen::rt::async_support::Subtask as _Subtask;
      struct _MySubtask<'a> { _unused: core::marker::PhantomData<&'a ()> }
      #[allow(unused_parens)]
      unsafe impl<'a> _Subtask for _MySubtask<'a> {
        
        type Params = (&'a Device, _rt::String, _rt::String, );
        type Results = Result<(),DeviceError>;
        type ParamsLower = ParamsLower;
        fn abi_layout(&mut self) -> ::core::alloc::Layout {
          unsafe {
            ::core::alloc::Layout::from_size_align_unchecked((6*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>())
          }
        }
        
        fn results_offset(&mut self) -> usize { (5*::core::mem::size_of::<*const u8>()) }

        unsafe fn call_import(&mut self, _params: Self::ParamsLower, _results: *mut u8) -> u32 {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "igloo:lib/extension-sp-to-igloo@0.1.0")]
          unsafe extern "C" {
            #[link_name = "[async-lower][method]device.save-cfg"]
            fn call(_: *mut u8, _: *mut u8, ) -> i32;
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn call(_: *mut u8, _: *mut u8, ) -> i32 { unreachable!() }
          
          unsafe { call(_params.0,_results) as u32 }
        }
        
        unsafe fn params_dealloc_lists(&mut self, _params: Self::ParamsLower) {
          unsafe { let l0 = *_params.0.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
          let l1 = *_params.0.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>();
          _rt::cabi_dealloc(l0, l1, 1);
          let l2 = *_params.0.add(3*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
          let l3 = *_params.0.add(4*::core::mem::size_of::<*const u8>()).cast::<usize>();
          _rt::cabi_dealloc(l2, l3, 1);
        }
      }
      unsafe fn params_dealloc_lists_and_own(&mut self, _params: Self::ParamsLower) {
        unsafe { let l0 = *_params.0.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
        let l1 = *_params.0.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>();
        _rt::cabi_dealloc(l0, l1, 1);
        let l2 = *_params.0.add(3*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
        let l3 = *_params.0.add(4*::core::mem::size_of::<*const u8>()).cast::<usize>();
        _rt::cabi_dealloc(l2, l3, 1);
      }
    }
    unsafe fn params_lower(&mut self, (_lower0, _lower1, _lower2,): Self::Params, _ptr: *mut u8) -> Self::ParamsLower {
      let _param_ptr = unsafe { _ptr.add(0) };
      unsafe { *_param_ptr.add(0).cast::<i32>() = (_lower0).handle() as i32;
    }
    let _param_ptr = unsafe { _ptr.add(::core::mem::size_of::<*const u8>()) };
    unsafe { let vec0 = (_lower1.into_bytes()).into_boxed_slice();
    let ptr0 = vec0.as_ptr().cast::<u8>();
    let len0 = vec0.len();
    ::core::mem::forget(vec0);
    *_param_ptr.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len0;
    *_param_ptr.add(0).cast::<*mut u8>() = ptr0.cast_mut();
  }
  let _param_ptr = unsafe { _ptr.add((3*::core::mem::size_of::<*const u8>())) };
  unsafe { let vec0 = (_lower2.into_bytes()).into_boxed_slice();
  let ptr0 = vec0.as_ptr().cast::<u8>();
  let len0 = vec0.len();
  ::core::mem::forget(vec0);
  *_param_ptr.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len0;
  *_param_ptr.add(0).cast::<*mut u8>() = ptr0.cast_mut();
}
ParamsLower(_ptr,)
}
unsafe fn results_lift(&mut self, _ptr: *mut u8) -> Self::Results {
  unsafe { let l0 = i32::from(*_ptr.add(0).cast::<u8>());

  match l0 {
    0 => {
      let e = ();
      Ok(e)
    }
    1 => {
      let e = {
        let l1 = i32::from(*_ptr.add(1).cast::<u8>());

        DeviceError::_lift(l1 as u8)
      };
      Err(e)
    }
    _ => _rt::invalid_enum_discriminant(),
  } }
}
}
_MySubtask { _unused: core::marker::PhantomData }.call((self, key, value,)).await
}
}
}
impl Device {
  #[allow(unused_unsafe, clippy::all)]
  /// Remove a value from the config for this device
  #[allow(async_fn_in_trait)]
  pub async fn remove_cfg(&self,key: _rt::String,) -> Result<(),DeviceError>{
    unsafe {

      #[derive(Copy, Clone)]
      struct ParamsLower(
      i32, *mut u8, usize, 
      );
      unsafe impl Send for ParamsLower {}
      

      use wit_bindgen::rt::async_support::Subtask as _Subtask;
      struct _MySubtask<'a> { _unused: core::marker::PhantomData<&'a ()> }
      #[allow(unused_parens)]
      unsafe impl<'a> _Subtask for _MySubtask<'a> {
        
        type Params = (&'a Device, _rt::String, );
        type Results = Result<(),DeviceError>;
        type ParamsLower = ParamsLower;
        fn abi_layout(&mut self) -> ::core::alloc::Layout {
          unsafe {
            ::core::alloc::Layout::from_size_align_unchecked(2, 1)
          }
        }
        
        fn results_offset(&mut self) -> usize { 0 }

        unsafe fn call_import(&mut self, _params: Self::ParamsLower, _results: *mut u8) -> u32 {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "igloo:lib/extension-sp-to-igloo@0.1.0")]
          unsafe extern "C" {
            #[link_name = "[async-lower][method]device.remove-cfg"]
            fn call(_: i32, _: *mut u8, _: usize, _: *mut u8, ) -> i32;
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn call(_: i32, _: *mut u8, _: usize, _: *mut u8, ) -> i32 { unreachable!() }
          
          unsafe { call(_params.0,_params.1,_params.2,_results) as u32 }
        }
        
        unsafe fn params_dealloc_lists(&mut self, _params: Self::ParamsLower) {
          unsafe { _rt::cabi_dealloc(_params.1, _params.2, 1);
        }
      }
      unsafe fn params_dealloc_lists_and_own(&mut self, _params: Self::ParamsLower) {
        unsafe { _rt::cabi_dealloc(_params.1, _params.2, 1);
      }
    }
    unsafe fn params_lower(&mut self, (_lower0, _lower1,): Self::Params, _ptr: *mut u8) -> Self::ParamsLower {
      unsafe { let vec0 = (_lower1.into_bytes()).into_boxed_slice();
      let ptr0 = vec0.as_ptr().cast::<u8>();
      let len0 = vec0.len();
      ::core::mem::forget(vec0);
      ParamsLower((_lower0).handle() as i32, ptr0.cast_mut(), len0,) }
    }
    unsafe fn results_lift(&mut self, _ptr: *mut u8) -> Self::Results {
      unsafe { let l0 = i32::from(*_ptr.add(0).cast::<u8>());

      match l0 {
        0 => {
          let e = ();
          Ok(e)
        }
        1 => {
          let e = {
            let l1 = i32::from(*_ptr.add(1).cast::<u8>());

            DeviceError::_lift(l1 as u8)
          };
          Err(e)
        }
        _ => _rt::invalid_enum_discriminant(),
      } }
    }
  }
  _MySubtask { _unused: core::marker::PhantomData }.call((self, key,)).await
}
}
}
impl Device {
  #[allow(unused_unsafe, clippy::all)]
  /// Register an entity under this device
  /// Fails if the device is invalid
  #[allow(async_fn_in_trait)]
  pub async fn register_entity(&self,id: EntityId,) -> Result<Entity,DeviceError>{
    unsafe {

      #[derive(Copy, Clone)]
      struct ParamsLower(
      i32, *mut u8, usize, 
      );
      unsafe impl Send for ParamsLower {}
      

      use wit_bindgen::rt::async_support::Subtask as _Subtask;
      struct _MySubtask<'a> { _unused: core::marker::PhantomData<&'a ()> }
      #[allow(unused_parens)]
      unsafe impl<'a> _Subtask for _MySubtask<'a> {
        
        type Params = (&'a Device, EntityId, );
        type Results = Result<Entity,DeviceError>;
        type ParamsLower = ParamsLower;
        fn abi_layout(&mut self) -> ::core::alloc::Layout {
          unsafe {
            ::core::alloc::Layout::from_size_align_unchecked(8, 4)
          }
        }
        
        fn results_offset(&mut self) -> usize { 0 }

        unsafe fn call_import(&mut self, _params: Self::ParamsLower, _results: *mut u8) -> u32 {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "igloo:lib/extension-sp-to-igloo@0.1.0")]
          unsafe extern "C" {
            #[link_name = "[async-lower][method]device.register-entity"]
            fn call(_: i32, _: *mut u8, _: usize, _: *mut u8, ) -> i32;
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn call(_: i32, _: *mut u8, _: usize, _: *mut u8, ) -> i32 { unreachable!() }
          
          unsafe { call(_params.0,_params.1,_params.2,_results) as u32 }
        }
        
        unsafe fn params_dealloc_lists(&mut self, _params: Self::ParamsLower) {
          unsafe { _rt::cabi_dealloc(_params.1, _params.2, 1);
        }
      }
      unsafe fn params_dealloc_lists_and_own(&mut self, _params: Self::ParamsLower) {
        unsafe { _rt::cabi_dealloc(_params.1, _params.2, 1);
      }
    }
    unsafe fn params_lower(&mut self, (_lower0, _lower1,): Self::Params, _ptr: *mut u8) -> Self::ParamsLower {
      unsafe { let super::super::super::__with_name0::EntityId{ inner:inner0, } = _lower1;
      let vec1 = (inner0.into_bytes()).into_boxed_slice();
      let ptr1 = vec1.as_ptr().cast::<u8>();
      let len1 = vec1.len();
      ::core::mem::forget(vec1);
      ParamsLower((_lower0).handle() as i32, ptr1.cast_mut(), len1,) }
    }
    unsafe fn results_lift(&mut self, _ptr: *mut u8) -> Self::Results {
      unsafe { let l0 = i32::from(*_ptr.add(0).cast::<u8>());

      match l0 {
        0 => {
          let e = {
            let l1 = *_ptr.add(4).cast::<i32>();

            super::super::super::igloo::lib::entity::Entity::from_handle(l1 as u32)
          };
          Ok(e)
        }
        1 => {
          let e = {
            let l2 = i32::from(*_ptr.add(4).cast::<u8>());

            DeviceError::_lift(l2 as u8)
          };
          Err(e)
        }
        _ => _rt::invalid_enum_discriminant(),
      } }
    }
  }
  _MySubtask { _unused: core::marker::PhantomData }.call((self, id,)).await
}
}
}

}

}
}
#[allow(dead_code, clippy::all)]
pub mod wasi {
  pub mod cli {

    #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
    pub mod environment {
      #[used]
      #[doc(hidden)]
      static __FORCE_SECTION_REF: fn() =
      super::super::super::__link_custom_section_describing_imports;
      
      use super::super::super::_rt;
      #[allow(unused_unsafe, clippy::all)]
      /// Get the POSIX-style environment variables.
      ///
      /// Each environment variable is provided as a pair of string variable names
      /// and string value.
      ///
      /// Morally, these are a value import, but until value imports are available
      /// in the component model, this import function should return the same
      /// values each time it is called.
      #[allow(async_fn_in_trait)]
      pub async fn get_environment() -> _rt::Vec::<(_rt::String,_rt::String,)>{
        unsafe {

          #[derive(Copy, Clone)]
          struct ParamsLower(
          
          );
          unsafe impl Send for ParamsLower {}
          

          use wit_bindgen::rt::async_support::Subtask as _Subtask;
          struct _MySubtask<'a> { _unused: core::marker::PhantomData<&'a ()> }
          #[allow(unused_parens)]
          unsafe impl<'a> _Subtask for _MySubtask<'a> {
            
            type Params = ();
            type Results = _rt::Vec::<(_rt::String,_rt::String,)>;
            type ParamsLower = ParamsLower;
            fn abi_layout(&mut self) -> ::core::alloc::Layout {
              unsafe {
                ::core::alloc::Layout::from_size_align_unchecked((2*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>())
              }
            }
            
            fn results_offset(&mut self) -> usize { 0 }

            unsafe fn call_import(&mut self, _params: Self::ParamsLower, _results: *mut u8) -> u32 {
              
              #[cfg(target_arch = "wasm32")]
              #[link(wasm_import_module = "wasi:cli/environment@0.3.0-rc-2026-01-06")]
              unsafe extern "C" {
                #[link_name = "[async-lower]get-environment"]
                fn call(_: *mut u8, ) -> i32;
              }

              #[cfg(not(target_arch = "wasm32"))]
              unsafe extern "C" fn call(_: *mut u8, ) -> i32 { unreachable!() }
              
              unsafe { call(_results) as u32 }
            }
            
            unsafe fn params_dealloc_lists(&mut self, _params: Self::ParamsLower) {
              unsafe {  }
            }
            unsafe fn params_dealloc_lists_and_own(&mut self, _params: Self::ParamsLower) {
              unsafe {  }
            }
            unsafe fn params_lower(&mut self, (): Self::Params, _ptr: *mut u8) -> Self::ParamsLower {
              unsafe {  ParamsLower() }
            }
            unsafe fn results_lift(&mut self, _ptr: *mut u8) -> Self::Results {
              unsafe { let l0 = *_ptr.add(0).cast::<*mut u8>();
              let l1 = *_ptr.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
              let base8 = l0;
              let len8 = l1;
              let mut result8 = _rt::Vec::with_capacity(len8);
              for i in 0..len8 {
                let base = base8.add(i * (4*::core::mem::size_of::<*const u8>()));
                let e8 = {
                  let l2 = *base.add(0).cast::<*mut u8>();
                  let l3 = *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
                  let len4 = l3;
                  let bytes4 = _rt::Vec::from_raw_parts(l2.cast(), len4, len4);
                  let l5 = *base.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                  let l6 = *base.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>();
                  let len7 = l6;
                  let bytes7 = _rt::Vec::from_raw_parts(l5.cast(), len7, len7);

                  (_rt::string_lift(bytes4), _rt::string_lift(bytes7))
                };
                result8.push(e8);
              }
              _rt::cabi_dealloc(base8, len8 * (4*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>());

              result8 }
            }
          }
          _MySubtask { _unused: core::marker::PhantomData }.call(()).await
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Get the POSIX-style arguments to the program.
      #[allow(async_fn_in_trait)]
      pub async fn get_arguments() -> _rt::Vec::<_rt::String>{
        unsafe {

          #[derive(Copy, Clone)]
          struct ParamsLower(
          
          );
          unsafe impl Send for ParamsLower {}
          

          use wit_bindgen::rt::async_support::Subtask as _Subtask;
          struct _MySubtask<'a> { _unused: core::marker::PhantomData<&'a ()> }
          #[allow(unused_parens)]
          unsafe impl<'a> _Subtask for _MySubtask<'a> {
            
            type Params = ();
            type Results = _rt::Vec::<_rt::String>;
            type ParamsLower = ParamsLower;
            fn abi_layout(&mut self) -> ::core::alloc::Layout {
              unsafe {
                ::core::alloc::Layout::from_size_align_unchecked((2*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>())
              }
            }
            
            fn results_offset(&mut self) -> usize { 0 }

            unsafe fn call_import(&mut self, _params: Self::ParamsLower, _results: *mut u8) -> u32 {
              
              #[cfg(target_arch = "wasm32")]
              #[link(wasm_import_module = "wasi:cli/environment@0.3.0-rc-2026-01-06")]
              unsafe extern "C" {
                #[link_name = "[async-lower]get-arguments"]
                fn call(_: *mut u8, ) -> i32;
              }

              #[cfg(not(target_arch = "wasm32"))]
              unsafe extern "C" fn call(_: *mut u8, ) -> i32 { unreachable!() }
              
              unsafe { call(_results) as u32 }
            }
            
            unsafe fn params_dealloc_lists(&mut self, _params: Self::ParamsLower) {
              unsafe {  }
            }
            unsafe fn params_dealloc_lists_and_own(&mut self, _params: Self::ParamsLower) {
              unsafe {  }
            }
            unsafe fn params_lower(&mut self, (): Self::Params, _ptr: *mut u8) -> Self::ParamsLower {
              unsafe {  ParamsLower() }
            }
            unsafe fn results_lift(&mut self, _ptr: *mut u8) -> Self::Results {
              unsafe { let l0 = *_ptr.add(0).cast::<*mut u8>();
              let l1 = *_ptr.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
              let base5 = l0;
              let len5 = l1;
              let mut result5 = _rt::Vec::with_capacity(len5);
              for i in 0..len5 {
                let base = base5.add(i * (2*::core::mem::size_of::<*const u8>()));
                let e5 = {
                  let l2 = *base.add(0).cast::<*mut u8>();
                  let l3 = *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
                  let len4 = l3;
                  let bytes4 = _rt::Vec::from_raw_parts(l2.cast(), len4, len4);

                  _rt::string_lift(bytes4)
                };
                result5.push(e5);
              }
              _rt::cabi_dealloc(base5, len5 * (2*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>());

              result5 }
            }
          }
          _MySubtask { _unused: core::marker::PhantomData }.call(()).await
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Return a path that programs should use as their initial current working
      /// directory, interpreting `.` as shorthand for this.
      #[allow(async_fn_in_trait)]
      pub async fn get_initial_cwd() -> Option<_rt::String>{
        unsafe {

          #[derive(Copy, Clone)]
          struct ParamsLower(
          
          );
          unsafe impl Send for ParamsLower {}
          

          use wit_bindgen::rt::async_support::Subtask as _Subtask;
          struct _MySubtask<'a> { _unused: core::marker::PhantomData<&'a ()> }
          #[allow(unused_parens)]
          unsafe impl<'a> _Subtask for _MySubtask<'a> {
            
            type Params = ();
            type Results = Option<_rt::String>;
            type ParamsLower = ParamsLower;
            fn abi_layout(&mut self) -> ::core::alloc::Layout {
              unsafe {
                ::core::alloc::Layout::from_size_align_unchecked((3*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>())
              }
            }
            
            fn results_offset(&mut self) -> usize { 0 }

            unsafe fn call_import(&mut self, _params: Self::ParamsLower, _results: *mut u8) -> u32 {
              
              #[cfg(target_arch = "wasm32")]
              #[link(wasm_import_module = "wasi:cli/environment@0.3.0-rc-2026-01-06")]
              unsafe extern "C" {
                #[link_name = "[async-lower]get-initial-cwd"]
                fn call(_: *mut u8, ) -> i32;
              }

              #[cfg(not(target_arch = "wasm32"))]
              unsafe extern "C" fn call(_: *mut u8, ) -> i32 { unreachable!() }
              
              unsafe { call(_results) as u32 }
            }
            
            unsafe fn params_dealloc_lists(&mut self, _params: Self::ParamsLower) {
              unsafe {  }
            }
            unsafe fn params_dealloc_lists_and_own(&mut self, _params: Self::ParamsLower) {
              unsafe {  }
            }
            unsafe fn params_lower(&mut self, (): Self::Params, _ptr: *mut u8) -> Self::ParamsLower {
              unsafe {  ParamsLower() }
            }
            unsafe fn results_lift(&mut self, _ptr: *mut u8) -> Self::Results {
              unsafe { let l0 = i32::from(*_ptr.add(0).cast::<u8>());

              match l0 {
                0 => None,
                1 => {
                  let e = {
                    let l1 = *_ptr.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                    let l2 = *_ptr.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>();
                    let len3 = l2;
                    let bytes3 = _rt::Vec::from_raw_parts(l1.cast(), len3, len3);

                    _rt::string_lift(bytes3)
                  };
                  Some(e)
                }
                _ => _rt::invalid_enum_discriminant(),
              } }
            }
          }
          _MySubtask { _unused: core::marker::PhantomData }.call(()).await
        }
      }

    }


    #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
    pub mod exit {
      #[used]
      #[doc(hidden)]
      static __FORCE_SECTION_REF: fn() =
      super::super::super::__link_custom_section_describing_imports;
      
      #[allow(unused_unsafe, clippy::all)]
      /// Exit the current instance and any linked instances.
      #[allow(async_fn_in_trait)]
      pub async fn exit(status: Result<(),()>,) -> (){
        unsafe {

          #[derive(Copy, Clone)]
          struct ParamsLower(
          i32, 
          );
          unsafe impl Send for ParamsLower {}
          

          use wit_bindgen::rt::async_support::Subtask as _Subtask;
          struct _MySubtask<'a> { _unused: core::marker::PhantomData<&'a ()> }
          #[allow(unused_parens)]
          unsafe impl<'a> _Subtask for _MySubtask<'a> {
            
            type Params = (Result<(),()>, );
            type Results = ();
            type ParamsLower = ParamsLower;
            fn abi_layout(&mut self) -> ::core::alloc::Layout {
              unsafe {
                ::core::alloc::Layout::from_size_align_unchecked(0, 1)
              }
            }
            
            fn results_offset(&mut self) -> usize { 0 }

            unsafe fn call_import(&mut self, _params: Self::ParamsLower, _results: *mut u8) -> u32 {
              
              #[cfg(target_arch = "wasm32")]
              #[link(wasm_import_module = "wasi:cli/exit@0.3.0-rc-2026-01-06")]
              unsafe extern "C" {
                #[link_name = "[async-lower]exit"]
                fn call(_: i32, ) -> i32;
              }

              #[cfg(not(target_arch = "wasm32"))]
              unsafe extern "C" fn call(_: i32, ) -> i32 { unreachable!() }
              
              unsafe { call(_params.0,) as u32 }
            }
            
            unsafe fn params_dealloc_lists(&mut self, _params: Self::ParamsLower) {
              unsafe { match _params.0 {
                0 => (),
                _ => (),
              }
            }
          }
          unsafe fn params_dealloc_lists_and_own(&mut self, _params: Self::ParamsLower) {
            unsafe { match _params.0 {
              0 => (),
              _ => (),
            }
          }
        }
        unsafe fn params_lower(&mut self, (_lower0,): Self::Params, _ptr: *mut u8) -> Self::ParamsLower {
          unsafe { let result0 = match _lower0 {
            Ok(_) => { 0i32 },
            Err(_) => { 1i32 },
          }; ParamsLower(result0,) }
        }
        unsafe fn results_lift(&mut self, _ptr: *mut u8) -> Self::Results {

        }
      }
      _MySubtask { _unused: core::marker::PhantomData }.call((status,)).await
    }
  }

}


#[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
pub mod types {
  #[used]
  #[doc(hidden)]
  static __FORCE_SECTION_REF: fn() =
  super::super::super::__link_custom_section_describing_imports;
  
  #[repr(u8)]
  #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd, serde::Deserialize, serde::Serialize)]
  pub enum ErrorCode {
    /// Input/output error
    Io,
    /// Invalid or incomplete multibyte or wide character
    IllegalByteSequence,
    /// Broken pipe
    Pipe,
  }
  impl ErrorCode{
    pub fn name(&self) -> &'static str {
      match self {
        ErrorCode::Io => "io",
        ErrorCode::IllegalByteSequence => "illegal-byte-sequence",
        ErrorCode::Pipe => "pipe",
      }
    }
    pub fn message(&self) -> &'static str {
      match self {
        ErrorCode::Io => "Input/output error",
        ErrorCode::IllegalByteSequence => "Invalid or incomplete multibyte or wide character",
        ErrorCode::Pipe => "Broken pipe",
      }
    }
  }
  impl ::core::fmt::Debug for ErrorCode{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
      f.debug_struct("ErrorCode")
      .field("code", &(*self as i32))
      .field("name", &self.name())
      .field("message", &self.message())
      .finish()
    }
  }
  impl ::core::fmt::Display for ErrorCode{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
      write!(f, "{} (error {})", self.name(), *self as i32)
    }
  }

  impl ::core::error::Error for ErrorCode {}

  impl ErrorCode{
    #[doc(hidden)]
    pub unsafe fn _lift(val: u8) -> ErrorCode{
      if !cfg!(debug_assertions) {
        return unsafe { ::core::mem::transmute(val) };
      }

      match val {
        0 => ErrorCode::Io,
        1 => ErrorCode::IllegalByteSequence,
        2 => ErrorCode::Pipe,

        _ => panic!("invalid enum discriminant"),
      }
    }
  }


}


#[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
pub mod stdin {
  #[used]
  #[doc(hidden)]
  static __FORCE_SECTION_REF: fn() =
  super::super::super::__link_custom_section_describing_imports;
  
  use super::super::super::_rt;
  pub type ErrorCode = super::super::super::wasi::cli::types::ErrorCode;
  #[allow(unused_unsafe, clippy::all)]
  /// Return a stream for reading from stdin.
  ///
  /// This function returns a stream which provides data read from stdin,
  /// and a future to signal read results.
  ///
  /// If the stream's readable end is dropped the future will resolve to success.
  ///
  /// If the stream's writable end is dropped the future will either resolve to
  /// success if stdin was closed by the writer or to an error-code if reading
  /// failed for some other reason.
  ///
  /// Multiple streams may be active at the same time. The behavior of concurrent
  /// reads is implementation-specific.
  #[allow(async_fn_in_trait)]
  pub async fn read_via_stream() -> (wit_bindgen::rt::async_support::StreamReader<u8>,wit_bindgen::rt::async_support::FutureReader<Result<(),ErrorCode>>,){
    unsafe {

      #[derive(Copy, Clone)]
      struct ParamsLower(
      
      );
      unsafe impl Send for ParamsLower {}
      

      use wit_bindgen::rt::async_support::Subtask as _Subtask;
      struct _MySubtask<'a> { _unused: core::marker::PhantomData<&'a ()> }
      #[allow(unused_parens)]
      unsafe impl<'a> _Subtask for _MySubtask<'a> {
        
        type Params = ();
        type Results = (wit_bindgen::rt::async_support::StreamReader<u8>,wit_bindgen::rt::async_support::FutureReader<Result<(),ErrorCode>>,);
        type ParamsLower = ParamsLower;
        fn abi_layout(&mut self) -> ::core::alloc::Layout {
          unsafe {
            ::core::alloc::Layout::from_size_align_unchecked(8, 4)
          }
        }
        
        fn results_offset(&mut self) -> usize { 0 }

        unsafe fn call_import(&mut self, _params: Self::ParamsLower, _results: *mut u8) -> u32 {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:cli/stdin@0.3.0-rc-2026-01-06")]
          unsafe extern "C" {
            #[link_name = "[async-lower]read-via-stream"]
            fn call(_: *mut u8, ) -> i32;
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn call(_: *mut u8, ) -> i32 { unreachable!() }
          
          unsafe { call(_results) as u32 }
        }
        
        unsafe fn params_dealloc_lists(&mut self, _params: Self::ParamsLower) {
          unsafe {  }
        }
        unsafe fn params_dealloc_lists_and_own(&mut self, _params: Self::ParamsLower) {
          unsafe {  }
        }
        unsafe fn params_lower(&mut self, (): Self::Params, _ptr: *mut u8) -> Self::ParamsLower {
          unsafe {  ParamsLower() }
        }
        unsafe fn results_lift(&mut self, _ptr: *mut u8) -> Self::Results {
          unsafe { let l0 = *_ptr.add(0).cast::<i32>();
          let l1 = *_ptr.add(4).cast::<i32>();

          (wit_bindgen::rt::async_support::StreamReader::new(l0 as u32, &super::super::super::wit_stream::vtable0::VTABLE), wit_bindgen::rt::async_support::FutureReader::new(l1 as u32, &super::super::super::wit_future::vtable0::VTABLE)) }
        }
      }
      _MySubtask { _unused: core::marker::PhantomData }.call(()).await
    }
  }

}


#[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
pub mod stdout {
  #[used]
  #[doc(hidden)]
  static __FORCE_SECTION_REF: fn() =
  super::super::super::__link_custom_section_describing_imports;
  
  use super::super::super::_rt;
  pub type ErrorCode = super::super::super::wasi::cli::types::ErrorCode;
  #[allow(unused_unsafe, clippy::all)]
  /// Write the given stream to stdout.
  ///
  /// If the stream's writable end is dropped this function will either return
  /// success once the entire contents of the stream have been written or an
  /// error-code representing a failure.
  ///
  /// Otherwise if there is an error the readable end of the stream will be
  /// dropped and this function will return an error-code.
  #[allow(async_fn_in_trait)]
  pub async fn write_via_stream(data: wit_bindgen::rt::async_support::StreamReader<u8>,) -> Result<(),ErrorCode>{
    unsafe {

      #[derive(Copy, Clone)]
      struct ParamsLower(
      i32, 
      );
      unsafe impl Send for ParamsLower {}
      

      use wit_bindgen::rt::async_support::Subtask as _Subtask;
      struct _MySubtask<'a> { _unused: core::marker::PhantomData<&'a ()> }
      #[allow(unused_parens)]
      unsafe impl<'a> _Subtask for _MySubtask<'a> {
        
        type Params = (wit_bindgen::rt::async_support::StreamReader<u8>, );
        type Results = Result<(),ErrorCode>;
        type ParamsLower = ParamsLower;
        fn abi_layout(&mut self) -> ::core::alloc::Layout {
          unsafe {
            ::core::alloc::Layout::from_size_align_unchecked(2, 1)
          }
        }
        
        fn results_offset(&mut self) -> usize { 0 }

        unsafe fn call_import(&mut self, _params: Self::ParamsLower, _results: *mut u8) -> u32 {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:cli/stdout@0.3.0-rc-2026-01-06")]
          unsafe extern "C" {
            #[link_name = "[async-lower]write-via-stream"]
            fn call(_: i32, _: *mut u8, ) -> i32;
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn call(_: i32, _: *mut u8, ) -> i32 { unreachable!() }
          
          unsafe { call(_params.0,_results) as u32 }
        }
        
        unsafe fn params_dealloc_lists(&mut self, _params: Self::ParamsLower) {
          unsafe {  }
        }
        unsafe fn params_dealloc_lists_and_own(&mut self, _params: Self::ParamsLower) {
          unsafe { let _ = wit_bindgen::rt::async_support::StreamReader::new(_params.0 as u32, &super::super::super::wit_stream::vtable0::VTABLE);
        }
      }
      unsafe fn params_lower(&mut self, (_lower0,): Self::Params, _ptr: *mut u8) -> Self::ParamsLower {
        unsafe {  ParamsLower((_lower0).take_handle() as i32,) }
      }
      unsafe fn results_lift(&mut self, _ptr: *mut u8) -> Self::Results {
        unsafe { let l0 = i32::from(*_ptr.add(0).cast::<u8>());

        match l0 {
          0 => {
            let e = ();
            Ok(e)
          }
          1 => {
            let e = {
              let l1 = i32::from(*_ptr.add(1).cast::<u8>());

              super::super::super::wasi::cli::types::ErrorCode::_lift(l1 as u8)
            };
            Err(e)
          }
          _ => _rt::invalid_enum_discriminant(),
        } }
      }
    }
    _MySubtask { _unused: core::marker::PhantomData }.call((data,)).await
  }
}

}


#[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
pub mod stderr {
  #[used]
  #[doc(hidden)]
  static __FORCE_SECTION_REF: fn() =
  super::super::super::__link_custom_section_describing_imports;
  
  use super::super::super::_rt;
  pub type ErrorCode = super::super::super::wasi::cli::types::ErrorCode;
  #[allow(unused_unsafe, clippy::all)]
  /// Write the given stream to stderr.
  ///
  /// If the stream's writable end is dropped this function will either return
  /// success once the entire contents of the stream have been written or an
  /// error-code representing a failure.
  ///
  /// Otherwise if there is an error the readable end of the stream will be
  /// dropped and this function will return an error-code.
  #[allow(async_fn_in_trait)]
  pub async fn write_via_stream(data: wit_bindgen::rt::async_support::StreamReader<u8>,) -> Result<(),ErrorCode>{
    unsafe {

      #[derive(Copy, Clone)]
      struct ParamsLower(
      i32, 
      );
      unsafe impl Send for ParamsLower {}
      

      use wit_bindgen::rt::async_support::Subtask as _Subtask;
      struct _MySubtask<'a> { _unused: core::marker::PhantomData<&'a ()> }
      #[allow(unused_parens)]
      unsafe impl<'a> _Subtask for _MySubtask<'a> {
        
        type Params = (wit_bindgen::rt::async_support::StreamReader<u8>, );
        type Results = Result<(),ErrorCode>;
        type ParamsLower = ParamsLower;
        fn abi_layout(&mut self) -> ::core::alloc::Layout {
          unsafe {
            ::core::alloc::Layout::from_size_align_unchecked(2, 1)
          }
        }
        
        fn results_offset(&mut self) -> usize { 0 }

        unsafe fn call_import(&mut self, _params: Self::ParamsLower, _results: *mut u8) -> u32 {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:cli/stderr@0.3.0-rc-2026-01-06")]
          unsafe extern "C" {
            #[link_name = "[async-lower]write-via-stream"]
            fn call(_: i32, _: *mut u8, ) -> i32;
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn call(_: i32, _: *mut u8, ) -> i32 { unreachable!() }
          
          unsafe { call(_params.0,_results) as u32 }
        }
        
        unsafe fn params_dealloc_lists(&mut self, _params: Self::ParamsLower) {
          unsafe {  }
        }
        unsafe fn params_dealloc_lists_and_own(&mut self, _params: Self::ParamsLower) {
          unsafe { let _ = wit_bindgen::rt::async_support::StreamReader::new(_params.0 as u32, &super::super::super::wit_stream::vtable0::VTABLE);
        }
      }
      unsafe fn params_lower(&mut self, (_lower0,): Self::Params, _ptr: *mut u8) -> Self::ParamsLower {
        unsafe {  ParamsLower((_lower0).take_handle() as i32,) }
      }
      unsafe fn results_lift(&mut self, _ptr: *mut u8) -> Self::Results {
        unsafe { let l0 = i32::from(*_ptr.add(0).cast::<u8>());

        match l0 {
          0 => {
            let e = ();
            Ok(e)
          }
          1 => {
            let e = {
              let l1 = i32::from(*_ptr.add(1).cast::<u8>());

              super::super::super::wasi::cli::types::ErrorCode::_lift(l1 as u8)
            };
            Err(e)
          }
          _ => _rt::invalid_enum_discriminant(),
        } }
      }
    }
    _MySubtask { _unused: core::marker::PhantomData }.call((data,)).await
  }
}

}

/// Terminal input.
///
/// In the future, this may include functions for disabling echoing,
/// disabling input buffering so that keyboard events are sent through
/// immediately, querying supported features, and so on.
#[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
pub mod terminal_input {
  #[used]
  #[doc(hidden)]
  static __FORCE_SECTION_REF: fn() =
  super::super::super::__link_custom_section_describing_imports;
  
  use super::super::super::_rt;
  /// The input side of a terminal.

  #[derive(Debug)]
  #[repr(transparent)]
  pub struct TerminalInput{
    handle: _rt::Resource<TerminalInput>,
  }

  impl TerminalInput{
    #[doc(hidden)]
    pub unsafe fn from_handle(handle: u32) -> Self {
      Self {
        handle: unsafe { _rt::Resource::from_handle(handle) },
      }
    }

    #[doc(hidden)]
    pub fn take_handle(&self) -> u32 {
      _rt::Resource::take_handle(&self.handle)
    }

    #[doc(hidden)]
    pub fn handle(&self) -> u32 {
      _rt::Resource::handle(&self.handle)
    }
  }
  

  unsafe impl _rt::WasmResource for TerminalInput{
    #[inline]
    unsafe fn drop(_handle: u32) {
      
      #[cfg(target_arch = "wasm32")]
      #[link(wasm_import_module = "wasi:cli/terminal-input@0.3.0-rc-2026-01-06")]
      unsafe extern "C" {
        #[link_name = "[resource-drop]terminal-input"]
        fn drop(_: i32, );
      }

      #[cfg(not(target_arch = "wasm32"))]
      unsafe extern "C" fn drop(_: i32, ) { unreachable!() }
      
      unsafe { drop(_handle as i32); }
    }
  }
  

}

/// Terminal output.
///
/// In the future, this may include functions for querying the terminal
/// size, being notified of terminal size changes, querying supported
/// features, and so on.
#[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
pub mod terminal_output {
  #[used]
  #[doc(hidden)]
  static __FORCE_SECTION_REF: fn() =
  super::super::super::__link_custom_section_describing_imports;
  
  use super::super::super::_rt;
  /// The output side of a terminal.

  #[derive(Debug)]
  #[repr(transparent)]
  pub struct TerminalOutput{
    handle: _rt::Resource<TerminalOutput>,
  }

  impl TerminalOutput{
    #[doc(hidden)]
    pub unsafe fn from_handle(handle: u32) -> Self {
      Self {
        handle: unsafe { _rt::Resource::from_handle(handle) },
      }
    }

    #[doc(hidden)]
    pub fn take_handle(&self) -> u32 {
      _rt::Resource::take_handle(&self.handle)
    }

    #[doc(hidden)]
    pub fn handle(&self) -> u32 {
      _rt::Resource::handle(&self.handle)
    }
  }
  

  unsafe impl _rt::WasmResource for TerminalOutput{
    #[inline]
    unsafe fn drop(_handle: u32) {
      
      #[cfg(target_arch = "wasm32")]
      #[link(wasm_import_module = "wasi:cli/terminal-output@0.3.0-rc-2026-01-06")]
      unsafe extern "C" {
        #[link_name = "[resource-drop]terminal-output"]
        fn drop(_: i32, );
      }

      #[cfg(not(target_arch = "wasm32"))]
      unsafe extern "C" fn drop(_: i32, ) { unreachable!() }
      
      unsafe { drop(_handle as i32); }
    }
  }
  

}

/// An interface providing an optional `terminal-input` for stdin as a
/// link-time authority.
#[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
pub mod terminal_stdin {
  #[used]
  #[doc(hidden)]
  static __FORCE_SECTION_REF: fn() =
  super::super::super::__link_custom_section_describing_imports;
  
  use super::super::super::_rt;
  pub type TerminalInput = super::super::super::wasi::cli::terminal_input::TerminalInput;
  #[allow(unused_unsafe, clippy::all)]
  /// If stdin is connected to a terminal, return a `terminal-input` handle
  /// allowing further interaction with it.
  #[allow(async_fn_in_trait)]
  pub async fn get_terminal_stdin() -> Option<TerminalInput>{
    unsafe {

      #[derive(Copy, Clone)]
      struct ParamsLower(
      
      );
      unsafe impl Send for ParamsLower {}
      

      use wit_bindgen::rt::async_support::Subtask as _Subtask;
      struct _MySubtask<'a> { _unused: core::marker::PhantomData<&'a ()> }
      #[allow(unused_parens)]
      unsafe impl<'a> _Subtask for _MySubtask<'a> {
        
        type Params = ();
        type Results = Option<TerminalInput>;
        type ParamsLower = ParamsLower;
        fn abi_layout(&mut self) -> ::core::alloc::Layout {
          unsafe {
            ::core::alloc::Layout::from_size_align_unchecked(8, 4)
          }
        }
        
        fn results_offset(&mut self) -> usize { 0 }

        unsafe fn call_import(&mut self, _params: Self::ParamsLower, _results: *mut u8) -> u32 {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:cli/terminal-stdin@0.3.0-rc-2026-01-06")]
          unsafe extern "C" {
            #[link_name = "[async-lower]get-terminal-stdin"]
            fn call(_: *mut u8, ) -> i32;
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn call(_: *mut u8, ) -> i32 { unreachable!() }
          
          unsafe { call(_results) as u32 }
        }
        
        unsafe fn params_dealloc_lists(&mut self, _params: Self::ParamsLower) {
          unsafe {  }
        }
        unsafe fn params_dealloc_lists_and_own(&mut self, _params: Self::ParamsLower) {
          unsafe {  }
        }
        unsafe fn params_lower(&mut self, (): Self::Params, _ptr: *mut u8) -> Self::ParamsLower {
          unsafe {  ParamsLower() }
        }
        unsafe fn results_lift(&mut self, _ptr: *mut u8) -> Self::Results {
          unsafe { let l0 = i32::from(*_ptr.add(0).cast::<u8>());

          match l0 {
            0 => None,
            1 => {
              let e = {
                let l1 = *_ptr.add(4).cast::<i32>();

                super::super::super::wasi::cli::terminal_input::TerminalInput::from_handle(l1 as u32)
              };
              Some(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          } }
        }
      }
      _MySubtask { _unused: core::marker::PhantomData }.call(()).await
    }
  }

}

/// An interface providing an optional `terminal-output` for stdout as a
/// link-time authority.
#[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
pub mod terminal_stdout {
  #[used]
  #[doc(hidden)]
  static __FORCE_SECTION_REF: fn() =
  super::super::super::__link_custom_section_describing_imports;
  
  use super::super::super::_rt;
  pub type TerminalOutput = super::super::super::wasi::cli::terminal_output::TerminalOutput;
  #[allow(unused_unsafe, clippy::all)]
  /// If stdout is connected to a terminal, return a `terminal-output` handle
  /// allowing further interaction with it.
  #[allow(async_fn_in_trait)]
  pub async fn get_terminal_stdout() -> Option<TerminalOutput>{
    unsafe {

      #[derive(Copy, Clone)]
      struct ParamsLower(
      
      );
      unsafe impl Send for ParamsLower {}
      

      use wit_bindgen::rt::async_support::Subtask as _Subtask;
      struct _MySubtask<'a> { _unused: core::marker::PhantomData<&'a ()> }
      #[allow(unused_parens)]
      unsafe impl<'a> _Subtask for _MySubtask<'a> {
        
        type Params = ();
        type Results = Option<TerminalOutput>;
        type ParamsLower = ParamsLower;
        fn abi_layout(&mut self) -> ::core::alloc::Layout {
          unsafe {
            ::core::alloc::Layout::from_size_align_unchecked(8, 4)
          }
        }
        
        fn results_offset(&mut self) -> usize { 0 }

        unsafe fn call_import(&mut self, _params: Self::ParamsLower, _results: *mut u8) -> u32 {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:cli/terminal-stdout@0.3.0-rc-2026-01-06")]
          unsafe extern "C" {
            #[link_name = "[async-lower]get-terminal-stdout"]
            fn call(_: *mut u8, ) -> i32;
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn call(_: *mut u8, ) -> i32 { unreachable!() }
          
          unsafe { call(_results) as u32 }
        }
        
        unsafe fn params_dealloc_lists(&mut self, _params: Self::ParamsLower) {
          unsafe {  }
        }
        unsafe fn params_dealloc_lists_and_own(&mut self, _params: Self::ParamsLower) {
          unsafe {  }
        }
        unsafe fn params_lower(&mut self, (): Self::Params, _ptr: *mut u8) -> Self::ParamsLower {
          unsafe {  ParamsLower() }
        }
        unsafe fn results_lift(&mut self, _ptr: *mut u8) -> Self::Results {
          unsafe { let l0 = i32::from(*_ptr.add(0).cast::<u8>());

          match l0 {
            0 => None,
            1 => {
              let e = {
                let l1 = *_ptr.add(4).cast::<i32>();

                super::super::super::wasi::cli::terminal_output::TerminalOutput::from_handle(l1 as u32)
              };
              Some(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          } }
        }
      }
      _MySubtask { _unused: core::marker::PhantomData }.call(()).await
    }
  }

}

/// An interface providing an optional `terminal-output` for stderr as a
/// link-time authority.
#[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
pub mod terminal_stderr {
  #[used]
  #[doc(hidden)]
  static __FORCE_SECTION_REF: fn() =
  super::super::super::__link_custom_section_describing_imports;
  
  use super::super::super::_rt;
  pub type TerminalOutput = super::super::super::wasi::cli::terminal_output::TerminalOutput;
  #[allow(unused_unsafe, clippy::all)]
  /// If stderr is connected to a terminal, return a `terminal-output` handle
  /// allowing further interaction with it.
  #[allow(async_fn_in_trait)]
  pub async fn get_terminal_stderr() -> Option<TerminalOutput>{
    unsafe {

      #[derive(Copy, Clone)]
      struct ParamsLower(
      
      );
      unsafe impl Send for ParamsLower {}
      

      use wit_bindgen::rt::async_support::Subtask as _Subtask;
      struct _MySubtask<'a> { _unused: core::marker::PhantomData<&'a ()> }
      #[allow(unused_parens)]
      unsafe impl<'a> _Subtask for _MySubtask<'a> {
        
        type Params = ();
        type Results = Option<TerminalOutput>;
        type ParamsLower = ParamsLower;
        fn abi_layout(&mut self) -> ::core::alloc::Layout {
          unsafe {
            ::core::alloc::Layout::from_size_align_unchecked(8, 4)
          }
        }
        
        fn results_offset(&mut self) -> usize { 0 }

        unsafe fn call_import(&mut self, _params: Self::ParamsLower, _results: *mut u8) -> u32 {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:cli/terminal-stderr@0.3.0-rc-2026-01-06")]
          unsafe extern "C" {
            #[link_name = "[async-lower]get-terminal-stderr"]
            fn call(_: *mut u8, ) -> i32;
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn call(_: *mut u8, ) -> i32 { unreachable!() }
          
          unsafe { call(_results) as u32 }
        }
        
        unsafe fn params_dealloc_lists(&mut self, _params: Self::ParamsLower) {
          unsafe {  }
        }
        unsafe fn params_dealloc_lists_and_own(&mut self, _params: Self::ParamsLower) {
          unsafe {  }
        }
        unsafe fn params_lower(&mut self, (): Self::Params, _ptr: *mut u8) -> Self::ParamsLower {
          unsafe {  ParamsLower() }
        }
        unsafe fn results_lift(&mut self, _ptr: *mut u8) -> Self::Results {
          unsafe { let l0 = i32::from(*_ptr.add(0).cast::<u8>());

          match l0 {
            0 => None,
            1 => {
              let e = {
                let l1 = *_ptr.add(4).cast::<i32>();

                super::super::super::wasi::cli::terminal_output::TerminalOutput::from_handle(l1 as u32)
              };
              Some(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          } }
        }
      }
      _MySubtask { _unused: core::marker::PhantomData }.call(()).await
    }
  }

}

}
pub mod clocks {
  /// This interface common types used throughout wasi:clocks.
  #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
  pub mod types {
    #[used]
    #[doc(hidden)]
    static __FORCE_SECTION_REF: fn() =
    super::super::super::__link_custom_section_describing_imports;
    
    /// A duration of time, in nanoseconds.
    pub type Duration = u64;

  }

  /// WASI Monotonic Clock is a clock API intended to let users measure elapsed
  /// time.
  ///
  /// It is intended to be portable at least between Unix-family platforms and
  /// Windows.
  ///
  /// A monotonic clock is a clock which has an unspecified initial value, and
  /// successive reads of the clock will produce non-decreasing values.
  #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
  pub mod monotonic_clock {
    #[used]
    #[doc(hidden)]
    static __FORCE_SECTION_REF: fn() =
    super::super::super::__link_custom_section_describing_imports;
    
    use super::super::super::_rt;
    pub type Duration = super::super::super::wasi::clocks::types::Duration;
    /// A mark on a monotonic clock is a number of nanoseconds since an
    /// unspecified initial value, and can only be compared to instances from
    /// the same monotonic-clock.
    pub type Mark = u64;
    #[allow(unused_unsafe, clippy::all)]
    /// Read the current value of the clock.
    ///
    /// The clock is monotonic, therefore calling this function repeatedly will
    /// produce a sequence of non-decreasing values.
    ///
    /// For completeness, this function traps if it's not possible to represent
    /// the value of the clock in a `mark`. Consequently, implementations
    /// should ensure that the starting time is low enough to avoid the
    /// possibility of overflow in practice.
    #[allow(async_fn_in_trait)]
    pub async fn now() -> Mark{
      unsafe {

        #[derive(Copy, Clone)]
        struct ParamsLower(
        
        );
        unsafe impl Send for ParamsLower {}
        

        use wit_bindgen::rt::async_support::Subtask as _Subtask;
        struct _MySubtask<'a> { _unused: core::marker::PhantomData<&'a ()> }
        #[allow(unused_parens)]
        unsafe impl<'a> _Subtask for _MySubtask<'a> {
          
          type Params = ();
          type Results = Mark;
          type ParamsLower = ParamsLower;
          fn abi_layout(&mut self) -> ::core::alloc::Layout {
            unsafe {
              ::core::alloc::Layout::from_size_align_unchecked(8, 8)
            }
          }
          
          fn results_offset(&mut self) -> usize { 0 }

          unsafe fn call_import(&mut self, _params: Self::ParamsLower, _results: *mut u8) -> u32 {
            
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:clocks/monotonic-clock@0.3.0-rc-2026-01-06")]
            unsafe extern "C" {
              #[link_name = "[async-lower]now"]
              fn call(_: *mut u8, ) -> i32;
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn call(_: *mut u8, ) -> i32 { unreachable!() }
            
            unsafe { call(_results) as u32 }
          }
          
          unsafe fn params_dealloc_lists(&mut self, _params: Self::ParamsLower) {
            unsafe {  }
          }
          unsafe fn params_dealloc_lists_and_own(&mut self, _params: Self::ParamsLower) {
            unsafe {  }
          }
          unsafe fn params_lower(&mut self, (): Self::Params, _ptr: *mut u8) -> Self::ParamsLower {
            unsafe {  ParamsLower() }
          }
          unsafe fn results_lift(&mut self, _ptr: *mut u8) -> Self::Results {
            unsafe { let l0 = *_ptr.add(0).cast::<i64>();

            l0 as u64 }
          }
        }
        _MySubtask { _unused: core::marker::PhantomData }.call(()).await
      }
    }
    #[allow(unused_unsafe, clippy::all)]
    /// Query the resolution of the clock. Returns the duration of time
    /// corresponding to a clock tick.
    #[allow(async_fn_in_trait)]
    pub async fn get_resolution() -> Duration{
      unsafe {

        #[derive(Copy, Clone)]
        struct ParamsLower(
        
        );
        unsafe impl Send for ParamsLower {}
        

        use wit_bindgen::rt::async_support::Subtask as _Subtask;
        struct _MySubtask<'a> { _unused: core::marker::PhantomData<&'a ()> }
        #[allow(unused_parens)]
        unsafe impl<'a> _Subtask for _MySubtask<'a> {
          
          type Params = ();
          type Results = Duration;
          type ParamsLower = ParamsLower;
          fn abi_layout(&mut self) -> ::core::alloc::Layout {
            unsafe {
              ::core::alloc::Layout::from_size_align_unchecked(8, 8)
            }
          }
          
          fn results_offset(&mut self) -> usize { 0 }

          unsafe fn call_import(&mut self, _params: Self::ParamsLower, _results: *mut u8) -> u32 {
            
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:clocks/monotonic-clock@0.3.0-rc-2026-01-06")]
            unsafe extern "C" {
              #[link_name = "[async-lower]get-resolution"]
              fn call(_: *mut u8, ) -> i32;
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn call(_: *mut u8, ) -> i32 { unreachable!() }
            
            unsafe { call(_results) as u32 }
          }
          
          unsafe fn params_dealloc_lists(&mut self, _params: Self::ParamsLower) {
            unsafe {  }
          }
          unsafe fn params_dealloc_lists_and_own(&mut self, _params: Self::ParamsLower) {
            unsafe {  }
          }
          unsafe fn params_lower(&mut self, (): Self::Params, _ptr: *mut u8) -> Self::ParamsLower {
            unsafe {  ParamsLower() }
          }
          unsafe fn results_lift(&mut self, _ptr: *mut u8) -> Self::Results {
            unsafe { let l0 = *_ptr.add(0).cast::<i64>();

            l0 as u64 }
          }
        }
        _MySubtask { _unused: core::marker::PhantomData }.call(()).await
      }
    }
    #[allow(unused_unsafe, clippy::all)]
    /// Wait until the specified mark has occurred.
    #[allow(async_fn_in_trait)]
    pub async fn wait_until(when: Mark,) -> (){
      unsafe {

        #[derive(Copy, Clone)]
        struct ParamsLower(
        i64, 
        );
        unsafe impl Send for ParamsLower {}
        

        use wit_bindgen::rt::async_support::Subtask as _Subtask;
        struct _MySubtask<'a> { _unused: core::marker::PhantomData<&'a ()> }
        #[allow(unused_parens)]
        unsafe impl<'a> _Subtask for _MySubtask<'a> {
          
          type Params = (Mark, );
          type Results = ();
          type ParamsLower = ParamsLower;
          fn abi_layout(&mut self) -> ::core::alloc::Layout {
            unsafe {
              ::core::alloc::Layout::from_size_align_unchecked(0, 1)
            }
          }
          
          fn results_offset(&mut self) -> usize { 0 }

          unsafe fn call_import(&mut self, _params: Self::ParamsLower, _results: *mut u8) -> u32 {
            
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:clocks/monotonic-clock@0.3.0-rc-2026-01-06")]
            unsafe extern "C" {
              #[link_name = "[async-lower]wait-until"]
              fn call(_: i64, ) -> i32;
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn call(_: i64, ) -> i32 { unreachable!() }
            
            unsafe { call(_params.0,) as u32 }
          }
          
          unsafe fn params_dealloc_lists(&mut self, _params: Self::ParamsLower) {
            unsafe {  }
          }
          unsafe fn params_dealloc_lists_and_own(&mut self, _params: Self::ParamsLower) {
            unsafe {  }
          }
          unsafe fn params_lower(&mut self, (_lower0,): Self::Params, _ptr: *mut u8) -> Self::ParamsLower {
            unsafe {  ParamsLower(_rt::as_i64(_lower0),) }
          }
          unsafe fn results_lift(&mut self, _ptr: *mut u8) -> Self::Results {

          }
        }
        _MySubtask { _unused: core::marker::PhantomData }.call((when,)).await
      }
    }
    #[allow(unused_unsafe, clippy::all)]
    /// Wait for the specified duration to elapse.
    #[allow(async_fn_in_trait)]
    pub async fn wait_for(how_long: Duration,) -> (){
      unsafe {

        #[derive(Copy, Clone)]
        struct ParamsLower(
        i64, 
        );
        unsafe impl Send for ParamsLower {}
        

        use wit_bindgen::rt::async_support::Subtask as _Subtask;
        struct _MySubtask<'a> { _unused: core::marker::PhantomData<&'a ()> }
        #[allow(unused_parens)]
        unsafe impl<'a> _Subtask for _MySubtask<'a> {
          
          type Params = (Duration, );
          type Results = ();
          type ParamsLower = ParamsLower;
          fn abi_layout(&mut self) -> ::core::alloc::Layout {
            unsafe {
              ::core::alloc::Layout::from_size_align_unchecked(0, 1)
            }
          }
          
          fn results_offset(&mut self) -> usize { 0 }

          unsafe fn call_import(&mut self, _params: Self::ParamsLower, _results: *mut u8) -> u32 {
            
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:clocks/monotonic-clock@0.3.0-rc-2026-01-06")]
            unsafe extern "C" {
              #[link_name = "[async-lower]wait-for"]
              fn call(_: i64, ) -> i32;
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn call(_: i64, ) -> i32 { unreachable!() }
            
            unsafe { call(_params.0,) as u32 }
          }
          
          unsafe fn params_dealloc_lists(&mut self, _params: Self::ParamsLower) {
            unsafe {  }
          }
          unsafe fn params_dealloc_lists_and_own(&mut self, _params: Self::ParamsLower) {
            unsafe {  }
          }
          unsafe fn params_lower(&mut self, (_lower0,): Self::Params, _ptr: *mut u8) -> Self::ParamsLower {
            unsafe {  ParamsLower(_rt::as_i64(_lower0),) }
          }
          unsafe fn results_lift(&mut self, _ptr: *mut u8) -> Self::Results {

          }
        }
        _MySubtask { _unused: core::marker::PhantomData }.call((how_long,)).await
      }
    }

  }

  /// WASI System Clock is a clock API intended to let users query the current
  /// time. The clock is not necessarily monotonic as it may be reset.
  ///
  /// It is intended to be portable at least between Unix-family platforms and
  /// Windows.
  ///
  /// External references may be reset, so this clock is not necessarily
  /// monotonic, making it unsuitable for measuring elapsed time.
  ///
  /// It is intended for reporting the current date and time for humans.
  #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
  pub mod system_clock {
    #[used]
    #[doc(hidden)]
    static __FORCE_SECTION_REF: fn() =
    super::super::super::__link_custom_section_describing_imports;
    
    pub type Duration = super::super::super::wasi::clocks::types::Duration;
    /// An "instant", or "exact time", is a point in time without regard to any
    /// time zone: just the time since a particular external reference point,
    /// often called an "epoch".
    ///
    /// Here, the epoch is 1970-01-01T00:00:00Z, also known as
    /// [POSIX's Seconds Since the Epoch], also known as [Unix Time].
    ///
    /// Note that even if the seconds field is negative, incrementing
    /// nanoseconds always represents moving forwards in time.
    /// For example, `{ -1 seconds, 999999999 nanoseconds }` represents the
    /// instant one nanosecond before the epoch.
    /// For more on various different ways to represent time, see
    /// https://tc39.es/proposal-temporal/docs/timezone.html
    ///
    /// [POSIX's Seconds Since the Epoch]: https://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_xbd_chap04.html#tag_21_04_16
    /// [Unix Time]: https://en.wikipedia.org/wiki/Unix_time
    #[repr(C)]
    #[derive(Clone, Copy, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct Instant {
      pub seconds: i64,
      pub nanoseconds: u32,
    }
    impl ::core::fmt::Debug for Instant {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("Instant").field("seconds", &self.seconds).field("nanoseconds", &self.nanoseconds).finish()
      }
    }
    #[allow(unused_unsafe, clippy::all)]
    /// Read the current value of the clock.
    ///
    /// This clock is not monotonic, therefore calling this function repeatedly
    /// will not necessarily produce a sequence of non-decreasing values.
    ///
    /// The nanoseconds field of the output is always less than 1000000000.
    #[allow(async_fn_in_trait)]
    pub async fn now() -> Instant{
      unsafe {

        #[derive(Copy, Clone)]
        struct ParamsLower(
        
        );
        unsafe impl Send for ParamsLower {}
        

        use wit_bindgen::rt::async_support::Subtask as _Subtask;
        struct _MySubtask<'a> { _unused: core::marker::PhantomData<&'a ()> }
        #[allow(unused_parens)]
        unsafe impl<'a> _Subtask for _MySubtask<'a> {
          
          type Params = ();
          type Results = Instant;
          type ParamsLower = ParamsLower;
          fn abi_layout(&mut self) -> ::core::alloc::Layout {
            unsafe {
              ::core::alloc::Layout::from_size_align_unchecked(16, 8)
            }
          }
          
          fn results_offset(&mut self) -> usize { 0 }

          unsafe fn call_import(&mut self, _params: Self::ParamsLower, _results: *mut u8) -> u32 {
            
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:clocks/system-clock@0.3.0-rc-2026-01-06")]
            unsafe extern "C" {
              #[link_name = "[async-lower]now"]
              fn call(_: *mut u8, ) -> i32;
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn call(_: *mut u8, ) -> i32 { unreachable!() }
            
            unsafe { call(_results) as u32 }
          }
          
          unsafe fn params_dealloc_lists(&mut self, _params: Self::ParamsLower) {
            unsafe {  }
          }
          unsafe fn params_dealloc_lists_and_own(&mut self, _params: Self::ParamsLower) {
            unsafe {  }
          }
          unsafe fn params_lower(&mut self, (): Self::Params, _ptr: *mut u8) -> Self::ParamsLower {
            unsafe {  ParamsLower() }
          }
          unsafe fn results_lift(&mut self, _ptr: *mut u8) -> Self::Results {
            unsafe { let l0 = *_ptr.add(0).cast::<i64>();
            let l1 = *_ptr.add(8).cast::<i32>();

            Instant{
              seconds: l0,
              nanoseconds: l1 as u32,
            } }
          }
        }
        _MySubtask { _unused: core::marker::PhantomData }.call(()).await
      }
    }
    #[allow(unused_unsafe, clippy::all)]
    /// Query the resolution of the clock. Returns the smallest duration of time
    /// that the implementation permits distinguishing.
    #[allow(async_fn_in_trait)]
    pub async fn get_resolution() -> Duration{
      unsafe {

        #[derive(Copy, Clone)]
        struct ParamsLower(
        
        );
        unsafe impl Send for ParamsLower {}
        

        use wit_bindgen::rt::async_support::Subtask as _Subtask;
        struct _MySubtask<'a> { _unused: core::marker::PhantomData<&'a ()> }
        #[allow(unused_parens)]
        unsafe impl<'a> _Subtask for _MySubtask<'a> {
          
          type Params = ();
          type Results = Duration;
          type ParamsLower = ParamsLower;
          fn abi_layout(&mut self) -> ::core::alloc::Layout {
            unsafe {
              ::core::alloc::Layout::from_size_align_unchecked(8, 8)
            }
          }
          
          fn results_offset(&mut self) -> usize { 0 }

          unsafe fn call_import(&mut self, _params: Self::ParamsLower, _results: *mut u8) -> u32 {
            
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:clocks/system-clock@0.3.0-rc-2026-01-06")]
            unsafe extern "C" {
              #[link_name = "[async-lower]get-resolution"]
              fn call(_: *mut u8, ) -> i32;
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn call(_: *mut u8, ) -> i32 { unreachable!() }
            
            unsafe { call(_results) as u32 }
          }
          
          unsafe fn params_dealloc_lists(&mut self, _params: Self::ParamsLower) {
            unsafe {  }
          }
          unsafe fn params_dealloc_lists_and_own(&mut self, _params: Self::ParamsLower) {
            unsafe {  }
          }
          unsafe fn params_lower(&mut self, (): Self::Params, _ptr: *mut u8) -> Self::ParamsLower {
            unsafe {  ParamsLower() }
          }
          unsafe fn results_lift(&mut self, _ptr: *mut u8) -> Self::Results {
            unsafe { let l0 = *_ptr.add(0).cast::<i64>();

            l0 as u64 }
          }
        }
        _MySubtask { _unused: core::marker::PhantomData }.call(()).await
      }
    }

  }

}
pub mod filesystem {
  /// WASI filesystem is a filesystem API primarily intended to let users run WASI
  /// programs that access their files on their existing filesystems, without
  /// significant overhead.
  ///
  /// It is intended to be roughly portable between Unix-family platforms and
  /// Windows, though it does not hide many of the major differences.
  ///
  /// Paths are passed as interface-type `string`s, meaning they must consist of
  /// a sequence of Unicode Scalar Values (USVs). Some filesystems may contain
  /// paths which are not accessible by this API.
  ///
  /// The directory separator in WASI is always the forward-slash (`/`).
  ///
  /// All paths in WASI are relative paths, and are interpreted relative to a
  /// `descriptor` referring to a base directory. If a `path` argument to any WASI
  /// function starts with `/`, or if any step of resolving a `path`, including
  /// `..` and symbolic link steps, reaches a directory outside of the base
  /// directory, or reaches a symlink to an absolute or rooted path in the
  /// underlying filesystem, the function fails with `error-code::not-permitted`.
  ///
  /// For more information about WASI path resolution and sandboxing, see
  /// [WASI filesystem path resolution].
  ///
  /// [WASI filesystem path resolution]: https://github.com/WebAssembly/wasi-filesystem/blob/main/path-resolution.md
  #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
  pub mod types {
    #[used]
    #[doc(hidden)]
    static __FORCE_SECTION_REF: fn() =
    super::super::super::__link_custom_section_describing_imports;
    
    use super::super::super::_rt;
    pub type Instant = super::super::super::wasi::clocks::system_clock::Instant;
    /// File size or length of a region within a file.
    pub type Filesize = u64;
    /// The type of a filesystem object referenced by a descriptor.
    ///
    /// Note: This was called `filetype` in earlier versions of WASI.
    #[repr(u8)]
    #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd, serde::Deserialize, serde::Serialize)]
    pub enum DescriptorType {
      /// The type of the descriptor or file is unknown or is different from
      /// any of the other types specified.
      Unknown,
      /// The descriptor refers to a block device inode.
      BlockDevice,
      /// The descriptor refers to a character device inode.
      CharacterDevice,
      /// The descriptor refers to a directory inode.
      Directory,
      /// The descriptor refers to a named pipe.
      Fifo,
      /// The file refers to a symbolic link inode.
      SymbolicLink,
      /// The descriptor refers to a regular file inode.
      RegularFile,
      /// The descriptor refers to a socket.
      Socket,
    }
    impl ::core::fmt::Debug for DescriptorType {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self {
          DescriptorType::Unknown => {
            f.debug_tuple("DescriptorType::Unknown").finish()
          }
          DescriptorType::BlockDevice => {
            f.debug_tuple("DescriptorType::BlockDevice").finish()
          }
          DescriptorType::CharacterDevice => {
            f.debug_tuple("DescriptorType::CharacterDevice").finish()
          }
          DescriptorType::Directory => {
            f.debug_tuple("DescriptorType::Directory").finish()
          }
          DescriptorType::Fifo => {
            f.debug_tuple("DescriptorType::Fifo").finish()
          }
          DescriptorType::SymbolicLink => {
            f.debug_tuple("DescriptorType::SymbolicLink").finish()
          }
          DescriptorType::RegularFile => {
            f.debug_tuple("DescriptorType::RegularFile").finish()
          }
          DescriptorType::Socket => {
            f.debug_tuple("DescriptorType::Socket").finish()
          }
        }
      }
    }

    impl DescriptorType{
      #[doc(hidden)]
      pub unsafe fn _lift(val: u8) -> DescriptorType{
        if !cfg!(debug_assertions) {
          return unsafe { ::core::mem::transmute(val) };
        }

        match val {
          0 => DescriptorType::Unknown,
          1 => DescriptorType::BlockDevice,
          2 => DescriptorType::CharacterDevice,
          3 => DescriptorType::Directory,
          4 => DescriptorType::Fifo,
          5 => DescriptorType::SymbolicLink,
          6 => DescriptorType::RegularFile,
          7 => DescriptorType::Socket,

          _ => panic!("invalid enum discriminant"),
        }
      }
    }

    wit_bindgen::rt::bitflags::bitflags! {
      /// Descriptor flags.
      ///
      /// Note: This was called `fdflags` in earlier versions of WASI.
      #[derive(PartialEq, Eq, PartialOrd, Ord, Hash, Debug, Clone, Copy)]
      pub struct DescriptorFlags: u8 {
        /// Read mode: Data can be read.
        const READ = 1 << 0;
        /// Write mode: Data can be written to.
        const WRITE = 1 << 1;
        /// Request that writes be performed according to synchronized I/O file
        /// integrity completion. The data stored in the file and the file's
        /// metadata are synchronized. This is similar to `O_SYNC` in POSIX.
        ///
        /// The precise semantics of this operation have not yet been defined for
        /// WASI. At this time, it should be interpreted as a request, and not a
        /// requirement.
        const FILE_INTEGRITY_SYNC = 1 << 2;
        /// Request that writes be performed according to synchronized I/O data
        /// integrity completion. Only the data stored in the file is
        /// synchronized. This is similar to `O_DSYNC` in POSIX.
        ///
        /// The precise semantics of this operation have not yet been defined for
        /// WASI. At this time, it should be interpreted as a request, and not a
        /// requirement.
        const DATA_INTEGRITY_SYNC = 1 << 3;
        /// Requests that reads be performed at the same level of integrity
        /// requested for writes. This is similar to `O_RSYNC` in POSIX.
        ///
        /// The precise semantics of this operation have not yet been defined for
        /// WASI. At this time, it should be interpreted as a request, and not a
        /// requirement.
        const REQUESTED_WRITE_SYNC = 1 << 4;
        /// Mutating directories mode: Directory contents may be mutated.
        ///
        /// When this flag is unset on a descriptor, operations using the
        /// descriptor which would create, rename, delete, modify the data or
        /// metadata of filesystem objects, or obtain another handle which
        /// would permit any of those, shall fail with `error-code::read-only` if
        /// they would otherwise succeed.
        ///
        /// This may only be set on directories.
        const MUTATE_DIRECTORY = 1 << 5;
      }
    }
    wit_bindgen::rt::bitflags::bitflags! {
      /// Flags determining the method of how paths are resolved.
      #[derive(PartialEq, Eq, PartialOrd, Ord, Hash, Debug, Clone, Copy)]
      pub struct PathFlags: u8 {
        /// As long as the resolved path corresponds to a symbolic link, it is
        /// expanded.
        const SYMLINK_FOLLOW = 1 << 0;
      }
    }
    wit_bindgen::rt::bitflags::bitflags! {
      /// Open flags used by `open-at`.
      #[derive(PartialEq, Eq, PartialOrd, Ord, Hash, Debug, Clone, Copy)]
      pub struct OpenFlags: u8 {
        /// Create file if it does not exist, similar to `O_CREAT` in POSIX.
        const CREATE = 1 << 0;
        /// Fail if not a directory, similar to `O_DIRECTORY` in POSIX.
        const DIRECTORY = 1 << 1;
        /// Fail if file already exists, similar to `O_EXCL` in POSIX.
        const EXCLUSIVE = 1 << 2;
        /// Truncate file to size 0, similar to `O_TRUNC` in POSIX.
        const TRUNCATE = 1 << 3;
      }
    }
    /// Number of hard links to an inode.
    pub type LinkCount = u64;
    /// File attributes.
    ///
    /// Note: This was called `filestat` in earlier versions of WASI.
    #[repr(C)]
    #[derive(Clone, Copy, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct DescriptorStat {
      /// File type.
      pub type_: DescriptorType,
      /// Number of hard links to the file.
      pub link_count: LinkCount,
      /// For regular files, the file size in bytes. For symbolic links, the
      /// length in bytes of the pathname contained in the symbolic link.
      pub size: Filesize,
      /// Last data access timestamp.
      ///
      /// If the `option` is none, the platform doesn't maintain an access
      /// timestamp for this file.
      pub data_access_timestamp: Option<Instant>,
      /// Last data modification timestamp.
      ///
      /// If the `option` is none, the platform doesn't maintain a
      /// modification timestamp for this file.
      pub data_modification_timestamp: Option<Instant>,
      /// Last file status-change timestamp.
      ///
      /// If the `option` is none, the platform doesn't maintain a
      /// status-change timestamp for this file.
      pub status_change_timestamp: Option<Instant>,
    }
    impl ::core::fmt::Debug for DescriptorStat {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DescriptorStat").field("type", &self.type_).field("link-count", &self.link_count).field("size", &self.size).field("data-access-timestamp", &self.data_access_timestamp).field("data-modification-timestamp", &self.data_modification_timestamp).field("status-change-timestamp", &self.status_change_timestamp).finish()
      }
    }
    /// When setting a timestamp, this gives the value to set it to.
    #[derive(Clone, Copy, PartialEq, serde::Deserialize, serde::Serialize)]
    pub enum NewTimestamp {
      /// Leave the timestamp set to its previous value.
      NoChange,
      /// Set the timestamp to the current time of the system clock associated
      /// with the filesystem.
      Now,
      /// Set the timestamp to the given value.
      Timestamp(Instant),
    }
    impl ::core::fmt::Debug for NewTimestamp {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self {
          NewTimestamp::NoChange => {
            f.debug_tuple("NewTimestamp::NoChange").finish()
          }
          NewTimestamp::Now => {
            f.debug_tuple("NewTimestamp::Now").finish()
          }
          NewTimestamp::Timestamp(e) => {
            f.debug_tuple("NewTimestamp::Timestamp").field(e).finish()
          }
        }
      }
    }
    /// A directory entry.
    #[derive(Clone, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct DirectoryEntry {
      /// The type of the file referred to by this directory entry.
      pub type_: DescriptorType,
      /// The name of the object.
      pub name: _rt::String,
    }
    impl ::core::fmt::Debug for DirectoryEntry {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DirectoryEntry").field("type", &self.type_).field("name", &self.name).finish()
      }
    }
    /// Error codes returned by functions, similar to `errno` in POSIX.
    /// Not all of these error codes are returned by the functions provided by this
    /// API; some are used in higher-level library layers, and others are provided
    /// merely for alignment with POSIX.
    #[repr(u8)]
    #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd, serde::Deserialize, serde::Serialize)]
    pub enum ErrorCode {
      /// Permission denied, similar to `EACCES` in POSIX.
      Access,
      /// Connection already in progress, similar to `EALREADY` in POSIX.
      Already,
      /// Bad descriptor, similar to `EBADF` in POSIX.
      BadDescriptor,
      /// Device or resource busy, similar to `EBUSY` in POSIX.
      Busy,
      /// Resource deadlock would occur, similar to `EDEADLK` in POSIX.
      Deadlock,
      /// Storage quota exceeded, similar to `EDQUOT` in POSIX.
      Quota,
      /// File exists, similar to `EEXIST` in POSIX.
      Exist,
      /// File too large, similar to `EFBIG` in POSIX.
      FileTooLarge,
      /// Illegal byte sequence, similar to `EILSEQ` in POSIX.
      IllegalByteSequence,
      /// Operation in progress, similar to `EINPROGRESS` in POSIX.
      InProgress,
      /// Interrupted function, similar to `EINTR` in POSIX.
      Interrupted,
      /// Invalid argument, similar to `EINVAL` in POSIX.
      Invalid,
      /// I/O error, similar to `EIO` in POSIX.
      Io,
      /// Is a directory, similar to `EISDIR` in POSIX.
      IsDirectory,
      /// Too many levels of symbolic links, similar to `ELOOP` in POSIX.
      Loop,
      /// Too many links, similar to `EMLINK` in POSIX.
      TooManyLinks,
      /// Message too large, similar to `EMSGSIZE` in POSIX.
      MessageSize,
      /// Filename too long, similar to `ENAMETOOLONG` in POSIX.
      NameTooLong,
      /// No such device, similar to `ENODEV` in POSIX.
      NoDevice,
      /// No such file or directory, similar to `ENOENT` in POSIX.
      NoEntry,
      /// No locks available, similar to `ENOLCK` in POSIX.
      NoLock,
      /// Not enough space, similar to `ENOMEM` in POSIX.
      InsufficientMemory,
      /// No space left on device, similar to `ENOSPC` in POSIX.
      InsufficientSpace,
      /// Not a directory or a symbolic link to a directory, similar to `ENOTDIR` in POSIX.
      NotDirectory,
      /// Directory not empty, similar to `ENOTEMPTY` in POSIX.
      NotEmpty,
      /// State not recoverable, similar to `ENOTRECOVERABLE` in POSIX.
      NotRecoverable,
      /// Not supported, similar to `ENOTSUP` and `ENOSYS` in POSIX.
      Unsupported,
      /// Inappropriate I/O control operation, similar to `ENOTTY` in POSIX.
      NoTty,
      /// No such device or address, similar to `ENXIO` in POSIX.
      NoSuchDevice,
      /// Value too large to be stored in data type, similar to `EOVERFLOW` in POSIX.
      Overflow,
      /// Operation not permitted, similar to `EPERM` in POSIX.
      NotPermitted,
      /// Broken pipe, similar to `EPIPE` in POSIX.
      Pipe,
      /// Read-only file system, similar to `EROFS` in POSIX.
      ReadOnly,
      /// Invalid seek, similar to `ESPIPE` in POSIX.
      InvalidSeek,
      /// Text file busy, similar to `ETXTBSY` in POSIX.
      TextFileBusy,
      /// Cross-device link, similar to `EXDEV` in POSIX.
      CrossDevice,
    }
    impl ErrorCode{
      pub fn name(&self) -> &'static str {
        match self {
          ErrorCode::Access => "access",
          ErrorCode::Already => "already",
          ErrorCode::BadDescriptor => "bad-descriptor",
          ErrorCode::Busy => "busy",
          ErrorCode::Deadlock => "deadlock",
          ErrorCode::Quota => "quota",
          ErrorCode::Exist => "exist",
          ErrorCode::FileTooLarge => "file-too-large",
          ErrorCode::IllegalByteSequence => "illegal-byte-sequence",
          ErrorCode::InProgress => "in-progress",
          ErrorCode::Interrupted => "interrupted",
          ErrorCode::Invalid => "invalid",
          ErrorCode::Io => "io",
          ErrorCode::IsDirectory => "is-directory",
          ErrorCode::Loop => "loop",
          ErrorCode::TooManyLinks => "too-many-links",
          ErrorCode::MessageSize => "message-size",
          ErrorCode::NameTooLong => "name-too-long",
          ErrorCode::NoDevice => "no-device",
          ErrorCode::NoEntry => "no-entry",
          ErrorCode::NoLock => "no-lock",
          ErrorCode::InsufficientMemory => "insufficient-memory",
          ErrorCode::InsufficientSpace => "insufficient-space",
          ErrorCode::NotDirectory => "not-directory",
          ErrorCode::NotEmpty => "not-empty",
          ErrorCode::NotRecoverable => "not-recoverable",
          ErrorCode::Unsupported => "unsupported",
          ErrorCode::NoTty => "no-tty",
          ErrorCode::NoSuchDevice => "no-such-device",
          ErrorCode::Overflow => "overflow",
          ErrorCode::NotPermitted => "not-permitted",
          ErrorCode::Pipe => "pipe",
          ErrorCode::ReadOnly => "read-only",
          ErrorCode::InvalidSeek => "invalid-seek",
          ErrorCode::TextFileBusy => "text-file-busy",
          ErrorCode::CrossDevice => "cross-device",
        }
      }
      pub fn message(&self) -> &'static str {
        match self {
          ErrorCode::Access => "Permission denied, similar to `EACCES` in POSIX.",
          ErrorCode::Already => "Connection already in progress, similar to `EALREADY` in POSIX.",
          ErrorCode::BadDescriptor => "Bad descriptor, similar to `EBADF` in POSIX.",
          ErrorCode::Busy => "Device or resource busy, similar to `EBUSY` in POSIX.",
          ErrorCode::Deadlock => "Resource deadlock would occur, similar to `EDEADLK` in POSIX.",
          ErrorCode::Quota => "Storage quota exceeded, similar to `EDQUOT` in POSIX.",
          ErrorCode::Exist => "File exists, similar to `EEXIST` in POSIX.",
          ErrorCode::FileTooLarge => "File too large, similar to `EFBIG` in POSIX.",
          ErrorCode::IllegalByteSequence => "Illegal byte sequence, similar to `EILSEQ` in POSIX.",
          ErrorCode::InProgress => "Operation in progress, similar to `EINPROGRESS` in POSIX.",
          ErrorCode::Interrupted => "Interrupted function, similar to `EINTR` in POSIX.",
          ErrorCode::Invalid => "Invalid argument, similar to `EINVAL` in POSIX.",
          ErrorCode::Io => "I/O error, similar to `EIO` in POSIX.",
          ErrorCode::IsDirectory => "Is a directory, similar to `EISDIR` in POSIX.",
          ErrorCode::Loop => "Too many levels of symbolic links, similar to `ELOOP` in POSIX.",
          ErrorCode::TooManyLinks => "Too many links, similar to `EMLINK` in POSIX.",
          ErrorCode::MessageSize => "Message too large, similar to `EMSGSIZE` in POSIX.",
          ErrorCode::NameTooLong => "Filename too long, similar to `ENAMETOOLONG` in POSIX.",
          ErrorCode::NoDevice => "No such device, similar to `ENODEV` in POSIX.",
          ErrorCode::NoEntry => "No such file or directory, similar to `ENOENT` in POSIX.",
          ErrorCode::NoLock => "No locks available, similar to `ENOLCK` in POSIX.",
          ErrorCode::InsufficientMemory => "Not enough space, similar to `ENOMEM` in POSIX.",
          ErrorCode::InsufficientSpace => "No space left on device, similar to `ENOSPC` in POSIX.",
          ErrorCode::NotDirectory => "Not a directory or a symbolic link to a directory, similar to `ENOTDIR` in POSIX.",
          ErrorCode::NotEmpty => "Directory not empty, similar to `ENOTEMPTY` in POSIX.",
          ErrorCode::NotRecoverable => "State not recoverable, similar to `ENOTRECOVERABLE` in POSIX.",
          ErrorCode::Unsupported => "Not supported, similar to `ENOTSUP` and `ENOSYS` in POSIX.",
          ErrorCode::NoTty => "Inappropriate I/O control operation, similar to `ENOTTY` in POSIX.",
          ErrorCode::NoSuchDevice => "No such device or address, similar to `ENXIO` in POSIX.",
          ErrorCode::Overflow => "Value too large to be stored in data type, similar to `EOVERFLOW` in POSIX.",
          ErrorCode::NotPermitted => "Operation not permitted, similar to `EPERM` in POSIX.",
          ErrorCode::Pipe => "Broken pipe, similar to `EPIPE` in POSIX.",
          ErrorCode::ReadOnly => "Read-only file system, similar to `EROFS` in POSIX.",
          ErrorCode::InvalidSeek => "Invalid seek, similar to `ESPIPE` in POSIX.",
          ErrorCode::TextFileBusy => "Text file busy, similar to `ETXTBSY` in POSIX.",
          ErrorCode::CrossDevice => "Cross-device link, similar to `EXDEV` in POSIX.",
        }
      }
    }
    impl ::core::fmt::Debug for ErrorCode{
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("ErrorCode")
        .field("code", &(*self as i32))
        .field("name", &self.name())
        .field("message", &self.message())
        .finish()
      }
    }
    impl ::core::fmt::Display for ErrorCode{
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "{} (error {})", self.name(), *self as i32)
      }
    }

    impl ::core::error::Error for ErrorCode {}

    impl ErrorCode{
      #[doc(hidden)]
      pub unsafe fn _lift(val: u8) -> ErrorCode{
        if !cfg!(debug_assertions) {
          return unsafe { ::core::mem::transmute(val) };
        }

        match val {
          0 => ErrorCode::Access,
          1 => ErrorCode::Already,
          2 => ErrorCode::BadDescriptor,
          3 => ErrorCode::Busy,
          4 => ErrorCode::Deadlock,
          5 => ErrorCode::Quota,
          6 => ErrorCode::Exist,
          7 => ErrorCode::FileTooLarge,
          8 => ErrorCode::IllegalByteSequence,
          9 => ErrorCode::InProgress,
          10 => ErrorCode::Interrupted,
          11 => ErrorCode::Invalid,
          12 => ErrorCode::Io,
          13 => ErrorCode::IsDirectory,
          14 => ErrorCode::Loop,
          15 => ErrorCode::TooManyLinks,
          16 => ErrorCode::MessageSize,
          17 => ErrorCode::NameTooLong,
          18 => ErrorCode::NoDevice,
          19 => ErrorCode::NoEntry,
          20 => ErrorCode::NoLock,
          21 => ErrorCode::InsufficientMemory,
          22 => ErrorCode::InsufficientSpace,
          23 => ErrorCode::NotDirectory,
          24 => ErrorCode::NotEmpty,
          25 => ErrorCode::NotRecoverable,
          26 => ErrorCode::Unsupported,
          27 => ErrorCode::NoTty,
          28 => ErrorCode::NoSuchDevice,
          29 => ErrorCode::Overflow,
          30 => ErrorCode::NotPermitted,
          31 => ErrorCode::Pipe,
          32 => ErrorCode::ReadOnly,
          33 => ErrorCode::InvalidSeek,
          34 => ErrorCode::TextFileBusy,
          35 => ErrorCode::CrossDevice,

          _ => panic!("invalid enum discriminant"),
        }
      }
    }

    /// File or memory access pattern advisory information.
    #[repr(u8)]
    #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd, serde::Deserialize, serde::Serialize)]
    pub enum Advice {
      /// The application has no advice to give on its behavior with respect
      /// to the specified data.
      Normal,
      /// The application expects to access the specified data sequentially
      /// from lower offsets to higher offsets.
      Sequential,
      /// The application expects to access the specified data in a random
      /// order.
      Random,
      /// The application expects to access the specified data in the near
      /// future.
      WillNeed,
      /// The application expects that it will not access the specified data
      /// in the near future.
      DontNeed,
      /// The application expects to access the specified data once and then
      /// not reuse it thereafter.
      NoReuse,
    }
    impl ::core::fmt::Debug for Advice {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self {
          Advice::Normal => {
            f.debug_tuple("Advice::Normal").finish()
          }
          Advice::Sequential => {
            f.debug_tuple("Advice::Sequential").finish()
          }
          Advice::Random => {
            f.debug_tuple("Advice::Random").finish()
          }
          Advice::WillNeed => {
            f.debug_tuple("Advice::WillNeed").finish()
          }
          Advice::DontNeed => {
            f.debug_tuple("Advice::DontNeed").finish()
          }
          Advice::NoReuse => {
            f.debug_tuple("Advice::NoReuse").finish()
          }
        }
      }
    }

    impl Advice{
      #[doc(hidden)]
      pub unsafe fn _lift(val: u8) -> Advice{
        if !cfg!(debug_assertions) {
          return unsafe { ::core::mem::transmute(val) };
        }

        match val {
          0 => Advice::Normal,
          1 => Advice::Sequential,
          2 => Advice::Random,
          3 => Advice::WillNeed,
          4 => Advice::DontNeed,
          5 => Advice::NoReuse,

          _ => panic!("invalid enum discriminant"),
        }
      }
    }

    /// A 128-bit hash value, split into parts because wasm doesn't have a
    /// 128-bit integer type.
    #[repr(C)]
    #[derive(Clone, Copy, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct MetadataHashValue {
      /// 64 bits of a 128-bit hash value.
      pub lower: u64,
      /// Another 64 bits of a 128-bit hash value.
      pub upper: u64,
    }
    impl ::core::fmt::Debug for MetadataHashValue {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("MetadataHashValue").field("lower", &self.lower).field("upper", &self.upper).finish()
      }
    }
    /// A descriptor is a reference to a filesystem object, which may be a file,
    /// directory, named pipe, special file, or other object on which filesystem
    /// calls may be made.

    #[derive(Debug)]
    #[repr(transparent)]
    pub struct Descriptor{
      handle: _rt::Resource<Descriptor>,
    }

    impl Descriptor{
      #[doc(hidden)]
      pub unsafe fn from_handle(handle: u32) -> Self {
        Self {
          handle: unsafe { _rt::Resource::from_handle(handle) },
        }
      }

      #[doc(hidden)]
      pub fn take_handle(&self) -> u32 {
        _rt::Resource::take_handle(&self.handle)
      }

      #[doc(hidden)]
      pub fn handle(&self) -> u32 {
        _rt::Resource::handle(&self.handle)
      }
    }
    

    unsafe impl _rt::WasmResource for Descriptor{
      #[inline]
      unsafe fn drop(_handle: u32) {
        
        #[cfg(target_arch = "wasm32")]
        #[link(wasm_import_module = "wasi:filesystem/types@0.3.0-rc-2026-01-06")]
        unsafe extern "C" {
          #[link_name = "[resource-drop]descriptor"]
          fn drop(_: i32, );
        }

        #[cfg(not(target_arch = "wasm32"))]
        unsafe extern "C" fn drop(_: i32, ) { unreachable!() }
        
        unsafe { drop(_handle as i32); }
      }
    }
    
    impl Descriptor {
      #[allow(unused_unsafe, clippy::all)]
      /// Return a stream for reading from a file.
      ///
      /// Multiple read, write, and append streams may be active on the same open
      /// file and they do not interfere with each other.
      ///
      /// This function returns a `stream` which provides the data received from the
      /// file, and a `future` providing additional error information in case an
      /// error is encountered.
      ///
      /// If no error is encountered, `stream.read` on the `stream` will return
      /// `read-status::closed` with no `error-context` and the future resolves to
      /// the value `ok`. If an error is encountered, `stream.read` on the
      /// `stream` returns `read-status::closed` with an `error-context` and the future
      /// resolves to `err` with an `error-code`.
      ///
      /// Note: This is similar to `pread` in POSIX.
      #[allow(async_fn_in_trait)]
      pub async fn read_via_stream(&self,offset: Filesize,) -> (wit_bindgen::rt::async_support::StreamReader<u8>,wit_bindgen::rt::async_support::FutureReader<Result<(),ErrorCode>>,){
        unsafe {

          #[derive(Copy, Clone)]
          struct ParamsLower(
          i32, i64, 
          );
          unsafe impl Send for ParamsLower {}
          

          use wit_bindgen::rt::async_support::Subtask as _Subtask;
          struct _MySubtask<'a> { _unused: core::marker::PhantomData<&'a ()> }
          #[allow(unused_parens)]
          unsafe impl<'a> _Subtask for _MySubtask<'a> {
            
            type Params = (&'a Descriptor, Filesize, );
            type Results = (wit_bindgen::rt::async_support::StreamReader<u8>,wit_bindgen::rt::async_support::FutureReader<Result<(),ErrorCode>>,);
            type ParamsLower = ParamsLower;
            fn abi_layout(&mut self) -> ::core::alloc::Layout {
              unsafe {
                ::core::alloc::Layout::from_size_align_unchecked(8, 4)
              }
            }
            
            fn results_offset(&mut self) -> usize { 0 }

            unsafe fn call_import(&mut self, _params: Self::ParamsLower, _results: *mut u8) -> u32 {
              
              #[cfg(target_arch = "wasm32")]
              #[link(wasm_import_module = "wasi:filesystem/types@0.3.0-rc-2026-01-06")]
              unsafe extern "C" {
                #[link_name = "[async-lower][method]descriptor.read-via-stream"]
                fn call(_: i32, _: i64, _: *mut u8, ) -> i32;
              }

              #[cfg(not(target_arch = "wasm32"))]
              unsafe extern "C" fn call(_: i32, _: i64, _: *mut u8, ) -> i32 { unreachable!() }
              
              unsafe { call(_params.0,_params.1,_results) as u32 }
            }
            
            unsafe fn params_dealloc_lists(&mut self, _params: Self::ParamsLower) {
              unsafe {  }
            }
            unsafe fn params_dealloc_lists_and_own(&mut self, _params: Self::ParamsLower) {
              unsafe {  }
            }
            unsafe fn params_lower(&mut self, (_lower0, _lower1,): Self::Params, _ptr: *mut u8) -> Self::ParamsLower {
              unsafe {  ParamsLower((_lower0).handle() as i32, _rt::as_i64(_lower1),) }
            }
            unsafe fn results_lift(&mut self, _ptr: *mut u8) -> Self::Results {
              unsafe { let l0 = *_ptr.add(0).cast::<i32>();
              let l1 = *_ptr.add(4).cast::<i32>();

              (wit_bindgen::rt::async_support::StreamReader::new(l0 as u32, &super::super::super::wit_stream::vtable0::VTABLE), wit_bindgen::rt::async_support::FutureReader::new(l1 as u32, &super::super::super::wit_future::vtable1::VTABLE)) }
            }
          }
          _MySubtask { _unused: core::marker::PhantomData }.call((self, offset,)).await
        }
      }
    }
    impl Descriptor {
      #[allow(unused_unsafe, clippy::all)]
      /// Return a stream for writing to a file, if available.
      ///
      /// May fail with an error-code describing why the file cannot be written.
      ///
      /// It is valid to write past the end of a file; the file is extended to the
      /// extent of the write, with bytes between the previous end and the start of
      /// the write set to zero.
      ///
      /// This function returns once either full contents of the stream are
      /// written or an error is encountered.
      ///
      /// Note: This is similar to `pwrite` in POSIX.
      #[allow(async_fn_in_trait)]
      pub async fn write_via_stream(&self,data: wit_bindgen::rt::async_support::StreamReader<u8>,offset: Filesize,) -> Result<(),ErrorCode>{
        unsafe {

          #[derive(Copy, Clone)]
          struct ParamsLower(
          i32, i32, i64, 
          );
          unsafe impl Send for ParamsLower {}
          

          use wit_bindgen::rt::async_support::Subtask as _Subtask;
          struct _MySubtask<'a> { _unused: core::marker::PhantomData<&'a ()> }
          #[allow(unused_parens)]
          unsafe impl<'a> _Subtask for _MySubtask<'a> {
            
            type Params = (&'a Descriptor, wit_bindgen::rt::async_support::StreamReader<u8>, Filesize, );
            type Results = Result<(),ErrorCode>;
            type ParamsLower = ParamsLower;
            fn abi_layout(&mut self) -> ::core::alloc::Layout {
              unsafe {
                ::core::alloc::Layout::from_size_align_unchecked(2, 1)
              }
            }
            
            fn results_offset(&mut self) -> usize { 0 }

            unsafe fn call_import(&mut self, _params: Self::ParamsLower, _results: *mut u8) -> u32 {
              
              #[cfg(target_arch = "wasm32")]
              #[link(wasm_import_module = "wasi:filesystem/types@0.3.0-rc-2026-01-06")]
              unsafe extern "C" {
                #[link_name = "[async-lower][method]descriptor.write-via-stream"]
                fn call(_: i32, _: i32, _: i64, _: *mut u8, ) -> i32;
              }

              #[cfg(not(target_arch = "wasm32"))]
              unsafe extern "C" fn call(_: i32, _: i32, _: i64, _: *mut u8, ) -> i32 { unreachable!() }
              
              unsafe { call(_params.0,_params.1,_params.2,_results) as u32 }
            }
            
            unsafe fn params_dealloc_lists(&mut self, _params: Self::ParamsLower) {
              unsafe {  }
            }
            unsafe fn params_dealloc_lists_and_own(&mut self, _params: Self::ParamsLower) {
              unsafe { let _ = wit_bindgen::rt::async_support::StreamReader::new(_params.1 as u32, &super::super::super::wit_stream::vtable0::VTABLE);
            }
          }
          unsafe fn params_lower(&mut self, (_lower0, _lower1, _lower2,): Self::Params, _ptr: *mut u8) -> Self::ParamsLower {
            unsafe {  ParamsLower((_lower0).handle() as i32, (_lower1).take_handle() as i32, _rt::as_i64(_lower2),) }
          }
          unsafe fn results_lift(&mut self, _ptr: *mut u8) -> Self::Results {
            unsafe { let l0 = i32::from(*_ptr.add(0).cast::<u8>());

            match l0 {
              0 => {
                let e = ();
                Ok(e)
              }
              1 => {
                let e = {
                  let l1 = i32::from(*_ptr.add(1).cast::<u8>());

                  ErrorCode::_lift(l1 as u8)
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            } }
          }
        }
        _MySubtask { _unused: core::marker::PhantomData }.call((self, data, offset,)).await
      }
    }
  }
  impl Descriptor {
    #[allow(unused_unsafe, clippy::all)]
    /// Return a stream for appending to a file, if available.
    ///
    /// May fail with an error-code describing why the file cannot be appended.
    ///
    /// This function returns once either full contents of the stream are
    /// written or an error is encountered.
    ///
    /// Note: This is similar to `write` with `O_APPEND` in POSIX.
    #[allow(async_fn_in_trait)]
    pub async fn append_via_stream(&self,data: wit_bindgen::rt::async_support::StreamReader<u8>,) -> Result<(),ErrorCode>{
      unsafe {

        #[derive(Copy, Clone)]
        struct ParamsLower(
        i32, i32, 
        );
        unsafe impl Send for ParamsLower {}
        

        use wit_bindgen::rt::async_support::Subtask as _Subtask;
        struct _MySubtask<'a> { _unused: core::marker::PhantomData<&'a ()> }
        #[allow(unused_parens)]
        unsafe impl<'a> _Subtask for _MySubtask<'a> {
          
          type Params = (&'a Descriptor, wit_bindgen::rt::async_support::StreamReader<u8>, );
          type Results = Result<(),ErrorCode>;
          type ParamsLower = ParamsLower;
          fn abi_layout(&mut self) -> ::core::alloc::Layout {
            unsafe {
              ::core::alloc::Layout::from_size_align_unchecked(2, 1)
            }
          }
          
          fn results_offset(&mut self) -> usize { 0 }

          unsafe fn call_import(&mut self, _params: Self::ParamsLower, _results: *mut u8) -> u32 {
            
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:filesystem/types@0.3.0-rc-2026-01-06")]
            unsafe extern "C" {
              #[link_name = "[async-lower][method]descriptor.append-via-stream"]
              fn call(_: i32, _: i32, _: *mut u8, ) -> i32;
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn call(_: i32, _: i32, _: *mut u8, ) -> i32 { unreachable!() }
            
            unsafe { call(_params.0,_params.1,_results) as u32 }
          }
          
          unsafe fn params_dealloc_lists(&mut self, _params: Self::ParamsLower) {
            unsafe {  }
          }
          unsafe fn params_dealloc_lists_and_own(&mut self, _params: Self::ParamsLower) {
            unsafe { let _ = wit_bindgen::rt::async_support::StreamReader::new(_params.1 as u32, &super::super::super::wit_stream::vtable0::VTABLE);
          }
        }
        unsafe fn params_lower(&mut self, (_lower0, _lower1,): Self::Params, _ptr: *mut u8) -> Self::ParamsLower {
          unsafe {  ParamsLower((_lower0).handle() as i32, (_lower1).take_handle() as i32,) }
        }
        unsafe fn results_lift(&mut self, _ptr: *mut u8) -> Self::Results {
          unsafe { let l0 = i32::from(*_ptr.add(0).cast::<u8>());

          match l0 {
            0 => {
              let e = ();
              Ok(e)
            }
            1 => {
              let e = {
                let l1 = i32::from(*_ptr.add(1).cast::<u8>());

                ErrorCode::_lift(l1 as u8)
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          } }
        }
      }
      _MySubtask { _unused: core::marker::PhantomData }.call((self, data,)).await
    }
  }
}
impl Descriptor {
  #[allow(unused_unsafe, clippy::all)]
  /// Provide file advisory information on a descriptor.
  ///
  /// This is similar to `posix_fadvise` in POSIX.
  #[allow(async_fn_in_trait)]
  pub async fn advise(&self,offset: Filesize,length: Filesize,advice: Advice,) -> Result<(),ErrorCode>{
    unsafe {

      #[derive(Copy, Clone)]
      struct ParamsLower(
      i32, i64, i64, i32, 
      );
      unsafe impl Send for ParamsLower {}
      

      use wit_bindgen::rt::async_support::Subtask as _Subtask;
      struct _MySubtask<'a> { _unused: core::marker::PhantomData<&'a ()> }
      #[allow(unused_parens)]
      unsafe impl<'a> _Subtask for _MySubtask<'a> {
        
        type Params = (&'a Descriptor, Filesize, Filesize, Advice, );
        type Results = Result<(),ErrorCode>;
        type ParamsLower = ParamsLower;
        fn abi_layout(&mut self) -> ::core::alloc::Layout {
          unsafe {
            ::core::alloc::Layout::from_size_align_unchecked(2, 1)
          }
        }
        
        fn results_offset(&mut self) -> usize { 0 }

        unsafe fn call_import(&mut self, _params: Self::ParamsLower, _results: *mut u8) -> u32 {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:filesystem/types@0.3.0-rc-2026-01-06")]
          unsafe extern "C" {
            #[link_name = "[async-lower][method]descriptor.advise"]
            fn call(_: i32, _: i64, _: i64, _: i32, _: *mut u8, ) -> i32;
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn call(_: i32, _: i64, _: i64, _: i32, _: *mut u8, ) -> i32 { unreachable!() }
          
          unsafe { call(_params.0,_params.1,_params.2,_params.3,_results) as u32 }
        }
        
        unsafe fn params_dealloc_lists(&mut self, _params: Self::ParamsLower) {
          unsafe {  }
        }
        unsafe fn params_dealloc_lists_and_own(&mut self, _params: Self::ParamsLower) {
          unsafe {  }
        }
        unsafe fn params_lower(&mut self, (_lower0, _lower1, _lower2, _lower3,): Self::Params, _ptr: *mut u8) -> Self::ParamsLower {
          unsafe {  ParamsLower((_lower0).handle() as i32, _rt::as_i64(_lower1), _rt::as_i64(_lower2), _lower3.clone() as i32,) }
        }
        unsafe fn results_lift(&mut self, _ptr: *mut u8) -> Self::Results {
          unsafe { let l0 = i32::from(*_ptr.add(0).cast::<u8>());

          match l0 {
            0 => {
              let e = ();
              Ok(e)
            }
            1 => {
              let e = {
                let l1 = i32::from(*_ptr.add(1).cast::<u8>());

                ErrorCode::_lift(l1 as u8)
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          } }
        }
      }
      _MySubtask { _unused: core::marker::PhantomData }.call((self, offset, length, advice,)).await
    }
  }
}
impl Descriptor {
  #[allow(unused_unsafe, clippy::all)]
  /// Synchronize the data of a file to disk.
  ///
  /// This function succeeds with no effect if the file descriptor is not
  /// opened for writing.
  ///
  /// Note: This is similar to `fdatasync` in POSIX.
  #[allow(async_fn_in_trait)]
  pub async fn sync_data(&self,) -> Result<(),ErrorCode>{
    unsafe {

      #[derive(Copy, Clone)]
      struct ParamsLower(
      i32, 
      );
      unsafe impl Send for ParamsLower {}
      

      use wit_bindgen::rt::async_support::Subtask as _Subtask;
      struct _MySubtask<'a> { _unused: core::marker::PhantomData<&'a ()> }
      #[allow(unused_parens)]
      unsafe impl<'a> _Subtask for _MySubtask<'a> {
        
        type Params = (&'a Descriptor, );
        type Results = Result<(),ErrorCode>;
        type ParamsLower = ParamsLower;
        fn abi_layout(&mut self) -> ::core::alloc::Layout {
          unsafe {
            ::core::alloc::Layout::from_size_align_unchecked(2, 1)
          }
        }
        
        fn results_offset(&mut self) -> usize { 0 }

        unsafe fn call_import(&mut self, _params: Self::ParamsLower, _results: *mut u8) -> u32 {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:filesystem/types@0.3.0-rc-2026-01-06")]
          unsafe extern "C" {
            #[link_name = "[async-lower][method]descriptor.sync-data"]
            fn call(_: i32, _: *mut u8, ) -> i32;
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn call(_: i32, _: *mut u8, ) -> i32 { unreachable!() }
          
          unsafe { call(_params.0,_results) as u32 }
        }
        
        unsafe fn params_dealloc_lists(&mut self, _params: Self::ParamsLower) {
          unsafe {  }
        }
        unsafe fn params_dealloc_lists_and_own(&mut self, _params: Self::ParamsLower) {
          unsafe {  }
        }
        unsafe fn params_lower(&mut self, (_lower0,): Self::Params, _ptr: *mut u8) -> Self::ParamsLower {
          unsafe {  ParamsLower((_lower0).handle() as i32,) }
        }
        unsafe fn results_lift(&mut self, _ptr: *mut u8) -> Self::Results {
          unsafe { let l0 = i32::from(*_ptr.add(0).cast::<u8>());

          match l0 {
            0 => {
              let e = ();
              Ok(e)
            }
            1 => {
              let e = {
                let l1 = i32::from(*_ptr.add(1).cast::<u8>());

                ErrorCode::_lift(l1 as u8)
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          } }
        }
      }
      _MySubtask { _unused: core::marker::PhantomData }.call((self,)).await
    }
  }
}
impl Descriptor {
  #[allow(unused_unsafe, clippy::all)]
  /// Get flags associated with a descriptor.
  ///
  /// Note: This returns similar flags to `fcntl(fd, F_GETFL)` in POSIX.
  ///
  /// Note: This returns the value that was the `fs_flags` value returned
  /// from `fdstat_get` in earlier versions of WASI.
  #[allow(async_fn_in_trait)]
  pub async fn get_flags(&self,) -> Result<DescriptorFlags,ErrorCode>{
    unsafe {

      #[derive(Copy, Clone)]
      struct ParamsLower(
      i32, 
      );
      unsafe impl Send for ParamsLower {}
      

      use wit_bindgen::rt::async_support::Subtask as _Subtask;
      struct _MySubtask<'a> { _unused: core::marker::PhantomData<&'a ()> }
      #[allow(unused_parens)]
      unsafe impl<'a> _Subtask for _MySubtask<'a> {
        
        type Params = (&'a Descriptor, );
        type Results = Result<DescriptorFlags,ErrorCode>;
        type ParamsLower = ParamsLower;
        fn abi_layout(&mut self) -> ::core::alloc::Layout {
          unsafe {
            ::core::alloc::Layout::from_size_align_unchecked(2, 1)
          }
        }
        
        fn results_offset(&mut self) -> usize { 0 }

        unsafe fn call_import(&mut self, _params: Self::ParamsLower, _results: *mut u8) -> u32 {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:filesystem/types@0.3.0-rc-2026-01-06")]
          unsafe extern "C" {
            #[link_name = "[async-lower][method]descriptor.get-flags"]
            fn call(_: i32, _: *mut u8, ) -> i32;
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn call(_: i32, _: *mut u8, ) -> i32 { unreachable!() }
          
          unsafe { call(_params.0,_results) as u32 }
        }
        
        unsafe fn params_dealloc_lists(&mut self, _params: Self::ParamsLower) {
          unsafe {  }
        }
        unsafe fn params_dealloc_lists_and_own(&mut self, _params: Self::ParamsLower) {
          unsafe {  }
        }
        unsafe fn params_lower(&mut self, (_lower0,): Self::Params, _ptr: *mut u8) -> Self::ParamsLower {
          unsafe {  ParamsLower((_lower0).handle() as i32,) }
        }
        unsafe fn results_lift(&mut self, _ptr: *mut u8) -> Self::Results {
          unsafe { let l0 = i32::from(*_ptr.add(0).cast::<u8>());

          match l0 {
            0 => {
              let e = {
                let l1 = i32::from(*_ptr.add(1).cast::<u8>());

                DescriptorFlags::empty() | DescriptorFlags::from_bits_retain(((l1 as u8) << 0) as _)
              };
              Ok(e)
            }
            1 => {
              let e = {
                let l2 = i32::from(*_ptr.add(1).cast::<u8>());

                ErrorCode::_lift(l2 as u8)
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          } }
        }
      }
      _MySubtask { _unused: core::marker::PhantomData }.call((self,)).await
    }
  }
}
impl Descriptor {
  #[allow(unused_unsafe, clippy::all)]
  /// Get the dynamic type of a descriptor.
  ///
  /// Note: This returns the same value as the `type` field of the `fd-stat`
  /// returned by `stat`, `stat-at` and similar.
  ///
  /// Note: This returns similar flags to the `st_mode & S_IFMT` value provided
  /// by `fstat` in POSIX.
  ///
  /// Note: This returns the value that was the `fs_filetype` value returned
  /// from `fdstat_get` in earlier versions of WASI.
  #[allow(async_fn_in_trait)]
  pub async fn get_type(&self,) -> Result<DescriptorType,ErrorCode>{
    unsafe {

      #[derive(Copy, Clone)]
      struct ParamsLower(
      i32, 
      );
      unsafe impl Send for ParamsLower {}
      

      use wit_bindgen::rt::async_support::Subtask as _Subtask;
      struct _MySubtask<'a> { _unused: core::marker::PhantomData<&'a ()> }
      #[allow(unused_parens)]
      unsafe impl<'a> _Subtask for _MySubtask<'a> {
        
        type Params = (&'a Descriptor, );
        type Results = Result<DescriptorType,ErrorCode>;
        type ParamsLower = ParamsLower;
        fn abi_layout(&mut self) -> ::core::alloc::Layout {
          unsafe {
            ::core::alloc::Layout::from_size_align_unchecked(2, 1)
          }
        }
        
        fn results_offset(&mut self) -> usize { 0 }

        unsafe fn call_import(&mut self, _params: Self::ParamsLower, _results: *mut u8) -> u32 {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:filesystem/types@0.3.0-rc-2026-01-06")]
          unsafe extern "C" {
            #[link_name = "[async-lower][method]descriptor.get-type"]
            fn call(_: i32, _: *mut u8, ) -> i32;
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn call(_: i32, _: *mut u8, ) -> i32 { unreachable!() }
          
          unsafe { call(_params.0,_results) as u32 }
        }
        
        unsafe fn params_dealloc_lists(&mut self, _params: Self::ParamsLower) {
          unsafe {  }
        }
        unsafe fn params_dealloc_lists_and_own(&mut self, _params: Self::ParamsLower) {
          unsafe {  }
        }
        unsafe fn params_lower(&mut self, (_lower0,): Self::Params, _ptr: *mut u8) -> Self::ParamsLower {
          unsafe {  ParamsLower((_lower0).handle() as i32,) }
        }
        unsafe fn results_lift(&mut self, _ptr: *mut u8) -> Self::Results {
          unsafe { let l0 = i32::from(*_ptr.add(0).cast::<u8>());

          match l0 {
            0 => {
              let e = {
                let l1 = i32::from(*_ptr.add(1).cast::<u8>());

                DescriptorType::_lift(l1 as u8)
              };
              Ok(e)
            }
            1 => {
              let e = {
                let l2 = i32::from(*_ptr.add(1).cast::<u8>());

                ErrorCode::_lift(l2 as u8)
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          } }
        }
      }
      _MySubtask { _unused: core::marker::PhantomData }.call((self,)).await
    }
  }
}
impl Descriptor {
  #[allow(unused_unsafe, clippy::all)]
  /// Adjust the size of an open file. If this increases the file's size, the
  /// extra bytes are filled with zeros.
  ///
  /// Note: This was called `fd_filestat_set_size` in earlier versions of WASI.
  #[allow(async_fn_in_trait)]
  pub async fn set_size(&self,size: Filesize,) -> Result<(),ErrorCode>{
    unsafe {

      #[derive(Copy, Clone)]
      struct ParamsLower(
      i32, i64, 
      );
      unsafe impl Send for ParamsLower {}
      

      use wit_bindgen::rt::async_support::Subtask as _Subtask;
      struct _MySubtask<'a> { _unused: core::marker::PhantomData<&'a ()> }
      #[allow(unused_parens)]
      unsafe impl<'a> _Subtask for _MySubtask<'a> {
        
        type Params = (&'a Descriptor, Filesize, );
        type Results = Result<(),ErrorCode>;
        type ParamsLower = ParamsLower;
        fn abi_layout(&mut self) -> ::core::alloc::Layout {
          unsafe {
            ::core::alloc::Layout::from_size_align_unchecked(2, 1)
          }
        }
        
        fn results_offset(&mut self) -> usize { 0 }

        unsafe fn call_import(&mut self, _params: Self::ParamsLower, _results: *mut u8) -> u32 {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:filesystem/types@0.3.0-rc-2026-01-06")]
          unsafe extern "C" {
            #[link_name = "[async-lower][method]descriptor.set-size"]
            fn call(_: i32, _: i64, _: *mut u8, ) -> i32;
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn call(_: i32, _: i64, _: *mut u8, ) -> i32 { unreachable!() }
          
          unsafe { call(_params.0,_params.1,_results) as u32 }
        }
        
        unsafe fn params_dealloc_lists(&mut self, _params: Self::ParamsLower) {
          unsafe {  }
        }
        unsafe fn params_dealloc_lists_and_own(&mut self, _params: Self::ParamsLower) {
          unsafe {  }
        }
        unsafe fn params_lower(&mut self, (_lower0, _lower1,): Self::Params, _ptr: *mut u8) -> Self::ParamsLower {
          unsafe {  ParamsLower((_lower0).handle() as i32, _rt::as_i64(_lower1),) }
        }
        unsafe fn results_lift(&mut self, _ptr: *mut u8) -> Self::Results {
          unsafe { let l0 = i32::from(*_ptr.add(0).cast::<u8>());

          match l0 {
            0 => {
              let e = ();
              Ok(e)
            }
            1 => {
              let e = {
                let l1 = i32::from(*_ptr.add(1).cast::<u8>());

                ErrorCode::_lift(l1 as u8)
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          } }
        }
      }
      _MySubtask { _unused: core::marker::PhantomData }.call((self, size,)).await
    }
  }
}
impl Descriptor {
  #[allow(unused_unsafe, clippy::all)]
  /// Adjust the timestamps of an open file or directory.
  ///
  /// Note: This is similar to `futimens` in POSIX.
  ///
  /// Note: This was called `fd_filestat_set_times` in earlier versions of WASI.
  #[allow(async_fn_in_trait)]
  pub async fn set_times(&self,data_access_timestamp: NewTimestamp,data_modification_timestamp: NewTimestamp,) -> Result<(),ErrorCode>{
    unsafe {

      #[derive(Copy, Clone)]
      struct ParamsLower(
      *mut u8, 
      );
      unsafe impl Send for ParamsLower {}
      

      use wit_bindgen::rt::async_support::Subtask as _Subtask;
      struct _MySubtask<'a> { _unused: core::marker::PhantomData<&'a ()> }
      #[allow(unused_parens)]
      unsafe impl<'a> _Subtask for _MySubtask<'a> {
        
        type Params = (&'a Descriptor, NewTimestamp, NewTimestamp, );
        type Results = Result<(),ErrorCode>;
        type ParamsLower = ParamsLower;
        fn abi_layout(&mut self) -> ::core::alloc::Layout {
          unsafe {
            ::core::alloc::Layout::from_size_align_unchecked(64, 8)
          }
        }
        
        fn results_offset(&mut self) -> usize { 56 }

        unsafe fn call_import(&mut self, _params: Self::ParamsLower, _results: *mut u8) -> u32 {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:filesystem/types@0.3.0-rc-2026-01-06")]
          unsafe extern "C" {
            #[link_name = "[async-lower][method]descriptor.set-times"]
            fn call(_: *mut u8, _: *mut u8, ) -> i32;
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn call(_: *mut u8, _: *mut u8, ) -> i32 { unreachable!() }
          
          unsafe { call(_params.0,_results) as u32 }
        }
        
        unsafe fn params_dealloc_lists(&mut self, _params: Self::ParamsLower) {
          unsafe {  }
        }
        unsafe fn params_dealloc_lists_and_own(&mut self, _params: Self::ParamsLower) {
          unsafe {  }
        }
        unsafe fn params_lower(&mut self, (_lower0, _lower1, _lower2,): Self::Params, _ptr: *mut u8) -> Self::ParamsLower {
          let _param_ptr = unsafe { _ptr.add(0) };
          unsafe { *_param_ptr.add(0).cast::<i32>() = (_lower0).handle() as i32;
        }
        let _param_ptr = unsafe { _ptr.add(8) };
        unsafe { match _lower1 {
          NewTimestamp::NoChange=> {
            {
              *_param_ptr.add(0).cast::<u8>() = (0i32) as u8;
            }
          }
          NewTimestamp::Now=> {
            {
              *_param_ptr.add(0).cast::<u8>() = (1i32) as u8;
            }
          }
          NewTimestamp::Timestamp(e) => {
            *_param_ptr.add(0).cast::<u8>() = (2i32) as u8;
            let super::super::super::wasi::clocks::system_clock::Instant{ seconds:seconds0, nanoseconds:nanoseconds0, } = e;
            *_param_ptr.add(8).cast::<i64>() = _rt::as_i64(seconds0);
            *_param_ptr.add(16).cast::<i32>() = _rt::as_i32(nanoseconds0);
          },
        }
      }
      let _param_ptr = unsafe { _ptr.add(32) };
      unsafe { match _lower2 {
        NewTimestamp::NoChange=> {
          {
            *_param_ptr.add(0).cast::<u8>() = (0i32) as u8;
          }
        }
        NewTimestamp::Now=> {
          {
            *_param_ptr.add(0).cast::<u8>() = (1i32) as u8;
          }
        }
        NewTimestamp::Timestamp(e) => {
          *_param_ptr.add(0).cast::<u8>() = (2i32) as u8;
          let super::super::super::wasi::clocks::system_clock::Instant{ seconds:seconds0, nanoseconds:nanoseconds0, } = e;
          *_param_ptr.add(8).cast::<i64>() = _rt::as_i64(seconds0);
          *_param_ptr.add(16).cast::<i32>() = _rt::as_i32(nanoseconds0);
        },
      }
    }
    ParamsLower(_ptr,)
  }
  unsafe fn results_lift(&mut self, _ptr: *mut u8) -> Self::Results {
    unsafe { let l0 = i32::from(*_ptr.add(0).cast::<u8>());

    match l0 {
      0 => {
        let e = ();
        Ok(e)
      }
      1 => {
        let e = {
          let l1 = i32::from(*_ptr.add(1).cast::<u8>());

          ErrorCode::_lift(l1 as u8)
        };
        Err(e)
      }
      _ => _rt::invalid_enum_discriminant(),
    } }
  }
}
_MySubtask { _unused: core::marker::PhantomData }.call((self, data_access_timestamp, data_modification_timestamp,)).await
}
}
}
impl Descriptor {
  #[allow(unused_unsafe, clippy::all)]
  /// Read directory entries from a directory.
  ///
  /// On filesystems where directories contain entries referring to themselves
  /// and their parents, often named `.` and `..` respectively, these entries
  /// are omitted.
  ///
  /// This always returns a new stream which starts at the beginning of the
  /// directory. Multiple streams may be active on the same directory, and they
  /// do not interfere with each other.
  ///
  /// This function returns a future, which will resolve to an error code if
  /// reading full contents of the directory fails.
  #[allow(async_fn_in_trait)]
  pub async fn read_directory(&self,) -> (wit_bindgen::rt::async_support::StreamReader<DirectoryEntry>,wit_bindgen::rt::async_support::FutureReader<Result<(),ErrorCode>>,){
    unsafe {

      #[derive(Copy, Clone)]
      struct ParamsLower(
      i32, 
      );
      unsafe impl Send for ParamsLower {}
      

      use wit_bindgen::rt::async_support::Subtask as _Subtask;
      struct _MySubtask<'a> { _unused: core::marker::PhantomData<&'a ()> }
      #[allow(unused_parens)]
      unsafe impl<'a> _Subtask for _MySubtask<'a> {
        
        type Params = (&'a Descriptor, );
        type Results = (wit_bindgen::rt::async_support::StreamReader<DirectoryEntry>,wit_bindgen::rt::async_support::FutureReader<Result<(),ErrorCode>>,);
        type ParamsLower = ParamsLower;
        fn abi_layout(&mut self) -> ::core::alloc::Layout {
          unsafe {
            ::core::alloc::Layout::from_size_align_unchecked(8, 4)
          }
        }
        
        fn results_offset(&mut self) -> usize { 0 }

        unsafe fn call_import(&mut self, _params: Self::ParamsLower, _results: *mut u8) -> u32 {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:filesystem/types@0.3.0-rc-2026-01-06")]
          unsafe extern "C" {
            #[link_name = "[async-lower][method]descriptor.read-directory"]
            fn call(_: i32, _: *mut u8, ) -> i32;
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn call(_: i32, _: *mut u8, ) -> i32 { unreachable!() }
          
          unsafe { call(_params.0,_results) as u32 }
        }
        
        unsafe fn params_dealloc_lists(&mut self, _params: Self::ParamsLower) {
          unsafe {  }
        }
        unsafe fn params_dealloc_lists_and_own(&mut self, _params: Self::ParamsLower) {
          unsafe {  }
        }
        unsafe fn params_lower(&mut self, (_lower0,): Self::Params, _ptr: *mut u8) -> Self::ParamsLower {
          unsafe {  ParamsLower((_lower0).handle() as i32,) }
        }
        unsafe fn results_lift(&mut self, _ptr: *mut u8) -> Self::Results {
          unsafe { let l0 = *_ptr.add(0).cast::<i32>();
          let l1 = *_ptr.add(4).cast::<i32>();

          (wit_bindgen::rt::async_support::StreamReader::new(l0 as u32, &super::super::super::wit_stream::vtable1::VTABLE), wit_bindgen::rt::async_support::FutureReader::new(l1 as u32, &super::super::super::wit_future::vtable1::VTABLE)) }
        }
      }
      _MySubtask { _unused: core::marker::PhantomData }.call((self,)).await
    }
  }
}
impl Descriptor {
  #[allow(unused_unsafe, clippy::all)]
  /// Synchronize the data and metadata of a file to disk.
  ///
  /// This function succeeds with no effect if the file descriptor is not
  /// opened for writing.
  ///
  /// Note: This is similar to `fsync` in POSIX.
  #[allow(async_fn_in_trait)]
  pub async fn sync(&self,) -> Result<(),ErrorCode>{
    unsafe {

      #[derive(Copy, Clone)]
      struct ParamsLower(
      i32, 
      );
      unsafe impl Send for ParamsLower {}
      

      use wit_bindgen::rt::async_support::Subtask as _Subtask;
      struct _MySubtask<'a> { _unused: core::marker::PhantomData<&'a ()> }
      #[allow(unused_parens)]
      unsafe impl<'a> _Subtask for _MySubtask<'a> {
        
        type Params = (&'a Descriptor, );
        type Results = Result<(),ErrorCode>;
        type ParamsLower = ParamsLower;
        fn abi_layout(&mut self) -> ::core::alloc::Layout {
          unsafe {
            ::core::alloc::Layout::from_size_align_unchecked(2, 1)
          }
        }
        
        fn results_offset(&mut self) -> usize { 0 }

        unsafe fn call_import(&mut self, _params: Self::ParamsLower, _results: *mut u8) -> u32 {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:filesystem/types@0.3.0-rc-2026-01-06")]
          unsafe extern "C" {
            #[link_name = "[async-lower][method]descriptor.sync"]
            fn call(_: i32, _: *mut u8, ) -> i32;
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn call(_: i32, _: *mut u8, ) -> i32 { unreachable!() }
          
          unsafe { call(_params.0,_results) as u32 }
        }
        
        unsafe fn params_dealloc_lists(&mut self, _params: Self::ParamsLower) {
          unsafe {  }
        }
        unsafe fn params_dealloc_lists_and_own(&mut self, _params: Self::ParamsLower) {
          unsafe {  }
        }
        unsafe fn params_lower(&mut self, (_lower0,): Self::Params, _ptr: *mut u8) -> Self::ParamsLower {
          unsafe {  ParamsLower((_lower0).handle() as i32,) }
        }
        unsafe fn results_lift(&mut self, _ptr: *mut u8) -> Self::Results {
          unsafe { let l0 = i32::from(*_ptr.add(0).cast::<u8>());

          match l0 {
            0 => {
              let e = ();
              Ok(e)
            }
            1 => {
              let e = {
                let l1 = i32::from(*_ptr.add(1).cast::<u8>());

                ErrorCode::_lift(l1 as u8)
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          } }
        }
      }
      _MySubtask { _unused: core::marker::PhantomData }.call((self,)).await
    }
  }
}
impl Descriptor {
  #[allow(unused_unsafe, clippy::all)]
  /// Create a directory.
  ///
  /// Note: This is similar to `mkdirat` in POSIX.
  #[allow(async_fn_in_trait)]
  pub async fn create_directory_at(&self,path: _rt::String,) -> Result<(),ErrorCode>{
    unsafe {

      #[derive(Copy, Clone)]
      struct ParamsLower(
      i32, *mut u8, usize, 
      );
      unsafe impl Send for ParamsLower {}
      

      use wit_bindgen::rt::async_support::Subtask as _Subtask;
      struct _MySubtask<'a> { _unused: core::marker::PhantomData<&'a ()> }
      #[allow(unused_parens)]
      unsafe impl<'a> _Subtask for _MySubtask<'a> {
        
        type Params = (&'a Descriptor, _rt::String, );
        type Results = Result<(),ErrorCode>;
        type ParamsLower = ParamsLower;
        fn abi_layout(&mut self) -> ::core::alloc::Layout {
          unsafe {
            ::core::alloc::Layout::from_size_align_unchecked(2, 1)
          }
        }
        
        fn results_offset(&mut self) -> usize { 0 }

        unsafe fn call_import(&mut self, _params: Self::ParamsLower, _results: *mut u8) -> u32 {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:filesystem/types@0.3.0-rc-2026-01-06")]
          unsafe extern "C" {
            #[link_name = "[async-lower][method]descriptor.create-directory-at"]
            fn call(_: i32, _: *mut u8, _: usize, _: *mut u8, ) -> i32;
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn call(_: i32, _: *mut u8, _: usize, _: *mut u8, ) -> i32 { unreachable!() }
          
          unsafe { call(_params.0,_params.1,_params.2,_results) as u32 }
        }
        
        unsafe fn params_dealloc_lists(&mut self, _params: Self::ParamsLower) {
          unsafe { _rt::cabi_dealloc(_params.1, _params.2, 1);
        }
      }
      unsafe fn params_dealloc_lists_and_own(&mut self, _params: Self::ParamsLower) {
        unsafe { _rt::cabi_dealloc(_params.1, _params.2, 1);
      }
    }
    unsafe fn params_lower(&mut self, (_lower0, _lower1,): Self::Params, _ptr: *mut u8) -> Self::ParamsLower {
      unsafe { let vec0 = (_lower1.into_bytes()).into_boxed_slice();
      let ptr0 = vec0.as_ptr().cast::<u8>();
      let len0 = vec0.len();
      ::core::mem::forget(vec0);
      ParamsLower((_lower0).handle() as i32, ptr0.cast_mut(), len0,) }
    }
    unsafe fn results_lift(&mut self, _ptr: *mut u8) -> Self::Results {
      unsafe { let l0 = i32::from(*_ptr.add(0).cast::<u8>());

      match l0 {
        0 => {
          let e = ();
          Ok(e)
        }
        1 => {
          let e = {
            let l1 = i32::from(*_ptr.add(1).cast::<u8>());

            ErrorCode::_lift(l1 as u8)
          };
          Err(e)
        }
        _ => _rt::invalid_enum_discriminant(),
      } }
    }
  }
  _MySubtask { _unused: core::marker::PhantomData }.call((self, path,)).await
}
}
}
impl Descriptor {
  #[allow(unused_unsafe, clippy::all)]
  /// Return the attributes of an open file or directory.
  ///
  /// Note: This is similar to `fstat` in POSIX, except that it does not return
  /// device and inode information. For testing whether two descriptors refer to
  /// the same underlying filesystem object, use `is-same-object`. To obtain
  /// additional data that can be used do determine whether a file has been
  /// modified, use `metadata-hash`.
  ///
  /// Note: This was called `fd_filestat_get` in earlier versions of WASI.
  #[allow(async_fn_in_trait)]
  pub async fn stat(&self,) -> Result<DescriptorStat,ErrorCode>{
    unsafe {

      #[derive(Copy, Clone)]
      struct ParamsLower(
      i32, 
      );
      unsafe impl Send for ParamsLower {}
      

      use wit_bindgen::rt::async_support::Subtask as _Subtask;
      struct _MySubtask<'a> { _unused: core::marker::PhantomData<&'a ()> }
      #[allow(unused_parens)]
      unsafe impl<'a> _Subtask for _MySubtask<'a> {
        
        type Params = (&'a Descriptor, );
        type Results = Result<DescriptorStat,ErrorCode>;
        type ParamsLower = ParamsLower;
        fn abi_layout(&mut self) -> ::core::alloc::Layout {
          unsafe {
            ::core::alloc::Layout::from_size_align_unchecked(104, 8)
          }
        }
        
        fn results_offset(&mut self) -> usize { 0 }

        unsafe fn call_import(&mut self, _params: Self::ParamsLower, _results: *mut u8) -> u32 {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:filesystem/types@0.3.0-rc-2026-01-06")]
          unsafe extern "C" {
            #[link_name = "[async-lower][method]descriptor.stat"]
            fn call(_: i32, _: *mut u8, ) -> i32;
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn call(_: i32, _: *mut u8, ) -> i32 { unreachable!() }
          
          unsafe { call(_params.0,_results) as u32 }
        }
        
        unsafe fn params_dealloc_lists(&mut self, _params: Self::ParamsLower) {
          unsafe {  }
        }
        unsafe fn params_dealloc_lists_and_own(&mut self, _params: Self::ParamsLower) {
          unsafe {  }
        }
        unsafe fn params_lower(&mut self, (_lower0,): Self::Params, _ptr: *mut u8) -> Self::ParamsLower {
          unsafe {  ParamsLower((_lower0).handle() as i32,) }
        }
        unsafe fn results_lift(&mut self, _ptr: *mut u8) -> Self::Results {
          unsafe { let l0 = i32::from(*_ptr.add(0).cast::<u8>());

          match l0 {
            0 => {
              let e = {
                let l1 = i32::from(*_ptr.add(8).cast::<u8>());
                let l2 = *_ptr.add(16).cast::<i64>();
                let l3 = *_ptr.add(24).cast::<i64>();
                let l4 = i32::from(*_ptr.add(32).cast::<u8>());
                let l7 = i32::from(*_ptr.add(56).cast::<u8>());
                let l10 = i32::from(*_ptr.add(80).cast::<u8>());

                DescriptorStat{
                  type_: DescriptorType::_lift(l1 as u8),
                  link_count: l2 as u64,
                  size: l3 as u64,
                  data_access_timestamp: match l4 {
                    0 => None,
                    1 => {
                      let e = {
                        let l5 = *_ptr.add(40).cast::<i64>();
                        let l6 = *_ptr.add(48).cast::<i32>();

                        super::super::super::wasi::clocks::system_clock::Instant{
                          seconds: l5,
                          nanoseconds: l6 as u32,
                        }
                      };
                      Some(e)
                    }
                    _ => _rt::invalid_enum_discriminant(),
                  },
                  data_modification_timestamp: match l7 {
                    0 => None,
                    1 => {
                      let e = {
                        let l8 = *_ptr.add(64).cast::<i64>();
                        let l9 = *_ptr.add(72).cast::<i32>();

                        super::super::super::wasi::clocks::system_clock::Instant{
                          seconds: l8,
                          nanoseconds: l9 as u32,
                        }
                      };
                      Some(e)
                    }
                    _ => _rt::invalid_enum_discriminant(),
                  },
                  status_change_timestamp: match l10 {
                    0 => None,
                    1 => {
                      let e = {
                        let l11 = *_ptr.add(88).cast::<i64>();
                        let l12 = *_ptr.add(96).cast::<i32>();

                        super::super::super::wasi::clocks::system_clock::Instant{
                          seconds: l11,
                          nanoseconds: l12 as u32,
                        }
                      };
                      Some(e)
                    }
                    _ => _rt::invalid_enum_discriminant(),
                  },
                }
              };
              Ok(e)
            }
            1 => {
              let e = {
                let l13 = i32::from(*_ptr.add(8).cast::<u8>());

                ErrorCode::_lift(l13 as u8)
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          } }
        }
      }
      _MySubtask { _unused: core::marker::PhantomData }.call((self,)).await
    }
  }
}
impl Descriptor {
  #[allow(unused_unsafe, clippy::all)]
  /// Return the attributes of a file or directory.
  ///
  /// Note: This is similar to `fstatat` in POSIX, except that it does not
  /// return device and inode information. See the `stat` description for a
  /// discussion of alternatives.
  ///
  /// Note: This was called `path_filestat_get` in earlier versions of WASI.
  #[allow(async_fn_in_trait)]
  pub async fn stat_at(&self,path_flags: PathFlags,path: _rt::String,) -> Result<DescriptorStat,ErrorCode>{
    unsafe {

      #[derive(Copy, Clone)]
      struct ParamsLower(
      i32, i32, *mut u8, usize, 
      );
      unsafe impl Send for ParamsLower {}
      

      use wit_bindgen::rt::async_support::Subtask as _Subtask;
      struct _MySubtask<'a> { _unused: core::marker::PhantomData<&'a ()> }
      #[allow(unused_parens)]
      unsafe impl<'a> _Subtask for _MySubtask<'a> {
        
        type Params = (&'a Descriptor, PathFlags, _rt::String, );
        type Results = Result<DescriptorStat,ErrorCode>;
        type ParamsLower = ParamsLower;
        fn abi_layout(&mut self) -> ::core::alloc::Layout {
          unsafe {
            ::core::alloc::Layout::from_size_align_unchecked(104, 8)
          }
        }
        
        fn results_offset(&mut self) -> usize { 0 }

        unsafe fn call_import(&mut self, _params: Self::ParamsLower, _results: *mut u8) -> u32 {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:filesystem/types@0.3.0-rc-2026-01-06")]
          unsafe extern "C" {
            #[link_name = "[async-lower][method]descriptor.stat-at"]
            fn call(_: i32, _: i32, _: *mut u8, _: usize, _: *mut u8, ) -> i32;
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn call(_: i32, _: i32, _: *mut u8, _: usize, _: *mut u8, ) -> i32 { unreachable!() }
          
          unsafe { call(_params.0,_params.1,_params.2,_params.3,_results) as u32 }
        }
        
        unsafe fn params_dealloc_lists(&mut self, _params: Self::ParamsLower) {
          unsafe { _rt::cabi_dealloc(_params.2, _params.3, 1);
        }
      }
      unsafe fn params_dealloc_lists_and_own(&mut self, _params: Self::ParamsLower) {
        unsafe { _rt::cabi_dealloc(_params.2, _params.3, 1);
      }
    }
    unsafe fn params_lower(&mut self, (_lower0, _lower1, _lower2,): Self::Params, _ptr: *mut u8) -> Self::ParamsLower {
      unsafe { let flags0 = _lower1;
      let vec1 = (_lower2.into_bytes()).into_boxed_slice();
      let ptr1 = vec1.as_ptr().cast::<u8>();
      let len1 = vec1.len();
      ::core::mem::forget(vec1);
      ParamsLower((_lower0).handle() as i32, (flags0.bits() >> 0) as i32, ptr1.cast_mut(), len1,) }
    }
    unsafe fn results_lift(&mut self, _ptr: *mut u8) -> Self::Results {
      unsafe { let l0 = i32::from(*_ptr.add(0).cast::<u8>());

      match l0 {
        0 => {
          let e = {
            let l1 = i32::from(*_ptr.add(8).cast::<u8>());
            let l2 = *_ptr.add(16).cast::<i64>();
            let l3 = *_ptr.add(24).cast::<i64>();
            let l4 = i32::from(*_ptr.add(32).cast::<u8>());
            let l7 = i32::from(*_ptr.add(56).cast::<u8>());
            let l10 = i32::from(*_ptr.add(80).cast::<u8>());

            DescriptorStat{
              type_: DescriptorType::_lift(l1 as u8),
              link_count: l2 as u64,
              size: l3 as u64,
              data_access_timestamp: match l4 {
                0 => None,
                1 => {
                  let e = {
                    let l5 = *_ptr.add(40).cast::<i64>();
                    let l6 = *_ptr.add(48).cast::<i32>();

                    super::super::super::wasi::clocks::system_clock::Instant{
                      seconds: l5,
                      nanoseconds: l6 as u32,
                    }
                  };
                  Some(e)
                }
                _ => _rt::invalid_enum_discriminant(),
              },
              data_modification_timestamp: match l7 {
                0 => None,
                1 => {
                  let e = {
                    let l8 = *_ptr.add(64).cast::<i64>();
                    let l9 = *_ptr.add(72).cast::<i32>();

                    super::super::super::wasi::clocks::system_clock::Instant{
                      seconds: l8,
                      nanoseconds: l9 as u32,
                    }
                  };
                  Some(e)
                }
                _ => _rt::invalid_enum_discriminant(),
              },
              status_change_timestamp: match l10 {
                0 => None,
                1 => {
                  let e = {
                    let l11 = *_ptr.add(88).cast::<i64>();
                    let l12 = *_ptr.add(96).cast::<i32>();

                    super::super::super::wasi::clocks::system_clock::Instant{
                      seconds: l11,
                      nanoseconds: l12 as u32,
                    }
                  };
                  Some(e)
                }
                _ => _rt::invalid_enum_discriminant(),
              },
            }
          };
          Ok(e)
        }
        1 => {
          let e = {
            let l13 = i32::from(*_ptr.add(8).cast::<u8>());

            ErrorCode::_lift(l13 as u8)
          };
          Err(e)
        }
        _ => _rt::invalid_enum_discriminant(),
      } }
    }
  }
  _MySubtask { _unused: core::marker::PhantomData }.call((self, path_flags, path,)).await
}
}
}
impl Descriptor {
  #[allow(unused_unsafe, clippy::all)]
  /// Adjust the timestamps of a file or directory.
  ///
  /// Note: This is similar to `utimensat` in POSIX.
  ///
  /// Note: This was called `path_filestat_set_times` in earlier versions of
  /// WASI.
  #[allow(async_fn_in_trait)]
  pub async fn set_times_at(&self,path_flags: PathFlags,path: _rt::String,data_access_timestamp: NewTimestamp,data_modification_timestamp: NewTimestamp,) -> Result<(),ErrorCode>{
    unsafe {

      #[derive(Copy, Clone)]
      struct ParamsLower(
      *mut u8, 
      );
      unsafe impl Send for ParamsLower {}
      

      use wit_bindgen::rt::async_support::Subtask as _Subtask;
      struct _MySubtask<'a> { _unused: core::marker::PhantomData<&'a ()> }
      #[allow(unused_parens)]
      unsafe impl<'a> _Subtask for _MySubtask<'a> {
        
        type Params = (&'a Descriptor, PathFlags, _rt::String, NewTimestamp, NewTimestamp, );
        type Results = Result<(),ErrorCode>;
        type ParamsLower = ParamsLower;
        fn abi_layout(&mut self) -> ::core::alloc::Layout {
          unsafe {
            ::core::alloc::Layout::from_size_align_unchecked((64+2*::core::mem::size_of::<*const u8>()), 8)
          }
        }
        
        fn results_offset(&mut self) -> usize { (56+2*::core::mem::size_of::<*const u8>()) }

        unsafe fn call_import(&mut self, _params: Self::ParamsLower, _results: *mut u8) -> u32 {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:filesystem/types@0.3.0-rc-2026-01-06")]
          unsafe extern "C" {
            #[link_name = "[async-lower][method]descriptor.set-times-at"]
            fn call(_: *mut u8, _: *mut u8, ) -> i32;
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn call(_: *mut u8, _: *mut u8, ) -> i32 { unreachable!() }
          
          unsafe { call(_params.0,_results) as u32 }
        }
        
        unsafe fn params_dealloc_lists(&mut self, _params: Self::ParamsLower) {
          unsafe { let l0 = *_params.0.add(8).cast::<*mut u8>();
          let l1 = *_params.0.add(8+1*::core::mem::size_of::<*const u8>()).cast::<usize>();
          _rt::cabi_dealloc(l0, l1, 1);
        }
      }
      unsafe fn params_dealloc_lists_and_own(&mut self, _params: Self::ParamsLower) {
        unsafe { let l0 = *_params.0.add(8).cast::<*mut u8>();
        let l1 = *_params.0.add(8+1*::core::mem::size_of::<*const u8>()).cast::<usize>();
        _rt::cabi_dealloc(l0, l1, 1);
      }
    }
    unsafe fn params_lower(&mut self, (_lower0, _lower1, _lower2, _lower3, _lower4,): Self::Params, _ptr: *mut u8) -> Self::ParamsLower {
      let _param_ptr = unsafe { _ptr.add(0) };
      unsafe { *_param_ptr.add(0).cast::<i32>() = (_lower0).handle() as i32;
    }
    let _param_ptr = unsafe { _ptr.add(4) };
    unsafe { let flags0 = _lower1;
    *_param_ptr.add(0).cast::<u8>() = ((flags0.bits() >> 0) as i32) as u8;
  }
  let _param_ptr = unsafe { _ptr.add(8) };
  unsafe { let vec0 = (_lower2.into_bytes()).into_boxed_slice();
  let ptr0 = vec0.as_ptr().cast::<u8>();
  let len0 = vec0.len();
  ::core::mem::forget(vec0);
  *_param_ptr.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len0;
  *_param_ptr.add(0).cast::<*mut u8>() = ptr0.cast_mut();
}
let _param_ptr = unsafe { _ptr.add((8+2*::core::mem::size_of::<*const u8>())) };
unsafe { match _lower3 {
  NewTimestamp::NoChange=> {
    {
      *_param_ptr.add(0).cast::<u8>() = (0i32) as u8;
    }
  }
  NewTimestamp::Now=> {
    {
      *_param_ptr.add(0).cast::<u8>() = (1i32) as u8;
    }
  }
  NewTimestamp::Timestamp(e) => {
    *_param_ptr.add(0).cast::<u8>() = (2i32) as u8;
    let super::super::super::wasi::clocks::system_clock::Instant{ seconds:seconds0, nanoseconds:nanoseconds0, } = e;
    *_param_ptr.add(8).cast::<i64>() = _rt::as_i64(seconds0);
    *_param_ptr.add(16).cast::<i32>() = _rt::as_i32(nanoseconds0);
  },
}
}
let _param_ptr = unsafe { _ptr.add((32+2*::core::mem::size_of::<*const u8>())) };
unsafe { match _lower4 {
  NewTimestamp::NoChange=> {
    {
      *_param_ptr.add(0).cast::<u8>() = (0i32) as u8;
    }
  }
  NewTimestamp::Now=> {
    {
      *_param_ptr.add(0).cast::<u8>() = (1i32) as u8;
    }
  }
  NewTimestamp::Timestamp(e) => {
    *_param_ptr.add(0).cast::<u8>() = (2i32) as u8;
    let super::super::super::wasi::clocks::system_clock::Instant{ seconds:seconds0, nanoseconds:nanoseconds0, } = e;
    *_param_ptr.add(8).cast::<i64>() = _rt::as_i64(seconds0);
    *_param_ptr.add(16).cast::<i32>() = _rt::as_i32(nanoseconds0);
  },
}
}
ParamsLower(_ptr,)
}
unsafe fn results_lift(&mut self, _ptr: *mut u8) -> Self::Results {
  unsafe { let l0 = i32::from(*_ptr.add(0).cast::<u8>());

  match l0 {
    0 => {
      let e = ();
      Ok(e)
    }
    1 => {
      let e = {
        let l1 = i32::from(*_ptr.add(1).cast::<u8>());

        ErrorCode::_lift(l1 as u8)
      };
      Err(e)
    }
    _ => _rt::invalid_enum_discriminant(),
  } }
}
}
_MySubtask { _unused: core::marker::PhantomData }.call((self, path_flags, path, data_access_timestamp, data_modification_timestamp,)).await
}
}
}
impl Descriptor {
  #[allow(unused_unsafe, clippy::all)]
  /// Create a hard link.
  ///
  /// Fails with `error-code::no-entry` if the old path does not exist,
  /// with `error-code::exist` if the new path already exists, and
  /// `error-code::not-permitted` if the old path is not a file.
  ///
  /// Note: This is similar to `linkat` in POSIX.
  #[allow(async_fn_in_trait)]
  pub async fn link_at(&self,old_path_flags: PathFlags,old_path: _rt::String,new_descriptor: &Descriptor,new_path: _rt::String,) -> Result<(),ErrorCode>{
    unsafe {

      #[derive(Copy, Clone)]
      struct ParamsLower(
      *mut u8, 
      );
      unsafe impl Send for ParamsLower {}
      

      use wit_bindgen::rt::async_support::Subtask as _Subtask;
      struct _MySubtask<'a> { _unused: core::marker::PhantomData<&'a ()> }
      #[allow(unused_parens)]
      unsafe impl<'a> _Subtask for _MySubtask<'a> {
        
        type Params = (&'a Descriptor, PathFlags, _rt::String, &'a Descriptor, _rt::String, );
        type Results = Result<(),ErrorCode>;
        type ParamsLower = ParamsLower;
        fn abi_layout(&mut self) -> ::core::alloc::Layout {
          unsafe {
            ::core::alloc::Layout::from_size_align_unchecked((8+6*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>())
          }
        }
        
        fn results_offset(&mut self) -> usize { (8+5*::core::mem::size_of::<*const u8>()) }

        unsafe fn call_import(&mut self, _params: Self::ParamsLower, _results: *mut u8) -> u32 {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:filesystem/types@0.3.0-rc-2026-01-06")]
          unsafe extern "C" {
            #[link_name = "[async-lower][method]descriptor.link-at"]
            fn call(_: *mut u8, _: *mut u8, ) -> i32;
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn call(_: *mut u8, _: *mut u8, ) -> i32 { unreachable!() }
          
          unsafe { call(_params.0,_results) as u32 }
        }
        
        unsafe fn params_dealloc_lists(&mut self, _params: Self::ParamsLower) {
          unsafe { let l0 = *_params.0.add(8).cast::<*mut u8>();
          let l1 = *_params.0.add(8+1*::core::mem::size_of::<*const u8>()).cast::<usize>();
          _rt::cabi_dealloc(l0, l1, 1);
          let l2 = *_params.0.add(8+3*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
          let l3 = *_params.0.add(8+4*::core::mem::size_of::<*const u8>()).cast::<usize>();
          _rt::cabi_dealloc(l2, l3, 1);
        }
      }
      unsafe fn params_dealloc_lists_and_own(&mut self, _params: Self::ParamsLower) {
        unsafe { let l0 = *_params.0.add(8).cast::<*mut u8>();
        let l1 = *_params.0.add(8+1*::core::mem::size_of::<*const u8>()).cast::<usize>();
        _rt::cabi_dealloc(l0, l1, 1);
        let l2 = *_params.0.add(8+3*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
        let l3 = *_params.0.add(8+4*::core::mem::size_of::<*const u8>()).cast::<usize>();
        _rt::cabi_dealloc(l2, l3, 1);
      }
    }
    unsafe fn params_lower(&mut self, (_lower0, _lower1, _lower2, _lower3, _lower4,): Self::Params, _ptr: *mut u8) -> Self::ParamsLower {
      let _param_ptr = unsafe { _ptr.add(0) };
      unsafe { *_param_ptr.add(0).cast::<i32>() = (_lower0).handle() as i32;
    }
    let _param_ptr = unsafe { _ptr.add(4) };
    unsafe { let flags0 = _lower1;
    *_param_ptr.add(0).cast::<u8>() = ((flags0.bits() >> 0) as i32) as u8;
  }
  let _param_ptr = unsafe { _ptr.add(8) };
  unsafe { let vec0 = (_lower2.into_bytes()).into_boxed_slice();
  let ptr0 = vec0.as_ptr().cast::<u8>();
  let len0 = vec0.len();
  ::core::mem::forget(vec0);
  *_param_ptr.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len0;
  *_param_ptr.add(0).cast::<*mut u8>() = ptr0.cast_mut();
}
let _param_ptr = unsafe { _ptr.add((8+2*::core::mem::size_of::<*const u8>())) };
unsafe { *_param_ptr.add(0).cast::<i32>() = (_lower3).handle() as i32;
}
let _param_ptr = unsafe { _ptr.add((8+3*::core::mem::size_of::<*const u8>())) };
unsafe { let vec0 = (_lower4.into_bytes()).into_boxed_slice();
let ptr0 = vec0.as_ptr().cast::<u8>();
let len0 = vec0.len();
::core::mem::forget(vec0);
*_param_ptr.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len0;
*_param_ptr.add(0).cast::<*mut u8>() = ptr0.cast_mut();
}
ParamsLower(_ptr,)
}
unsafe fn results_lift(&mut self, _ptr: *mut u8) -> Self::Results {
  unsafe { let l0 = i32::from(*_ptr.add(0).cast::<u8>());

  match l0 {
    0 => {
      let e = ();
      Ok(e)
    }
    1 => {
      let e = {
        let l1 = i32::from(*_ptr.add(1).cast::<u8>());

        ErrorCode::_lift(l1 as u8)
      };
      Err(e)
    }
    _ => _rt::invalid_enum_discriminant(),
  } }
}
}
_MySubtask { _unused: core::marker::PhantomData }.call((self, old_path_flags, old_path, new_descriptor, new_path,)).await
}
}
}
impl Descriptor {
  #[allow(unused_unsafe, clippy::all)]
  /// Open a file or directory.
  ///
  /// If `flags` contains `descriptor-flags::mutate-directory`, and the base
  /// descriptor doesn't have `descriptor-flags::mutate-directory` set,
  /// `open-at` fails with `error-code::read-only`.
  ///
  /// If `flags` contains `write` or `mutate-directory`, or `open-flags`
  /// contains `truncate` or `create`, and the base descriptor doesn't have
  /// `descriptor-flags::mutate-directory` set, `open-at` fails with
  /// `error-code::read-only`.
  ///
  /// Note: This is similar to `openat` in POSIX.
  #[allow(async_fn_in_trait)]
  pub async fn open_at(&self,path_flags: PathFlags,path: _rt::String,open_flags: OpenFlags,flags: DescriptorFlags,) -> Result<Descriptor,ErrorCode>{
    unsafe {

      #[derive(Copy, Clone)]
      struct ParamsLower(
      *mut u8, 
      );
      unsafe impl Send for ParamsLower {}
      

      use wit_bindgen::rt::async_support::Subtask as _Subtask;
      struct _MySubtask<'a> { _unused: core::marker::PhantomData<&'a ()> }
      #[allow(unused_parens)]
      unsafe impl<'a> _Subtask for _MySubtask<'a> {
        
        type Params = (&'a Descriptor, PathFlags, _rt::String, OpenFlags, DescriptorFlags, );
        type Results = Result<Descriptor,ErrorCode>;
        type ParamsLower = ParamsLower;
        fn abi_layout(&mut self) -> ::core::alloc::Layout {
          unsafe {
            ::core::alloc::Layout::from_size_align_unchecked((16+3*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>())
          }
        }
        
        fn results_offset(&mut self) -> usize { (12+2*::core::mem::size_of::<*const u8>()) }

        unsafe fn call_import(&mut self, _params: Self::ParamsLower, _results: *mut u8) -> u32 {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:filesystem/types@0.3.0-rc-2026-01-06")]
          unsafe extern "C" {
            #[link_name = "[async-lower][method]descriptor.open-at"]
            fn call(_: *mut u8, _: *mut u8, ) -> i32;
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn call(_: *mut u8, _: *mut u8, ) -> i32 { unreachable!() }
          
          unsafe { call(_params.0,_results) as u32 }
        }
        
        unsafe fn params_dealloc_lists(&mut self, _params: Self::ParamsLower) {
          unsafe { let l0 = *_params.0.add(8).cast::<*mut u8>();
          let l1 = *_params.0.add(8+1*::core::mem::size_of::<*const u8>()).cast::<usize>();
          _rt::cabi_dealloc(l0, l1, 1);
        }
      }
      unsafe fn params_dealloc_lists_and_own(&mut self, _params: Self::ParamsLower) {
        unsafe { let l0 = *_params.0.add(8).cast::<*mut u8>();
        let l1 = *_params.0.add(8+1*::core::mem::size_of::<*const u8>()).cast::<usize>();
        _rt::cabi_dealloc(l0, l1, 1);
      }
    }
    unsafe fn params_lower(&mut self, (_lower0, _lower1, _lower2, _lower3, _lower4,): Self::Params, _ptr: *mut u8) -> Self::ParamsLower {
      let _param_ptr = unsafe { _ptr.add(0) };
      unsafe { *_param_ptr.add(0).cast::<i32>() = (_lower0).handle() as i32;
    }
    let _param_ptr = unsafe { _ptr.add(4) };
    unsafe { let flags0 = _lower1;
    *_param_ptr.add(0).cast::<u8>() = ((flags0.bits() >> 0) as i32) as u8;
  }
  let _param_ptr = unsafe { _ptr.add(8) };
  unsafe { let vec0 = (_lower2.into_bytes()).into_boxed_slice();
  let ptr0 = vec0.as_ptr().cast::<u8>();
  let len0 = vec0.len();
  ::core::mem::forget(vec0);
  *_param_ptr.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len0;
  *_param_ptr.add(0).cast::<*mut u8>() = ptr0.cast_mut();
}
let _param_ptr = unsafe { _ptr.add((8+2*::core::mem::size_of::<*const u8>())) };
unsafe { let flags0 = _lower3;
*_param_ptr.add(0).cast::<u8>() = ((flags0.bits() >> 0) as i32) as u8;
}
let _param_ptr = unsafe { _ptr.add((9+2*::core::mem::size_of::<*const u8>())) };
unsafe { let flags0 = _lower4;
*_param_ptr.add(0).cast::<u8>() = ((flags0.bits() >> 0) as i32) as u8;
}
ParamsLower(_ptr,)
}
unsafe fn results_lift(&mut self, _ptr: *mut u8) -> Self::Results {
  unsafe { let l0 = i32::from(*_ptr.add(0).cast::<u8>());

  match l0 {
    0 => {
      let e = {
        let l1 = *_ptr.add(4).cast::<i32>();

        Descriptor::from_handle(l1 as u32)
      };
      Ok(e)
    }
    1 => {
      let e = {
        let l2 = i32::from(*_ptr.add(4).cast::<u8>());

        ErrorCode::_lift(l2 as u8)
      };
      Err(e)
    }
    _ => _rt::invalid_enum_discriminant(),
  } }
}
}
_MySubtask { _unused: core::marker::PhantomData }.call((self, path_flags, path, open_flags, flags,)).await
}
}
}
impl Descriptor {
  #[allow(unused_unsafe, clippy::all)]
  /// Read the contents of a symbolic link.
  ///
  /// If the contents contain an absolute or rooted path in the underlying
  /// filesystem, this function fails with `error-code::not-permitted`.
  ///
  /// Note: This is similar to `readlinkat` in POSIX.
  #[allow(async_fn_in_trait)]
  pub async fn readlink_at(&self,path: _rt::String,) -> Result<_rt::String,ErrorCode>{
    unsafe {

      #[derive(Copy, Clone)]
      struct ParamsLower(
      i32, *mut u8, usize, 
      );
      unsafe impl Send for ParamsLower {}
      

      use wit_bindgen::rt::async_support::Subtask as _Subtask;
      struct _MySubtask<'a> { _unused: core::marker::PhantomData<&'a ()> }
      #[allow(unused_parens)]
      unsafe impl<'a> _Subtask for _MySubtask<'a> {
        
        type Params = (&'a Descriptor, _rt::String, );
        type Results = Result<_rt::String,ErrorCode>;
        type ParamsLower = ParamsLower;
        fn abi_layout(&mut self) -> ::core::alloc::Layout {
          unsafe {
            ::core::alloc::Layout::from_size_align_unchecked((3*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>())
          }
        }
        
        fn results_offset(&mut self) -> usize { 0 }

        unsafe fn call_import(&mut self, _params: Self::ParamsLower, _results: *mut u8) -> u32 {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:filesystem/types@0.3.0-rc-2026-01-06")]
          unsafe extern "C" {
            #[link_name = "[async-lower][method]descriptor.readlink-at"]
            fn call(_: i32, _: *mut u8, _: usize, _: *mut u8, ) -> i32;
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn call(_: i32, _: *mut u8, _: usize, _: *mut u8, ) -> i32 { unreachable!() }
          
          unsafe { call(_params.0,_params.1,_params.2,_results) as u32 }
        }
        
        unsafe fn params_dealloc_lists(&mut self, _params: Self::ParamsLower) {
          unsafe { _rt::cabi_dealloc(_params.1, _params.2, 1);
        }
      }
      unsafe fn params_dealloc_lists_and_own(&mut self, _params: Self::ParamsLower) {
        unsafe { _rt::cabi_dealloc(_params.1, _params.2, 1);
      }
    }
    unsafe fn params_lower(&mut self, (_lower0, _lower1,): Self::Params, _ptr: *mut u8) -> Self::ParamsLower {
      unsafe { let vec0 = (_lower1.into_bytes()).into_boxed_slice();
      let ptr0 = vec0.as_ptr().cast::<u8>();
      let len0 = vec0.len();
      ::core::mem::forget(vec0);
      ParamsLower((_lower0).handle() as i32, ptr0.cast_mut(), len0,) }
    }
    unsafe fn results_lift(&mut self, _ptr: *mut u8) -> Self::Results {
      unsafe { let l0 = i32::from(*_ptr.add(0).cast::<u8>());

      match l0 {
        0 => {
          let e = {
            let l1 = *_ptr.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
            let l2 = *_ptr.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>();
            let len3 = l2;
            let bytes3 = _rt::Vec::from_raw_parts(l1.cast(), len3, len3);

            _rt::string_lift(bytes3)
          };
          Ok(e)
        }
        1 => {
          let e = {
            let l4 = i32::from(*_ptr.add(::core::mem::size_of::<*const u8>()).cast::<u8>());

            ErrorCode::_lift(l4 as u8)
          };
          Err(e)
        }
        _ => _rt::invalid_enum_discriminant(),
      } }
    }
  }
  _MySubtask { _unused: core::marker::PhantomData }.call((self, path,)).await
}
}
}
impl Descriptor {
  #[allow(unused_unsafe, clippy::all)]
  /// Remove a directory.
  ///
  /// Return `error-code::not-empty` if the directory is not empty.
  ///
  /// Note: This is similar to `unlinkat(fd, path, AT_REMOVEDIR)` in POSIX.
  #[allow(async_fn_in_trait)]
  pub async fn remove_directory_at(&self,path: _rt::String,) -> Result<(),ErrorCode>{
    unsafe {

      #[derive(Copy, Clone)]
      struct ParamsLower(
      i32, *mut u8, usize, 
      );
      unsafe impl Send for ParamsLower {}
      

      use wit_bindgen::rt::async_support::Subtask as _Subtask;
      struct _MySubtask<'a> { _unused: core::marker::PhantomData<&'a ()> }
      #[allow(unused_parens)]
      unsafe impl<'a> _Subtask for _MySubtask<'a> {
        
        type Params = (&'a Descriptor, _rt::String, );
        type Results = Result<(),ErrorCode>;
        type ParamsLower = ParamsLower;
        fn abi_layout(&mut self) -> ::core::alloc::Layout {
          unsafe {
            ::core::alloc::Layout::from_size_align_unchecked(2, 1)
          }
        }
        
        fn results_offset(&mut self) -> usize { 0 }

        unsafe fn call_import(&mut self, _params: Self::ParamsLower, _results: *mut u8) -> u32 {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:filesystem/types@0.3.0-rc-2026-01-06")]
          unsafe extern "C" {
            #[link_name = "[async-lower][method]descriptor.remove-directory-at"]
            fn call(_: i32, _: *mut u8, _: usize, _: *mut u8, ) -> i32;
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn call(_: i32, _: *mut u8, _: usize, _: *mut u8, ) -> i32 { unreachable!() }
          
          unsafe { call(_params.0,_params.1,_params.2,_results) as u32 }
        }
        
        unsafe fn params_dealloc_lists(&mut self, _params: Self::ParamsLower) {
          unsafe { _rt::cabi_dealloc(_params.1, _params.2, 1);
        }
      }
      unsafe fn params_dealloc_lists_and_own(&mut self, _params: Self::ParamsLower) {
        unsafe { _rt::cabi_dealloc(_params.1, _params.2, 1);
      }
    }
    unsafe fn params_lower(&mut self, (_lower0, _lower1,): Self::Params, _ptr: *mut u8) -> Self::ParamsLower {
      unsafe { let vec0 = (_lower1.into_bytes()).into_boxed_slice();
      let ptr0 = vec0.as_ptr().cast::<u8>();
      let len0 = vec0.len();
      ::core::mem::forget(vec0);
      ParamsLower((_lower0).handle() as i32, ptr0.cast_mut(), len0,) }
    }
    unsafe fn results_lift(&mut self, _ptr: *mut u8) -> Self::Results {
      unsafe { let l0 = i32::from(*_ptr.add(0).cast::<u8>());

      match l0 {
        0 => {
          let e = ();
          Ok(e)
        }
        1 => {
          let e = {
            let l1 = i32::from(*_ptr.add(1).cast::<u8>());

            ErrorCode::_lift(l1 as u8)
          };
          Err(e)
        }
        _ => _rt::invalid_enum_discriminant(),
      } }
    }
  }
  _MySubtask { _unused: core::marker::PhantomData }.call((self, path,)).await
}
}
}
impl Descriptor {
  #[allow(unused_unsafe, clippy::all)]
  /// Rename a filesystem object.
  ///
  /// Note: This is similar to `renameat` in POSIX.
  #[allow(async_fn_in_trait)]
  pub async fn rename_at(&self,old_path: _rt::String,new_descriptor: &Descriptor,new_path: _rt::String,) -> Result<(),ErrorCode>{
    unsafe {

      #[derive(Copy, Clone)]
      struct ParamsLower(
      *mut u8, 
      );
      unsafe impl Send for ParamsLower {}
      

      use wit_bindgen::rt::async_support::Subtask as _Subtask;
      struct _MySubtask<'a> { _unused: core::marker::PhantomData<&'a ()> }
      #[allow(unused_parens)]
      unsafe impl<'a> _Subtask for _MySubtask<'a> {
        
        type Params = (&'a Descriptor, _rt::String, &'a Descriptor, _rt::String, );
        type Results = Result<(),ErrorCode>;
        type ParamsLower = ParamsLower;
        fn abi_layout(&mut self) -> ::core::alloc::Layout {
          unsafe {
            ::core::alloc::Layout::from_size_align_unchecked((7*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>())
          }
        }
        
        fn results_offset(&mut self) -> usize { (6*::core::mem::size_of::<*const u8>()) }

        unsafe fn call_import(&mut self, _params: Self::ParamsLower, _results: *mut u8) -> u32 {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:filesystem/types@0.3.0-rc-2026-01-06")]
          unsafe extern "C" {
            #[link_name = "[async-lower][method]descriptor.rename-at"]
            fn call(_: *mut u8, _: *mut u8, ) -> i32;
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn call(_: *mut u8, _: *mut u8, ) -> i32 { unreachable!() }
          
          unsafe { call(_params.0,_results) as u32 }
        }
        
        unsafe fn params_dealloc_lists(&mut self, _params: Self::ParamsLower) {
          unsafe { let l0 = *_params.0.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
          let l1 = *_params.0.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>();
          _rt::cabi_dealloc(l0, l1, 1);
          let l2 = *_params.0.add(4*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
          let l3 = *_params.0.add(5*::core::mem::size_of::<*const u8>()).cast::<usize>();
          _rt::cabi_dealloc(l2, l3, 1);
        }
      }
      unsafe fn params_dealloc_lists_and_own(&mut self, _params: Self::ParamsLower) {
        unsafe { let l0 = *_params.0.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
        let l1 = *_params.0.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>();
        _rt::cabi_dealloc(l0, l1, 1);
        let l2 = *_params.0.add(4*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
        let l3 = *_params.0.add(5*::core::mem::size_of::<*const u8>()).cast::<usize>();
        _rt::cabi_dealloc(l2, l3, 1);
      }
    }
    unsafe fn params_lower(&mut self, (_lower0, _lower1, _lower2, _lower3,): Self::Params, _ptr: *mut u8) -> Self::ParamsLower {
      let _param_ptr = unsafe { _ptr.add(0) };
      unsafe { *_param_ptr.add(0).cast::<i32>() = (_lower0).handle() as i32;
    }
    let _param_ptr = unsafe { _ptr.add(::core::mem::size_of::<*const u8>()) };
    unsafe { let vec0 = (_lower1.into_bytes()).into_boxed_slice();
    let ptr0 = vec0.as_ptr().cast::<u8>();
    let len0 = vec0.len();
    ::core::mem::forget(vec0);
    *_param_ptr.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len0;
    *_param_ptr.add(0).cast::<*mut u8>() = ptr0.cast_mut();
  }
  let _param_ptr = unsafe { _ptr.add((3*::core::mem::size_of::<*const u8>())) };
  unsafe { *_param_ptr.add(0).cast::<i32>() = (_lower2).handle() as i32;
}
let _param_ptr = unsafe { _ptr.add((4*::core::mem::size_of::<*const u8>())) };
unsafe { let vec0 = (_lower3.into_bytes()).into_boxed_slice();
let ptr0 = vec0.as_ptr().cast::<u8>();
let len0 = vec0.len();
::core::mem::forget(vec0);
*_param_ptr.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len0;
*_param_ptr.add(0).cast::<*mut u8>() = ptr0.cast_mut();
}
ParamsLower(_ptr,)
}
unsafe fn results_lift(&mut self, _ptr: *mut u8) -> Self::Results {
  unsafe { let l0 = i32::from(*_ptr.add(0).cast::<u8>());

  match l0 {
    0 => {
      let e = ();
      Ok(e)
    }
    1 => {
      let e = {
        let l1 = i32::from(*_ptr.add(1).cast::<u8>());

        ErrorCode::_lift(l1 as u8)
      };
      Err(e)
    }
    _ => _rt::invalid_enum_discriminant(),
  } }
}
}
_MySubtask { _unused: core::marker::PhantomData }.call((self, old_path, new_descriptor, new_path,)).await
}
}
}
impl Descriptor {
  #[allow(unused_unsafe, clippy::all)]
  /// Create a symbolic link (also known as a "symlink").
  ///
  /// If `old-path` starts with `/`, the function fails with
  /// `error-code::not-permitted`.
  ///
  /// Note: This is similar to `symlinkat` in POSIX.
  #[allow(async_fn_in_trait)]
  pub async fn symlink_at(&self,old_path: _rt::String,new_path: _rt::String,) -> Result<(),ErrorCode>{
    unsafe {

      #[derive(Copy, Clone)]
      struct ParamsLower(
      *mut u8, 
      );
      unsafe impl Send for ParamsLower {}
      

      use wit_bindgen::rt::async_support::Subtask as _Subtask;
      struct _MySubtask<'a> { _unused: core::marker::PhantomData<&'a ()> }
      #[allow(unused_parens)]
      unsafe impl<'a> _Subtask for _MySubtask<'a> {
        
        type Params = (&'a Descriptor, _rt::String, _rt::String, );
        type Results = Result<(),ErrorCode>;
        type ParamsLower = ParamsLower;
        fn abi_layout(&mut self) -> ::core::alloc::Layout {
          unsafe {
            ::core::alloc::Layout::from_size_align_unchecked((6*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>())
          }
        }
        
        fn results_offset(&mut self) -> usize { (5*::core::mem::size_of::<*const u8>()) }

        unsafe fn call_import(&mut self, _params: Self::ParamsLower, _results: *mut u8) -> u32 {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:filesystem/types@0.3.0-rc-2026-01-06")]
          unsafe extern "C" {
            #[link_name = "[async-lower][method]descriptor.symlink-at"]
            fn call(_: *mut u8, _: *mut u8, ) -> i32;
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn call(_: *mut u8, _: *mut u8, ) -> i32 { unreachable!() }
          
          unsafe { call(_params.0,_results) as u32 }
        }
        
        unsafe fn params_dealloc_lists(&mut self, _params: Self::ParamsLower) {
          unsafe { let l0 = *_params.0.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
          let l1 = *_params.0.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>();
          _rt::cabi_dealloc(l0, l1, 1);
          let l2 = *_params.0.add(3*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
          let l3 = *_params.0.add(4*::core::mem::size_of::<*const u8>()).cast::<usize>();
          _rt::cabi_dealloc(l2, l3, 1);
        }
      }
      unsafe fn params_dealloc_lists_and_own(&mut self, _params: Self::ParamsLower) {
        unsafe { let l0 = *_params.0.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
        let l1 = *_params.0.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>();
        _rt::cabi_dealloc(l0, l1, 1);
        let l2 = *_params.0.add(3*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
        let l3 = *_params.0.add(4*::core::mem::size_of::<*const u8>()).cast::<usize>();
        _rt::cabi_dealloc(l2, l3, 1);
      }
    }
    unsafe fn params_lower(&mut self, (_lower0, _lower1, _lower2,): Self::Params, _ptr: *mut u8) -> Self::ParamsLower {
      let _param_ptr = unsafe { _ptr.add(0) };
      unsafe { *_param_ptr.add(0).cast::<i32>() = (_lower0).handle() as i32;
    }
    let _param_ptr = unsafe { _ptr.add(::core::mem::size_of::<*const u8>()) };
    unsafe { let vec0 = (_lower1.into_bytes()).into_boxed_slice();
    let ptr0 = vec0.as_ptr().cast::<u8>();
    let len0 = vec0.len();
    ::core::mem::forget(vec0);
    *_param_ptr.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len0;
    *_param_ptr.add(0).cast::<*mut u8>() = ptr0.cast_mut();
  }
  let _param_ptr = unsafe { _ptr.add((3*::core::mem::size_of::<*const u8>())) };
  unsafe { let vec0 = (_lower2.into_bytes()).into_boxed_slice();
  let ptr0 = vec0.as_ptr().cast::<u8>();
  let len0 = vec0.len();
  ::core::mem::forget(vec0);
  *_param_ptr.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len0;
  *_param_ptr.add(0).cast::<*mut u8>() = ptr0.cast_mut();
}
ParamsLower(_ptr,)
}
unsafe fn results_lift(&mut self, _ptr: *mut u8) -> Self::Results {
  unsafe { let l0 = i32::from(*_ptr.add(0).cast::<u8>());

  match l0 {
    0 => {
      let e = ();
      Ok(e)
    }
    1 => {
      let e = {
        let l1 = i32::from(*_ptr.add(1).cast::<u8>());

        ErrorCode::_lift(l1 as u8)
      };
      Err(e)
    }
    _ => _rt::invalid_enum_discriminant(),
  } }
}
}
_MySubtask { _unused: core::marker::PhantomData }.call((self, old_path, new_path,)).await
}
}
}
impl Descriptor {
  #[allow(unused_unsafe, clippy::all)]
  /// Unlink a filesystem object that is not a directory.
  ///
  /// Return `error-code::is-directory` if the path refers to a directory.
  /// Note: This is similar to `unlinkat(fd, path, 0)` in POSIX.
  #[allow(async_fn_in_trait)]
  pub async fn unlink_file_at(&self,path: _rt::String,) -> Result<(),ErrorCode>{
    unsafe {

      #[derive(Copy, Clone)]
      struct ParamsLower(
      i32, *mut u8, usize, 
      );
      unsafe impl Send for ParamsLower {}
      

      use wit_bindgen::rt::async_support::Subtask as _Subtask;
      struct _MySubtask<'a> { _unused: core::marker::PhantomData<&'a ()> }
      #[allow(unused_parens)]
      unsafe impl<'a> _Subtask for _MySubtask<'a> {
        
        type Params = (&'a Descriptor, _rt::String, );
        type Results = Result<(),ErrorCode>;
        type ParamsLower = ParamsLower;
        fn abi_layout(&mut self) -> ::core::alloc::Layout {
          unsafe {
            ::core::alloc::Layout::from_size_align_unchecked(2, 1)
          }
        }
        
        fn results_offset(&mut self) -> usize { 0 }

        unsafe fn call_import(&mut self, _params: Self::ParamsLower, _results: *mut u8) -> u32 {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:filesystem/types@0.3.0-rc-2026-01-06")]
          unsafe extern "C" {
            #[link_name = "[async-lower][method]descriptor.unlink-file-at"]
            fn call(_: i32, _: *mut u8, _: usize, _: *mut u8, ) -> i32;
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn call(_: i32, _: *mut u8, _: usize, _: *mut u8, ) -> i32 { unreachable!() }
          
          unsafe { call(_params.0,_params.1,_params.2,_results) as u32 }
        }
        
        unsafe fn params_dealloc_lists(&mut self, _params: Self::ParamsLower) {
          unsafe { _rt::cabi_dealloc(_params.1, _params.2, 1);
        }
      }
      unsafe fn params_dealloc_lists_and_own(&mut self, _params: Self::ParamsLower) {
        unsafe { _rt::cabi_dealloc(_params.1, _params.2, 1);
      }
    }
    unsafe fn params_lower(&mut self, (_lower0, _lower1,): Self::Params, _ptr: *mut u8) -> Self::ParamsLower {
      unsafe { let vec0 = (_lower1.into_bytes()).into_boxed_slice();
      let ptr0 = vec0.as_ptr().cast::<u8>();
      let len0 = vec0.len();
      ::core::mem::forget(vec0);
      ParamsLower((_lower0).handle() as i32, ptr0.cast_mut(), len0,) }
    }
    unsafe fn results_lift(&mut self, _ptr: *mut u8) -> Self::Results {
      unsafe { let l0 = i32::from(*_ptr.add(0).cast::<u8>());

      match l0 {
        0 => {
          let e = ();
          Ok(e)
        }
        1 => {
          let e = {
            let l1 = i32::from(*_ptr.add(1).cast::<u8>());

            ErrorCode::_lift(l1 as u8)
          };
          Err(e)
        }
        _ => _rt::invalid_enum_discriminant(),
      } }
    }
  }
  _MySubtask { _unused: core::marker::PhantomData }.call((self, path,)).await
}
}
}
impl Descriptor {
  #[allow(unused_unsafe, clippy::all)]
  /// Test whether two descriptors refer to the same filesystem object.
  ///
  /// In POSIX, this corresponds to testing whether the two descriptors have the
  /// same device (`st_dev`) and inode (`st_ino` or `d_ino`) numbers.
  /// wasi-filesystem does not expose device and inode numbers, so this function
  /// may be used instead.
  #[allow(async_fn_in_trait)]
  pub async fn is_same_object(&self,other: &Descriptor,) -> bool{
    unsafe {

      #[derive(Copy, Clone)]
      struct ParamsLower(
      i32, i32, 
      );
      unsafe impl Send for ParamsLower {}
      

      use wit_bindgen::rt::async_support::Subtask as _Subtask;
      struct _MySubtask<'a> { _unused: core::marker::PhantomData<&'a ()> }
      #[allow(unused_parens)]
      unsafe impl<'a> _Subtask for _MySubtask<'a> {
        
        type Params = (&'a Descriptor, &'a Descriptor, );
        type Results = bool;
        type ParamsLower = ParamsLower;
        fn abi_layout(&mut self) -> ::core::alloc::Layout {
          unsafe {
            ::core::alloc::Layout::from_size_align_unchecked(1, 1)
          }
        }
        
        fn results_offset(&mut self) -> usize { 0 }

        unsafe fn call_import(&mut self, _params: Self::ParamsLower, _results: *mut u8) -> u32 {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:filesystem/types@0.3.0-rc-2026-01-06")]
          unsafe extern "C" {
            #[link_name = "[async-lower][method]descriptor.is-same-object"]
            fn call(_: i32, _: i32, _: *mut u8, ) -> i32;
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn call(_: i32, _: i32, _: *mut u8, ) -> i32 { unreachable!() }
          
          unsafe { call(_params.0,_params.1,_results) as u32 }
        }
        
        unsafe fn params_dealloc_lists(&mut self, _params: Self::ParamsLower) {
          unsafe {  }
        }
        unsafe fn params_dealloc_lists_and_own(&mut self, _params: Self::ParamsLower) {
          unsafe {  }
        }
        unsafe fn params_lower(&mut self, (_lower0, _lower1,): Self::Params, _ptr: *mut u8) -> Self::ParamsLower {
          unsafe {  ParamsLower((_lower0).handle() as i32, (_lower1).handle() as i32,) }
        }
        unsafe fn results_lift(&mut self, _ptr: *mut u8) -> Self::Results {
          unsafe { let l0 = i32::from(*_ptr.add(0).cast::<u8>());

          _rt::bool_lift(l0 as u8) }
        }
      }
      _MySubtask { _unused: core::marker::PhantomData }.call((self, other,)).await
    }
  }
}
impl Descriptor {
  #[allow(unused_unsafe, clippy::all)]
  /// Return a hash of the metadata associated with a filesystem object referred
  /// to by a descriptor.
  ///
  /// This returns a hash of the last-modification timestamp and file size, and
  /// may also include the inode number, device number, birth timestamp, and
  /// other metadata fields that may change when the file is modified or
  /// replaced. It may also include a secret value chosen by the
  /// implementation and not otherwise exposed.
  ///
  /// Implementations are encouraged to provide the following properties:
  ///
  ///  - If the file is not modified or replaced, the computed hash value should
  ///    usually not change.
  ///  - If the object is modified or replaced, the computed hash value should
  ///    usually change.
  ///  - The inputs to the hash should not be easily computable from the
  ///    computed hash.
  ///
  /// However, none of these is required.
  #[allow(async_fn_in_trait)]
  pub async fn metadata_hash(&self,) -> Result<MetadataHashValue,ErrorCode>{
    unsafe {

      #[derive(Copy, Clone)]
      struct ParamsLower(
      i32, 
      );
      unsafe impl Send for ParamsLower {}
      

      use wit_bindgen::rt::async_support::Subtask as _Subtask;
      struct _MySubtask<'a> { _unused: core::marker::PhantomData<&'a ()> }
      #[allow(unused_parens)]
      unsafe impl<'a> _Subtask for _MySubtask<'a> {
        
        type Params = (&'a Descriptor, );
        type Results = Result<MetadataHashValue,ErrorCode>;
        type ParamsLower = ParamsLower;
        fn abi_layout(&mut self) -> ::core::alloc::Layout {
          unsafe {
            ::core::alloc::Layout::from_size_align_unchecked(24, 8)
          }
        }
        
        fn results_offset(&mut self) -> usize { 0 }

        unsafe fn call_import(&mut self, _params: Self::ParamsLower, _results: *mut u8) -> u32 {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:filesystem/types@0.3.0-rc-2026-01-06")]
          unsafe extern "C" {
            #[link_name = "[async-lower][method]descriptor.metadata-hash"]
            fn call(_: i32, _: *mut u8, ) -> i32;
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn call(_: i32, _: *mut u8, ) -> i32 { unreachable!() }
          
          unsafe { call(_params.0,_results) as u32 }
        }
        
        unsafe fn params_dealloc_lists(&mut self, _params: Self::ParamsLower) {
          unsafe {  }
        }
        unsafe fn params_dealloc_lists_and_own(&mut self, _params: Self::ParamsLower) {
          unsafe {  }
        }
        unsafe fn params_lower(&mut self, (_lower0,): Self::Params, _ptr: *mut u8) -> Self::ParamsLower {
          unsafe {  ParamsLower((_lower0).handle() as i32,) }
        }
        unsafe fn results_lift(&mut self, _ptr: *mut u8) -> Self::Results {
          unsafe { let l0 = i32::from(*_ptr.add(0).cast::<u8>());

          match l0 {
            0 => {
              let e = {
                let l1 = *_ptr.add(8).cast::<i64>();
                let l2 = *_ptr.add(16).cast::<i64>();

                MetadataHashValue{
                  lower: l1 as u64,
                  upper: l2 as u64,
                }
              };
              Ok(e)
            }
            1 => {
              let e = {
                let l3 = i32::from(*_ptr.add(8).cast::<u8>());

                ErrorCode::_lift(l3 as u8)
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          } }
        }
      }
      _MySubtask { _unused: core::marker::PhantomData }.call((self,)).await
    }
  }
}
impl Descriptor {
  #[allow(unused_unsafe, clippy::all)]
  /// Return a hash of the metadata associated with a filesystem object referred
  /// to by a directory descriptor and a relative path.
  ///
  /// This performs the same hash computation as `metadata-hash`.
  #[allow(async_fn_in_trait)]
  pub async fn metadata_hash_at(&self,path_flags: PathFlags,path: _rt::String,) -> Result<MetadataHashValue,ErrorCode>{
    unsafe {

      #[derive(Copy, Clone)]
      struct ParamsLower(
      i32, i32, *mut u8, usize, 
      );
      unsafe impl Send for ParamsLower {}
      

      use wit_bindgen::rt::async_support::Subtask as _Subtask;
      struct _MySubtask<'a> { _unused: core::marker::PhantomData<&'a ()> }
      #[allow(unused_parens)]
      unsafe impl<'a> _Subtask for _MySubtask<'a> {
        
        type Params = (&'a Descriptor, PathFlags, _rt::String, );
        type Results = Result<MetadataHashValue,ErrorCode>;
        type ParamsLower = ParamsLower;
        fn abi_layout(&mut self) -> ::core::alloc::Layout {
          unsafe {
            ::core::alloc::Layout::from_size_align_unchecked(24, 8)
          }
        }
        
        fn results_offset(&mut self) -> usize { 0 }

        unsafe fn call_import(&mut self, _params: Self::ParamsLower, _results: *mut u8) -> u32 {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:filesystem/types@0.3.0-rc-2026-01-06")]
          unsafe extern "C" {
            #[link_name = "[async-lower][method]descriptor.metadata-hash-at"]
            fn call(_: i32, _: i32, _: *mut u8, _: usize, _: *mut u8, ) -> i32;
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn call(_: i32, _: i32, _: *mut u8, _: usize, _: *mut u8, ) -> i32 { unreachable!() }
          
          unsafe { call(_params.0,_params.1,_params.2,_params.3,_results) as u32 }
        }
        
        unsafe fn params_dealloc_lists(&mut self, _params: Self::ParamsLower) {
          unsafe { _rt::cabi_dealloc(_params.2, _params.3, 1);
        }
      }
      unsafe fn params_dealloc_lists_and_own(&mut self, _params: Self::ParamsLower) {
        unsafe { _rt::cabi_dealloc(_params.2, _params.3, 1);
      }
    }
    unsafe fn params_lower(&mut self, (_lower0, _lower1, _lower2,): Self::Params, _ptr: *mut u8) -> Self::ParamsLower {
      unsafe { let flags0 = _lower1;
      let vec1 = (_lower2.into_bytes()).into_boxed_slice();
      let ptr1 = vec1.as_ptr().cast::<u8>();
      let len1 = vec1.len();
      ::core::mem::forget(vec1);
      ParamsLower((_lower0).handle() as i32, (flags0.bits() >> 0) as i32, ptr1.cast_mut(), len1,) }
    }
    unsafe fn results_lift(&mut self, _ptr: *mut u8) -> Self::Results {
      unsafe { let l0 = i32::from(*_ptr.add(0).cast::<u8>());

      match l0 {
        0 => {
          let e = {
            let l1 = *_ptr.add(8).cast::<i64>();
            let l2 = *_ptr.add(16).cast::<i64>();

            MetadataHashValue{
              lower: l1 as u64,
              upper: l2 as u64,
            }
          };
          Ok(e)
        }
        1 => {
          let e = {
            let l3 = i32::from(*_ptr.add(8).cast::<u8>());

            ErrorCode::_lift(l3 as u8)
          };
          Err(e)
        }
        _ => _rt::invalid_enum_discriminant(),
      } }
    }
  }
  _MySubtask { _unused: core::marker::PhantomData }.call((self, path_flags, path,)).await
}
}
}

}


#[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
pub mod preopens {
  #[used]
  #[doc(hidden)]
  static __FORCE_SECTION_REF: fn() =
  super::super::super::__link_custom_section_describing_imports;
  
  use super::super::super::_rt;
  pub type Descriptor = super::super::super::wasi::filesystem::types::Descriptor;
  #[allow(unused_unsafe, clippy::all)]
  /// Return the set of preopened directories, and their paths.
  #[allow(async_fn_in_trait)]
  pub async fn get_directories() -> _rt::Vec::<(Descriptor,_rt::String,)>{
    unsafe {

      #[derive(Copy, Clone)]
      struct ParamsLower(
      
      );
      unsafe impl Send for ParamsLower {}
      

      use wit_bindgen::rt::async_support::Subtask as _Subtask;
      struct _MySubtask<'a> { _unused: core::marker::PhantomData<&'a ()> }
      #[allow(unused_parens)]
      unsafe impl<'a> _Subtask for _MySubtask<'a> {
        
        type Params = ();
        type Results = _rt::Vec::<(Descriptor,_rt::String,)>;
        type ParamsLower = ParamsLower;
        fn abi_layout(&mut self) -> ::core::alloc::Layout {
          unsafe {
            ::core::alloc::Layout::from_size_align_unchecked((2*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>())
          }
        }
        
        fn results_offset(&mut self) -> usize { 0 }

        unsafe fn call_import(&mut self, _params: Self::ParamsLower, _results: *mut u8) -> u32 {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:filesystem/preopens@0.3.0-rc-2026-01-06")]
          unsafe extern "C" {
            #[link_name = "[async-lower]get-directories"]
            fn call(_: *mut u8, ) -> i32;
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn call(_: *mut u8, ) -> i32 { unreachable!() }
          
          unsafe { call(_results) as u32 }
        }
        
        unsafe fn params_dealloc_lists(&mut self, _params: Self::ParamsLower) {
          unsafe {  }
        }
        unsafe fn params_dealloc_lists_and_own(&mut self, _params: Self::ParamsLower) {
          unsafe {  }
        }
        unsafe fn params_lower(&mut self, (): Self::Params, _ptr: *mut u8) -> Self::ParamsLower {
          unsafe {  ParamsLower() }
        }
        unsafe fn results_lift(&mut self, _ptr: *mut u8) -> Self::Results {
          unsafe { let l0 = *_ptr.add(0).cast::<*mut u8>();
          let l1 = *_ptr.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
          let base6 = l0;
          let len6 = l1;
          let mut result6 = _rt::Vec::with_capacity(len6);
          for i in 0..len6 {
            let base = base6.add(i * (3*::core::mem::size_of::<*const u8>()));
            let e6 = {
              let l2 = *base.add(0).cast::<i32>();
              let l3 = *base.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
              let l4 = *base.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>();
              let len5 = l4;
              let bytes5 = _rt::Vec::from_raw_parts(l3.cast(), len5, len5);

              (super::super::super::wasi::filesystem::types::Descriptor::from_handle(l2 as u32), _rt::string_lift(bytes5))
            };
            result6.push(e6);
          }
          _rt::cabi_dealloc(base6, len6 * (3*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>());

          result6 }
        }
      }
      _MySubtask { _unused: core::marker::PhantomData }.call(()).await
    }
  }

}

}
pub mod random {
  /// WASI Random is a random data API.
  ///
  /// It is intended to be portable at least between Unix-family platforms and
  /// Windows.
  #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
  pub mod random {
    #[used]
    #[doc(hidden)]
    static __FORCE_SECTION_REF: fn() =
    super::super::super::__link_custom_section_describing_imports;
    
    use super::super::super::_rt;
    #[allow(unused_unsafe, clippy::all)]
    /// Return `len` cryptographically-secure random or pseudo-random bytes.
    ///
    /// This function must produce data at least as cryptographically secure and
    /// fast as an adequately seeded cryptographically-secure pseudo-random
    /// number generator (CSPRNG). It must not block, from the perspective of
    /// the calling program, under any circumstances, including on the first
    /// request and on requests for numbers of bytes. The returned data must
    /// always be unpredictable.
    ///
    /// This function must always return fresh data. Deterministic environments
    /// must omit this function, rather than implementing it with deterministic
    /// data.
    #[allow(async_fn_in_trait)]
    pub async fn get_random_bytes(len: u64,) -> _rt::Vec::<u8>{
      unsafe {

        #[derive(Copy, Clone)]
        struct ParamsLower(
        i64, 
        );
        unsafe impl Send for ParamsLower {}
        

        use wit_bindgen::rt::async_support::Subtask as _Subtask;
        struct _MySubtask<'a> { _unused: core::marker::PhantomData<&'a ()> }
        #[allow(unused_parens)]
        unsafe impl<'a> _Subtask for _MySubtask<'a> {
          
          type Params = (u64, );
          type Results = _rt::Vec::<u8>;
          type ParamsLower = ParamsLower;
          fn abi_layout(&mut self) -> ::core::alloc::Layout {
            unsafe {
              ::core::alloc::Layout::from_size_align_unchecked((2*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>())
            }
          }
          
          fn results_offset(&mut self) -> usize { 0 }

          unsafe fn call_import(&mut self, _params: Self::ParamsLower, _results: *mut u8) -> u32 {
            
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:random/random@0.3.0-rc-2026-01-06")]
            unsafe extern "C" {
              #[link_name = "[async-lower]get-random-bytes"]
              fn call(_: i64, _: *mut u8, ) -> i32;
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn call(_: i64, _: *mut u8, ) -> i32 { unreachable!() }
            
            unsafe { call(_params.0,_results) as u32 }
          }
          
          unsafe fn params_dealloc_lists(&mut self, _params: Self::ParamsLower) {
            unsafe {  }
          }
          unsafe fn params_dealloc_lists_and_own(&mut self, _params: Self::ParamsLower) {
            unsafe {  }
          }
          unsafe fn params_lower(&mut self, (_lower0,): Self::Params, _ptr: *mut u8) -> Self::ParamsLower {
            unsafe {  ParamsLower(_rt::as_i64(_lower0),) }
          }
          unsafe fn results_lift(&mut self, _ptr: *mut u8) -> Self::Results {
            unsafe { let l0 = *_ptr.add(0).cast::<*mut u8>();
            let l1 = *_ptr.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
            let len2 = l1;

            <_ as From<_rt::Vec<_>>>::from(_rt::Vec::from_raw_parts(l0.cast(), len2, len2)) }
          }
        }
        _MySubtask { _unused: core::marker::PhantomData }.call((len,)).await
      }
    }
    #[allow(unused_unsafe, clippy::all)]
    /// Return a cryptographically-secure random or pseudo-random `u64` value.
    ///
    /// This function returns the same type of data as `get-random-bytes`,
    /// represented as a `u64`.
    #[allow(async_fn_in_trait)]
    pub async fn get_random_u64() -> u64{
      unsafe {

        #[derive(Copy, Clone)]
        struct ParamsLower(
        
        );
        unsafe impl Send for ParamsLower {}
        

        use wit_bindgen::rt::async_support::Subtask as _Subtask;
        struct _MySubtask<'a> { _unused: core::marker::PhantomData<&'a ()> }
        #[allow(unused_parens)]
        unsafe impl<'a> _Subtask for _MySubtask<'a> {
          
          type Params = ();
          type Results = u64;
          type ParamsLower = ParamsLower;
          fn abi_layout(&mut self) -> ::core::alloc::Layout {
            unsafe {
              ::core::alloc::Layout::from_size_align_unchecked(8, 8)
            }
          }
          
          fn results_offset(&mut self) -> usize { 0 }

          unsafe fn call_import(&mut self, _params: Self::ParamsLower, _results: *mut u8) -> u32 {
            
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:random/random@0.3.0-rc-2026-01-06")]
            unsafe extern "C" {
              #[link_name = "[async-lower]get-random-u64"]
              fn call(_: *mut u8, ) -> i32;
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn call(_: *mut u8, ) -> i32 { unreachable!() }
            
            unsafe { call(_results) as u32 }
          }
          
          unsafe fn params_dealloc_lists(&mut self, _params: Self::ParamsLower) {
            unsafe {  }
          }
          unsafe fn params_dealloc_lists_and_own(&mut self, _params: Self::ParamsLower) {
            unsafe {  }
          }
          unsafe fn params_lower(&mut self, (): Self::Params, _ptr: *mut u8) -> Self::ParamsLower {
            unsafe {  ParamsLower() }
          }
          unsafe fn results_lift(&mut self, _ptr: *mut u8) -> Self::Results {
            unsafe { let l0 = *_ptr.add(0).cast::<i64>();

            l0 as u64 }
          }
        }
        _MySubtask { _unused: core::marker::PhantomData }.call(()).await
      }
    }

  }

  /// The insecure interface for insecure pseudo-random numbers.
  ///
  /// It is intended to be portable at least between Unix-family platforms and
  /// Windows.
  #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
  pub mod insecure {
    #[used]
    #[doc(hidden)]
    static __FORCE_SECTION_REF: fn() =
    super::super::super::__link_custom_section_describing_imports;
    
    use super::super::super::_rt;
    #[allow(unused_unsafe, clippy::all)]
    /// Return `len` insecure pseudo-random bytes.
    ///
    /// This function is not cryptographically secure. Do not use it for
    /// anything related to security.
    ///
    /// There are no requirements on the values of the returned bytes, however
    /// implementations are encouraged to return evenly distributed values with
    /// a long period.
    #[allow(async_fn_in_trait)]
    pub async fn get_insecure_random_bytes(len: u64,) -> _rt::Vec::<u8>{
      unsafe {

        #[derive(Copy, Clone)]
        struct ParamsLower(
        i64, 
        );
        unsafe impl Send for ParamsLower {}
        

        use wit_bindgen::rt::async_support::Subtask as _Subtask;
        struct _MySubtask<'a> { _unused: core::marker::PhantomData<&'a ()> }
        #[allow(unused_parens)]
        unsafe impl<'a> _Subtask for _MySubtask<'a> {
          
          type Params = (u64, );
          type Results = _rt::Vec::<u8>;
          type ParamsLower = ParamsLower;
          fn abi_layout(&mut self) -> ::core::alloc::Layout {
            unsafe {
              ::core::alloc::Layout::from_size_align_unchecked((2*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>())
            }
          }
          
          fn results_offset(&mut self) -> usize { 0 }

          unsafe fn call_import(&mut self, _params: Self::ParamsLower, _results: *mut u8) -> u32 {
            
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:random/insecure@0.3.0-rc-2026-01-06")]
            unsafe extern "C" {
              #[link_name = "[async-lower]get-insecure-random-bytes"]
              fn call(_: i64, _: *mut u8, ) -> i32;
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn call(_: i64, _: *mut u8, ) -> i32 { unreachable!() }
            
            unsafe { call(_params.0,_results) as u32 }
          }
          
          unsafe fn params_dealloc_lists(&mut self, _params: Self::ParamsLower) {
            unsafe {  }
          }
          unsafe fn params_dealloc_lists_and_own(&mut self, _params: Self::ParamsLower) {
            unsafe {  }
          }
          unsafe fn params_lower(&mut self, (_lower0,): Self::Params, _ptr: *mut u8) -> Self::ParamsLower {
            unsafe {  ParamsLower(_rt::as_i64(_lower0),) }
          }
          unsafe fn results_lift(&mut self, _ptr: *mut u8) -> Self::Results {
            unsafe { let l0 = *_ptr.add(0).cast::<*mut u8>();
            let l1 = *_ptr.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
            let len2 = l1;

            <_ as From<_rt::Vec<_>>>::from(_rt::Vec::from_raw_parts(l0.cast(), len2, len2)) }
          }
        }
        _MySubtask { _unused: core::marker::PhantomData }.call((len,)).await
      }
    }
    #[allow(unused_unsafe, clippy::all)]
    /// Return an insecure pseudo-random `u64` value.
    ///
    /// This function returns the same type of pseudo-random data as
    /// `get-insecure-random-bytes`, represented as a `u64`.
    #[allow(async_fn_in_trait)]
    pub async fn get_insecure_random_u64() -> u64{
      unsafe {

        #[derive(Copy, Clone)]
        struct ParamsLower(
        
        );
        unsafe impl Send for ParamsLower {}
        

        use wit_bindgen::rt::async_support::Subtask as _Subtask;
        struct _MySubtask<'a> { _unused: core::marker::PhantomData<&'a ()> }
        #[allow(unused_parens)]
        unsafe impl<'a> _Subtask for _MySubtask<'a> {
          
          type Params = ();
          type Results = u64;
          type ParamsLower = ParamsLower;
          fn abi_layout(&mut self) -> ::core::alloc::Layout {
            unsafe {
              ::core::alloc::Layout::from_size_align_unchecked(8, 8)
            }
          }
          
          fn results_offset(&mut self) -> usize { 0 }

          unsafe fn call_import(&mut self, _params: Self::ParamsLower, _results: *mut u8) -> u32 {
            
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:random/insecure@0.3.0-rc-2026-01-06")]
            unsafe extern "C" {
              #[link_name = "[async-lower]get-insecure-random-u64"]
              fn call(_: *mut u8, ) -> i32;
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn call(_: *mut u8, ) -> i32 { unreachable!() }
            
            unsafe { call(_results) as u32 }
          }
          
          unsafe fn params_dealloc_lists(&mut self, _params: Self::ParamsLower) {
            unsafe {  }
          }
          unsafe fn params_dealloc_lists_and_own(&mut self, _params: Self::ParamsLower) {
            unsafe {  }
          }
          unsafe fn params_lower(&mut self, (): Self::Params, _ptr: *mut u8) -> Self::ParamsLower {
            unsafe {  ParamsLower() }
          }
          unsafe fn results_lift(&mut self, _ptr: *mut u8) -> Self::Results {
            unsafe { let l0 = *_ptr.add(0).cast::<i64>();

            l0 as u64 }
          }
        }
        _MySubtask { _unused: core::marker::PhantomData }.call(()).await
      }
    }

  }

  /// The insecure-seed interface for seeding hash-map DoS resistance.
  ///
  /// It is intended to be portable at least between Unix-family platforms and
  /// Windows.
  #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
  pub mod insecure_seed {
    #[used]
    #[doc(hidden)]
    static __FORCE_SECTION_REF: fn() =
    super::super::super::__link_custom_section_describing_imports;
    
    #[allow(unused_unsafe, clippy::all)]
    /// Return a 128-bit value that may contain a pseudo-random value.
    ///
    /// The returned value is not required to be computed from a CSPRNG, and may
    /// even be entirely deterministic. Host implementations are encouraged to
    /// provide pseudo-random values to any program exposed to
    /// attacker-controlled content, to enable DoS protection built into many
    /// languages' hash-map implementations.
    ///
    /// This function is intended to only be called once, by a source language
    /// to initialize Denial Of Service (DoS) protection in its hash-map
    /// implementation.
    ///
    /// # Expected future evolution
    ///
    /// This will likely be changed to a value import, to prevent it from being
    /// called multiple times and potentially used for purposes other than DoS
    /// protection.
    #[allow(async_fn_in_trait)]
    pub async fn get_insecure_seed() -> (u64,u64,){
      unsafe {

        #[derive(Copy, Clone)]
        struct ParamsLower(
        
        );
        unsafe impl Send for ParamsLower {}
        

        use wit_bindgen::rt::async_support::Subtask as _Subtask;
        struct _MySubtask<'a> { _unused: core::marker::PhantomData<&'a ()> }
        #[allow(unused_parens)]
        unsafe impl<'a> _Subtask for _MySubtask<'a> {
          
          type Params = ();
          type Results = (u64,u64,);
          type ParamsLower = ParamsLower;
          fn abi_layout(&mut self) -> ::core::alloc::Layout {
            unsafe {
              ::core::alloc::Layout::from_size_align_unchecked(16, 8)
            }
          }
          
          fn results_offset(&mut self) -> usize { 0 }

          unsafe fn call_import(&mut self, _params: Self::ParamsLower, _results: *mut u8) -> u32 {
            
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:random/insecure-seed@0.3.0-rc-2026-01-06")]
            unsafe extern "C" {
              #[link_name = "[async-lower]get-insecure-seed"]
              fn call(_: *mut u8, ) -> i32;
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn call(_: *mut u8, ) -> i32 { unreachable!() }
            
            unsafe { call(_results) as u32 }
          }
          
          unsafe fn params_dealloc_lists(&mut self, _params: Self::ParamsLower) {
            unsafe {  }
          }
          unsafe fn params_dealloc_lists_and_own(&mut self, _params: Self::ParamsLower) {
            unsafe {  }
          }
          unsafe fn params_lower(&mut self, (): Self::Params, _ptr: *mut u8) -> Self::ParamsLower {
            unsafe {  ParamsLower() }
          }
          unsafe fn results_lift(&mut self, _ptr: *mut u8) -> Self::Results {
            unsafe { let l0 = *_ptr.add(0).cast::<i64>();
            let l1 = *_ptr.add(8).cast::<i64>();

            (l0 as u64, l1 as u64) }
          }
        }
        _MySubtask { _unused: core::marker::PhantomData }.call(()).await
      }
    }

  }

}
pub mod sockets {

  #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
  pub mod types {
    #[used]
    #[doc(hidden)]
    static __FORCE_SECTION_REF: fn() =
    super::super::super::__link_custom_section_describing_imports;
    
    use super::super::super::_rt;
    pub type Duration = super::super::super::wasi::clocks::types::Duration;
    /// Error codes.
    ///
    /// In theory, every API can return any error code.
    /// In practice, API's typically only return the errors documented per API
    /// combined with a couple of errors that are always possible:
    /// - `unknown`
    /// - `access-denied`
    /// - `not-supported`
    /// - `out-of-memory`
    ///
    /// See each individual API for what the POSIX equivalents are. They sometimes differ per API.
    #[repr(u8)]
    #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd, serde::Deserialize, serde::Serialize)]
    pub enum ErrorCode {
      /// Unknown error
      Unknown,
      /// Access denied.
      ///
      /// POSIX equivalent: EACCES, EPERM
      AccessDenied,
      /// The operation is not supported.
      ///
      /// POSIX equivalent: EOPNOTSUPP
      NotSupported,
      /// One of the arguments is invalid.
      ///
      /// POSIX equivalent: EINVAL
      InvalidArgument,
      /// Not enough memory to complete the operation.
      ///
      /// POSIX equivalent: ENOMEM, ENOBUFS, EAI_MEMORY
      OutOfMemory,
      /// The operation timed out before it could finish completely.
      Timeout,
      /// The operation is not valid in the socket's current state.
      InvalidState,
      /// A bind operation failed because the provided address is not an address that the `network` can bind to.
      AddressNotBindable,
      /// A bind operation failed because the provided address is already in use or because there are no ephemeral ports available.
      AddressInUse,
      /// The remote address is not reachable
      RemoteUnreachable,
      /// The TCP connection was forcefully rejected
      ConnectionRefused,
      /// The TCP connection was reset.
      ConnectionReset,
      /// A TCP connection was aborted.
      ConnectionAborted,
      /// The size of a datagram sent to a UDP socket exceeded the maximum
      /// supported size.
      DatagramTooLarge,
    }
    impl ErrorCode{
      pub fn name(&self) -> &'static str {
        match self {
          ErrorCode::Unknown => "unknown",
          ErrorCode::AccessDenied => "access-denied",
          ErrorCode::NotSupported => "not-supported",
          ErrorCode::InvalidArgument => "invalid-argument",
          ErrorCode::OutOfMemory => "out-of-memory",
          ErrorCode::Timeout => "timeout",
          ErrorCode::InvalidState => "invalid-state",
          ErrorCode::AddressNotBindable => "address-not-bindable",
          ErrorCode::AddressInUse => "address-in-use",
          ErrorCode::RemoteUnreachable => "remote-unreachable",
          ErrorCode::ConnectionRefused => "connection-refused",
          ErrorCode::ConnectionReset => "connection-reset",
          ErrorCode::ConnectionAborted => "connection-aborted",
          ErrorCode::DatagramTooLarge => "datagram-too-large",
        }
      }
      pub fn message(&self) -> &'static str {
        match self {
          ErrorCode::Unknown => "Unknown error",
          ErrorCode::AccessDenied => "Access denied.

          POSIX equivalent: EACCES, EPERM",
          ErrorCode::NotSupported => "The operation is not supported.

          POSIX equivalent: EOPNOTSUPP",
          ErrorCode::InvalidArgument => "One of the arguments is invalid.

          POSIX equivalent: EINVAL",
          ErrorCode::OutOfMemory => "Not enough memory to complete the operation.

          POSIX equivalent: ENOMEM, ENOBUFS, EAI_MEMORY",
          ErrorCode::Timeout => "The operation timed out before it could finish completely.",
          ErrorCode::InvalidState => "The operation is not valid in the socket's current state.",
          ErrorCode::AddressNotBindable => "A bind operation failed because the provided address is not an address that the `network` can bind to.",
          ErrorCode::AddressInUse => "A bind operation failed because the provided address is already in use or because there are no ephemeral ports available.",
          ErrorCode::RemoteUnreachable => "The remote address is not reachable",
          ErrorCode::ConnectionRefused => "The TCP connection was forcefully rejected",
          ErrorCode::ConnectionReset => "The TCP connection was reset.",
          ErrorCode::ConnectionAborted => "A TCP connection was aborted.",
          ErrorCode::DatagramTooLarge => "The size of a datagram sent to a UDP socket exceeded the maximum
          supported size.",
        }
      }
    }
    impl ::core::fmt::Debug for ErrorCode{
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("ErrorCode")
        .field("code", &(*self as i32))
        .field("name", &self.name())
        .field("message", &self.message())
        .finish()
      }
    }
    impl ::core::fmt::Display for ErrorCode{
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "{} (error {})", self.name(), *self as i32)
      }
    }

    impl ::core::error::Error for ErrorCode {}

    impl ErrorCode{
      #[doc(hidden)]
      pub unsafe fn _lift(val: u8) -> ErrorCode{
        if !cfg!(debug_assertions) {
          return unsafe { ::core::mem::transmute(val) };
        }

        match val {
          0 => ErrorCode::Unknown,
          1 => ErrorCode::AccessDenied,
          2 => ErrorCode::NotSupported,
          3 => ErrorCode::InvalidArgument,
          4 => ErrorCode::OutOfMemory,
          5 => ErrorCode::Timeout,
          6 => ErrorCode::InvalidState,
          7 => ErrorCode::AddressNotBindable,
          8 => ErrorCode::AddressInUse,
          9 => ErrorCode::RemoteUnreachable,
          10 => ErrorCode::ConnectionRefused,
          11 => ErrorCode::ConnectionReset,
          12 => ErrorCode::ConnectionAborted,
          13 => ErrorCode::DatagramTooLarge,

          _ => panic!("invalid enum discriminant"),
        }
      }
    }

    #[repr(u8)]
    #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd, serde::Deserialize, serde::Serialize)]
    pub enum IpAddressFamily {
      /// Similar to `AF_INET` in POSIX.
      Ipv4,
      /// Similar to `AF_INET6` in POSIX.
      Ipv6,
    }
    impl ::core::fmt::Debug for IpAddressFamily {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self {
          IpAddressFamily::Ipv4 => {
            f.debug_tuple("IpAddressFamily::Ipv4").finish()
          }
          IpAddressFamily::Ipv6 => {
            f.debug_tuple("IpAddressFamily::Ipv6").finish()
          }
        }
      }
    }

    impl IpAddressFamily{
      #[doc(hidden)]
      pub unsafe fn _lift(val: u8) -> IpAddressFamily{
        if !cfg!(debug_assertions) {
          return unsafe { ::core::mem::transmute(val) };
        }

        match val {
          0 => IpAddressFamily::Ipv4,
          1 => IpAddressFamily::Ipv6,

          _ => panic!("invalid enum discriminant"),
        }
      }
    }

    pub type Ipv4Address = (u8,u8,u8,u8,);
    pub type Ipv6Address = (u16,u16,u16,u16,u16,u16,u16,u16,);
    #[derive(Clone, Copy, PartialEq, serde::Deserialize, serde::Serialize)]
    pub enum IpAddress {
      Ipv4(Ipv4Address),
      Ipv6(Ipv6Address),
    }
    impl ::core::fmt::Debug for IpAddress {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self {
          IpAddress::Ipv4(e) => {
            f.debug_tuple("IpAddress::Ipv4").field(e).finish()
          }
          IpAddress::Ipv6(e) => {
            f.debug_tuple("IpAddress::Ipv6").field(e).finish()
          }
        }
      }
    }
    #[repr(C)]
    #[derive(Clone, Copy, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct Ipv4SocketAddress {
      /// sin_port
      pub port: u16,
      /// sin_addr
      pub address: Ipv4Address,
    }
    impl ::core::fmt::Debug for Ipv4SocketAddress {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("Ipv4SocketAddress").field("port", &self.port).field("address", &self.address).finish()
      }
    }
    #[repr(C)]
    #[derive(Clone, Copy, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct Ipv6SocketAddress {
      /// sin6_port
      pub port: u16,
      /// sin6_flowinfo
      pub flow_info: u32,
      /// sin6_addr
      pub address: Ipv6Address,
      /// sin6_scope_id
      pub scope_id: u32,
    }
    impl ::core::fmt::Debug for Ipv6SocketAddress {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("Ipv6SocketAddress").field("port", &self.port).field("flow-info", &self.flow_info).field("address", &self.address).field("scope-id", &self.scope_id).finish()
      }
    }
    #[derive(Clone, Copy, PartialEq, serde::Deserialize, serde::Serialize)]
    pub enum IpSocketAddress {
      Ipv4(Ipv4SocketAddress),
      Ipv6(Ipv6SocketAddress),
    }
    impl ::core::fmt::Debug for IpSocketAddress {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self {
          IpSocketAddress::Ipv4(e) => {
            f.debug_tuple("IpSocketAddress::Ipv4").field(e).finish()
          }
          IpSocketAddress::Ipv6(e) => {
            f.debug_tuple("IpSocketAddress::Ipv6").field(e).finish()
          }
        }
      }
    }
    /// A TCP socket resource.
    ///
    /// The socket can be in one of the following states:
    /// - `unbound`
    /// - `bound` (See note below)
    /// - `listening`
    /// - `connecting`
    /// - `connected`
    /// - `closed`
    /// See <https://github.com/WebAssembly/wasi-sockets/blob/main/TcpSocketOperationalSemantics-0.3.0-draft.md>
    /// for more information.
    ///
    /// Note: Except where explicitly mentioned, whenever this documentation uses
    /// the term "bound" without backticks it actually means: in the `bound` state *or higher*.
    /// (i.e. `bound`, `listening`, `connecting` or `connected`)
    ///
    /// In addition to the general error codes documented on the
    /// `types::error-code` type, TCP socket methods may always return
    /// `error(invalid-state)` when in the `closed` state.

    #[derive(Debug)]
    #[repr(transparent)]
    pub struct TcpSocket{
      handle: _rt::Resource<TcpSocket>,
    }

    impl TcpSocket{
      #[doc(hidden)]
      pub unsafe fn from_handle(handle: u32) -> Self {
        Self {
          handle: unsafe { _rt::Resource::from_handle(handle) },
        }
      }

      #[doc(hidden)]
      pub fn take_handle(&self) -> u32 {
        _rt::Resource::take_handle(&self.handle)
      }

      #[doc(hidden)]
      pub fn handle(&self) -> u32 {
        _rt::Resource::handle(&self.handle)
      }
    }
    

    unsafe impl _rt::WasmResource for TcpSocket{
      #[inline]
      unsafe fn drop(_handle: u32) {
        
        #[cfg(target_arch = "wasm32")]
        #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2026-01-06")]
        unsafe extern "C" {
          #[link_name = "[resource-drop]tcp-socket"]
          fn drop(_: i32, );
        }

        #[cfg(not(target_arch = "wasm32"))]
        unsafe extern "C" fn drop(_: i32, ) { unreachable!() }
        
        unsafe { drop(_handle as i32); }
      }
    }
    
    /// A UDP socket handle.

    #[derive(Debug)]
    #[repr(transparent)]
    pub struct UdpSocket{
      handle: _rt::Resource<UdpSocket>,
    }

    impl UdpSocket{
      #[doc(hidden)]
      pub unsafe fn from_handle(handle: u32) -> Self {
        Self {
          handle: unsafe { _rt::Resource::from_handle(handle) },
        }
      }

      #[doc(hidden)]
      pub fn take_handle(&self) -> u32 {
        _rt::Resource::take_handle(&self.handle)
      }

      #[doc(hidden)]
      pub fn handle(&self) -> u32 {
        _rt::Resource::handle(&self.handle)
      }
    }
    

    unsafe impl _rt::WasmResource for UdpSocket{
      #[inline]
      unsafe fn drop(_handle: u32) {
        
        #[cfg(target_arch = "wasm32")]
        #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2026-01-06")]
        unsafe extern "C" {
          #[link_name = "[resource-drop]udp-socket"]
          fn drop(_: i32, );
        }

        #[cfg(not(target_arch = "wasm32"))]
        unsafe extern "C" fn drop(_: i32, ) { unreachable!() }
        
        unsafe { drop(_handle as i32); }
      }
    }
    
    impl TcpSocket {
      #[allow(unused_unsafe, clippy::all)]
      /// Create a new TCP socket.
      ///
      /// Similar to `socket(AF_INET or AF_INET6, SOCK_STREAM, IPPROTO_TCP)` in POSIX.
      /// On IPv6 sockets, IPV6_V6ONLY is enabled by default and can't be configured otherwise.
      ///
      /// Unlike POSIX, WASI sockets have no notion of a socket-level
      /// `O_NONBLOCK` flag. Instead they fully rely on the Component Model's
      /// async support.
      ///
      /// # References
      /// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/socket.html>
      /// - <https://man7.org/linux/man-pages/man2/socket.2.html>
      /// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-wsasocketw>
      /// - <https://man.freebsd.org/cgi/man.cgi?query=socket&sektion=2>
      #[allow(async_fn_in_trait)]
      pub async fn create(address_family: IpAddressFamily,) -> Result<TcpSocket,ErrorCode>{
        unsafe {

          #[derive(Copy, Clone)]
          struct ParamsLower(
          i32, 
          );
          unsafe impl Send for ParamsLower {}
          

          use wit_bindgen::rt::async_support::Subtask as _Subtask;
          struct _MySubtask<'a> { _unused: core::marker::PhantomData<&'a ()> }
          #[allow(unused_parens)]
          unsafe impl<'a> _Subtask for _MySubtask<'a> {
            
            type Params = (IpAddressFamily, );
            type Results = Result<TcpSocket,ErrorCode>;
            type ParamsLower = ParamsLower;
            fn abi_layout(&mut self) -> ::core::alloc::Layout {
              unsafe {
                ::core::alloc::Layout::from_size_align_unchecked(8, 4)
              }
            }
            
            fn results_offset(&mut self) -> usize { 0 }

            unsafe fn call_import(&mut self, _params: Self::ParamsLower, _results: *mut u8) -> u32 {
              
              #[cfg(target_arch = "wasm32")]
              #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2026-01-06")]
              unsafe extern "C" {
                #[link_name = "[async-lower][static]tcp-socket.create"]
                fn call(_: i32, _: *mut u8, ) -> i32;
              }

              #[cfg(not(target_arch = "wasm32"))]
              unsafe extern "C" fn call(_: i32, _: *mut u8, ) -> i32 { unreachable!() }
              
              unsafe { call(_params.0,_results) as u32 }
            }
            
            unsafe fn params_dealloc_lists(&mut self, _params: Self::ParamsLower) {
              unsafe {  }
            }
            unsafe fn params_dealloc_lists_and_own(&mut self, _params: Self::ParamsLower) {
              unsafe {  }
            }
            unsafe fn params_lower(&mut self, (_lower0,): Self::Params, _ptr: *mut u8) -> Self::ParamsLower {
              unsafe {  ParamsLower(_lower0.clone() as i32,) }
            }
            unsafe fn results_lift(&mut self, _ptr: *mut u8) -> Self::Results {
              unsafe { let l0 = i32::from(*_ptr.add(0).cast::<u8>());

              match l0 {
                0 => {
                  let e = {
                    let l1 = *_ptr.add(4).cast::<i32>();

                    TcpSocket::from_handle(l1 as u32)
                  };
                  Ok(e)
                }
                1 => {
                  let e = {
                    let l2 = i32::from(*_ptr.add(4).cast::<u8>());

                    ErrorCode::_lift(l2 as u8)
                  };
                  Err(e)
                }
                _ => _rt::invalid_enum_discriminant(),
              } }
            }
          }
          _MySubtask { _unused: core::marker::PhantomData }.call((address_family,)).await
        }
      }
    }
    impl TcpSocket {
      #[allow(unused_unsafe, clippy::all)]
      /// Bind the socket to the provided IP address and port.
      ///
      /// If the IP address is zero (`0.0.0.0` in IPv4, `::` in IPv6), it is left to the implementation to decide which
      /// network interface(s) to bind to.
      /// If the TCP/UDP port is zero, the socket will be bound to a random free port.
      ///
      /// Bind can be attempted multiple times on the same socket, even with
      /// different arguments on each iteration. But never concurrently and
      /// only as long as the previous bind failed. Once a bind succeeds, the
      /// binding can't be changed anymore.
      ///
      /// # Typical errors
      /// - `invalid-argument`:          The `local-address` has the wrong address family. (EAFNOSUPPORT, EFAULT on Windows)
      /// - `invalid-argument`:          `local-address` is not a unicast address. (EINVAL)
      /// - `invalid-argument`:          `local-address` is an IPv4-mapped IPv6 address. (EINVAL)
      /// - `invalid-state`:             The socket is already bound. (EINVAL)
      /// - `address-in-use`:            No ephemeral ports available. (EADDRINUSE, ENOBUFS on Windows)
      /// - `address-in-use`:            Address is already in use. (EADDRINUSE)
      /// - `address-not-bindable`:      `local-address` is not an address that can be bound to. (EADDRNOTAVAIL)
      ///
      /// # Implementors note
      /// When binding to a non-zero port, this bind operation shouldn't be affected by the TIME_WAIT
      /// state of a recently closed socket on the same local address. In practice this means that the SO_REUSEADDR
      /// socket option should be set implicitly on all platforms, except on Windows where this is the default behavior
      /// and SO_REUSEADDR performs something different entirely.
      ///
      /// # References
      /// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/bind.html>
      /// - <https://man7.org/linux/man-pages/man2/bind.2.html>
      /// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-bind>
      /// - <https://man.freebsd.org/cgi/man.cgi?query=bind&sektion=2&format=html>
      #[allow(async_fn_in_trait)]
      pub async fn bind(&self,local_address: IpSocketAddress,) -> Result<(),ErrorCode>{
        unsafe {

          #[derive(Copy, Clone)]
          struct ParamsLower(
          *mut u8, 
          );
          unsafe impl Send for ParamsLower {}
          

          use wit_bindgen::rt::async_support::Subtask as _Subtask;
          struct _MySubtask<'a> { _unused: core::marker::PhantomData<&'a ()> }
          #[allow(unused_parens)]
          unsafe impl<'a> _Subtask for _MySubtask<'a> {
            
            type Params = (&'a TcpSocket, IpSocketAddress, );
            type Results = Result<(),ErrorCode>;
            type ParamsLower = ParamsLower;
            fn abi_layout(&mut self) -> ::core::alloc::Layout {
              unsafe {
                ::core::alloc::Layout::from_size_align_unchecked(40, 4)
              }
            }
            
            fn results_offset(&mut self) -> usize { 36 }

            unsafe fn call_import(&mut self, _params: Self::ParamsLower, _results: *mut u8) -> u32 {
              
              #[cfg(target_arch = "wasm32")]
              #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2026-01-06")]
              unsafe extern "C" {
                #[link_name = "[async-lower][method]tcp-socket.bind"]
                fn call(_: *mut u8, _: *mut u8, ) -> i32;
              }

              #[cfg(not(target_arch = "wasm32"))]
              unsafe extern "C" fn call(_: *mut u8, _: *mut u8, ) -> i32 { unreachable!() }
              
              unsafe { call(_params.0,_results) as u32 }
            }
            
            unsafe fn params_dealloc_lists(&mut self, _params: Self::ParamsLower) {
              unsafe {  }
            }
            unsafe fn params_dealloc_lists_and_own(&mut self, _params: Self::ParamsLower) {
              unsafe {  }
            }
            unsafe fn params_lower(&mut self, (_lower0, _lower1,): Self::Params, _ptr: *mut u8) -> Self::ParamsLower {
              let _param_ptr = unsafe { _ptr.add(0) };
              unsafe { *_param_ptr.add(0).cast::<i32>() = (_lower0).handle() as i32;
            }
            let _param_ptr = unsafe { _ptr.add(4) };
            unsafe { match _lower1 {
              IpSocketAddress::Ipv4(e) => {
                *_param_ptr.add(0).cast::<u8>() = (0i32) as u8;
                let Ipv4SocketAddress{ port:port0, address:address0, } = e;
                *_param_ptr.add(4).cast::<u16>() = (_rt::as_i32(port0)) as u16;
                let (t1_0, t1_1, t1_2, t1_3, ) = address0;
                *_param_ptr.add(6).cast::<u8>() = (_rt::as_i32(t1_0)) as u8;
                *_param_ptr.add(7).cast::<u8>() = (_rt::as_i32(t1_1)) as u8;
                *_param_ptr.add(8).cast::<u8>() = (_rt::as_i32(t1_2)) as u8;
                *_param_ptr.add(9).cast::<u8>() = (_rt::as_i32(t1_3)) as u8;
              },
              IpSocketAddress::Ipv6(e) => {
                *_param_ptr.add(0).cast::<u8>() = (1i32) as u8;
                let Ipv6SocketAddress{ port:port2, flow_info:flow_info2, address:address2, scope_id:scope_id2, } = e;
                *_param_ptr.add(4).cast::<u16>() = (_rt::as_i32(port2)) as u16;
                *_param_ptr.add(8).cast::<i32>() = _rt::as_i32(flow_info2);
                let (t3_0, t3_1, t3_2, t3_3, t3_4, t3_5, t3_6, t3_7, ) = address2;
                *_param_ptr.add(12).cast::<u16>() = (_rt::as_i32(t3_0)) as u16;
                *_param_ptr.add(14).cast::<u16>() = (_rt::as_i32(t3_1)) as u16;
                *_param_ptr.add(16).cast::<u16>() = (_rt::as_i32(t3_2)) as u16;
                *_param_ptr.add(18).cast::<u16>() = (_rt::as_i32(t3_3)) as u16;
                *_param_ptr.add(20).cast::<u16>() = (_rt::as_i32(t3_4)) as u16;
                *_param_ptr.add(22).cast::<u16>() = (_rt::as_i32(t3_5)) as u16;
                *_param_ptr.add(24).cast::<u16>() = (_rt::as_i32(t3_6)) as u16;
                *_param_ptr.add(26).cast::<u16>() = (_rt::as_i32(t3_7)) as u16;
                *_param_ptr.add(28).cast::<i32>() = _rt::as_i32(scope_id2);
              },
            }
          }
          ParamsLower(_ptr,)
        }
        unsafe fn results_lift(&mut self, _ptr: *mut u8) -> Self::Results {
          unsafe { let l0 = i32::from(*_ptr.add(0).cast::<u8>());

          match l0 {
            0 => {
              let e = ();
              Ok(e)
            }
            1 => {
              let e = {
                let l1 = i32::from(*_ptr.add(1).cast::<u8>());

                ErrorCode::_lift(l1 as u8)
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          } }
        }
      }
      _MySubtask { _unused: core::marker::PhantomData }.call((self, local_address,)).await
    }
  }
}
impl TcpSocket {
  #[allow(unused_unsafe, clippy::all)]
  /// Connect to a remote endpoint.
  ///
  /// On success, the socket is transitioned into the `connected` state and this function returns a connection resource.
  ///
  /// After a failed connection attempt, the socket will be in the `closed`
  /// state and the only valid action left is to `drop` the socket. A single
  /// socket can not be used to connect more than once.
  ///
  /// # Typical errors
  /// - `invalid-argument`:          The `remote-address` has the wrong address family. (EAFNOSUPPORT)
  /// - `invalid-argument`:          `remote-address` is not a unicast address. (EINVAL, ENETUNREACH on Linux, EAFNOSUPPORT on MacOS)
  /// - `invalid-argument`:          `remote-address` is an IPv4-mapped IPv6 address. (EINVAL, EADDRNOTAVAIL on Illumos)
  /// - `invalid-argument`:          The IP address in `remote-address` is set to INADDR_ANY (`0.0.0.0` / `::`). (EADDRNOTAVAIL on Windows)
  /// - `invalid-argument`:          The port in `remote-address` is set to 0. (EADDRNOTAVAIL on Windows)
  /// - `invalid-state`:             The socket is already in the `connecting` state. (EALREADY)
  /// - `invalid-state`:             The socket is already in the `connected` state. (EISCONN)
  /// - `invalid-state`:             The socket is already in the `listening` state. (EOPNOTSUPP, EINVAL on Windows)
  /// - `timeout`:                   Connection timed out. (ETIMEDOUT)
  /// - `connection-refused`:        The connection was forcefully rejected. (ECONNREFUSED)
  /// - `connection-reset`:          The connection was reset. (ECONNRESET)
  /// - `connection-aborted`:        The connection was aborted. (ECONNABORTED)
  /// - `remote-unreachable`:        The remote address is not reachable. (EHOSTUNREACH, EHOSTDOWN, ENETUNREACH, ENETDOWN, ENONET)
  /// - `address-in-use`:            Tried to perform an implicit bind, but there were no ephemeral ports available. (EADDRINUSE, EADDRNOTAVAIL on Linux, EAGAIN on BSD)
  ///
  /// # References
  /// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/connect.html>
  /// - <https://man7.org/linux/man-pages/man2/connect.2.html>
  /// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-connect>
  /// - <https://man.freebsd.org/cgi/man.cgi?connect>
  #[allow(async_fn_in_trait)]
  pub async fn connect(&self,remote_address: IpSocketAddress,) -> Result<(),ErrorCode>{
    unsafe {

      #[derive(Copy, Clone)]
      struct ParamsLower(
      *mut u8, 
      );
      unsafe impl Send for ParamsLower {}
      

      use wit_bindgen::rt::async_support::Subtask as _Subtask;
      struct _MySubtask<'a> { _unused: core::marker::PhantomData<&'a ()> }
      #[allow(unused_parens)]
      unsafe impl<'a> _Subtask for _MySubtask<'a> {
        
        type Params = (&'a TcpSocket, IpSocketAddress, );
        type Results = Result<(),ErrorCode>;
        type ParamsLower = ParamsLower;
        fn abi_layout(&mut self) -> ::core::alloc::Layout {
          unsafe {
            ::core::alloc::Layout::from_size_align_unchecked(40, 4)
          }
        }
        
        fn results_offset(&mut self) -> usize { 36 }

        unsafe fn call_import(&mut self, _params: Self::ParamsLower, _results: *mut u8) -> u32 {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2026-01-06")]
          unsafe extern "C" {
            #[link_name = "[async-lower][method]tcp-socket.connect"]
            fn call(_: *mut u8, _: *mut u8, ) -> i32;
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn call(_: *mut u8, _: *mut u8, ) -> i32 { unreachable!() }
          
          unsafe { call(_params.0,_results) as u32 }
        }
        
        unsafe fn params_dealloc_lists(&mut self, _params: Self::ParamsLower) {
          unsafe {  }
        }
        unsafe fn params_dealloc_lists_and_own(&mut self, _params: Self::ParamsLower) {
          unsafe {  }
        }
        unsafe fn params_lower(&mut self, (_lower0, _lower1,): Self::Params, _ptr: *mut u8) -> Self::ParamsLower {
          let _param_ptr = unsafe { _ptr.add(0) };
          unsafe { *_param_ptr.add(0).cast::<i32>() = (_lower0).handle() as i32;
        }
        let _param_ptr = unsafe { _ptr.add(4) };
        unsafe { match _lower1 {
          IpSocketAddress::Ipv4(e) => {
            *_param_ptr.add(0).cast::<u8>() = (0i32) as u8;
            let Ipv4SocketAddress{ port:port0, address:address0, } = e;
            *_param_ptr.add(4).cast::<u16>() = (_rt::as_i32(port0)) as u16;
            let (t1_0, t1_1, t1_2, t1_3, ) = address0;
            *_param_ptr.add(6).cast::<u8>() = (_rt::as_i32(t1_0)) as u8;
            *_param_ptr.add(7).cast::<u8>() = (_rt::as_i32(t1_1)) as u8;
            *_param_ptr.add(8).cast::<u8>() = (_rt::as_i32(t1_2)) as u8;
            *_param_ptr.add(9).cast::<u8>() = (_rt::as_i32(t1_3)) as u8;
          },
          IpSocketAddress::Ipv6(e) => {
            *_param_ptr.add(0).cast::<u8>() = (1i32) as u8;
            let Ipv6SocketAddress{ port:port2, flow_info:flow_info2, address:address2, scope_id:scope_id2, } = e;
            *_param_ptr.add(4).cast::<u16>() = (_rt::as_i32(port2)) as u16;
            *_param_ptr.add(8).cast::<i32>() = _rt::as_i32(flow_info2);
            let (t3_0, t3_1, t3_2, t3_3, t3_4, t3_5, t3_6, t3_7, ) = address2;
            *_param_ptr.add(12).cast::<u16>() = (_rt::as_i32(t3_0)) as u16;
            *_param_ptr.add(14).cast::<u16>() = (_rt::as_i32(t3_1)) as u16;
            *_param_ptr.add(16).cast::<u16>() = (_rt::as_i32(t3_2)) as u16;
            *_param_ptr.add(18).cast::<u16>() = (_rt::as_i32(t3_3)) as u16;
            *_param_ptr.add(20).cast::<u16>() = (_rt::as_i32(t3_4)) as u16;
            *_param_ptr.add(22).cast::<u16>() = (_rt::as_i32(t3_5)) as u16;
            *_param_ptr.add(24).cast::<u16>() = (_rt::as_i32(t3_6)) as u16;
            *_param_ptr.add(26).cast::<u16>() = (_rt::as_i32(t3_7)) as u16;
            *_param_ptr.add(28).cast::<i32>() = _rt::as_i32(scope_id2);
          },
        }
      }
      ParamsLower(_ptr,)
    }
    unsafe fn results_lift(&mut self, _ptr: *mut u8) -> Self::Results {
      unsafe { let l0 = i32::from(*_ptr.add(0).cast::<u8>());

      match l0 {
        0 => {
          let e = ();
          Ok(e)
        }
        1 => {
          let e = {
            let l1 = i32::from(*_ptr.add(1).cast::<u8>());

            ErrorCode::_lift(l1 as u8)
          };
          Err(e)
        }
        _ => _rt::invalid_enum_discriminant(),
      } }
    }
  }
  _MySubtask { _unused: core::marker::PhantomData }.call((self, remote_address,)).await
}
}
}
impl TcpSocket {
  #[allow(unused_unsafe, clippy::all)]
  /// Start listening and return a stream of new inbound connections.
  ///
  /// Transitions the socket into the `listening` state. This can be called
  /// at most once per socket.
  ///
  /// If the socket is not already explicitly bound, this function will
  /// implicitly bind the socket to a random free port.
  ///
  /// Normally, the returned sockets are bound, in the `connected` state
  /// and immediately ready for I/O. Though, depending on exact timing and
  /// circumstances, a newly accepted connection may already be `closed`
  /// by the time the server attempts to perform its first I/O on it. This
  /// is true regardless of whether the WASI implementation uses
  /// "synthesized" sockets or not (see Implementors Notes below).
  ///
  /// The following properties are inherited from the listener socket:
  /// - `address-family`
  /// - `keep-alive-enabled`
  /// - `keep-alive-idle-time`
  /// - `keep-alive-interval`
  /// - `keep-alive-count`
  /// - `hop-limit`
  /// - `receive-buffer-size`
  /// - `send-buffer-size`
  ///
  /// # Typical errors
  /// - `invalid-state`:             The socket is already in the `connected` state. (EISCONN, EINVAL on BSD)
  /// - `invalid-state`:             The socket is already in the `listening` state.
  /// - `address-in-use`:            Tried to perform an implicit bind, but there were no ephemeral ports available. (EADDRINUSE)
  ///
  /// # Implementors note
  /// This method returns a single perpetual stream that should only close
  /// on fatal errors (if any). Yet, the POSIX' `accept` function may also
  /// return transient errors (e.g. ECONNABORTED). The exact details differ
  /// per operation system. For example, the Linux manual mentions:
  ///
  /// > Linux accept() passes already-pending network errors on the new
  /// > socket as an error code from accept(). This behavior differs from
  /// > other BSD socket implementations. For reliable operation the
  /// > application should detect the network errors defined for the
  /// > protocol after accept() and treat them like EAGAIN by retrying.
  /// > In the case of TCP/IP, these are ENETDOWN, EPROTO, ENOPROTOOPT,
  /// > EHOSTDOWN, ENONET, EHOSTUNREACH, EOPNOTSUPP, and ENETUNREACH.
  /// Source: https://man7.org/linux/man-pages/man2/accept.2.html
  ///
  /// WASI implementations have two options to handle this:
  /// - Optionally log it and then skip over non-fatal errors returned by
  ///   `accept`. Guest code never gets to see these failures. Or:
  /// - Synthesize a `tcp-socket` resource that exposes the error when
  ///   attempting to send or receive on it. Guest code then sees these
  ///   failures as regular I/O errors.
  ///
  /// In either case, the stream returned by this `listen` method remains
  /// operational.
  ///
  /// # References
  /// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/listen.html>
  /// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/accept.html>
  /// - <https://man7.org/linux/man-pages/man2/listen.2.html>
  /// - <https://man7.org/linux/man-pages/man2/accept.2.html>
  /// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-listen>
  /// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-accept>
  /// - <https://man.freebsd.org/cgi/man.cgi?query=listen&sektion=2>
  /// - <https://man.freebsd.org/cgi/man.cgi?query=accept&sektion=2>
  #[allow(async_fn_in_trait)]
  pub async fn listen(&self,) -> Result<wit_bindgen::rt::async_support::StreamReader<TcpSocket>,ErrorCode>{
    unsafe {

      #[derive(Copy, Clone)]
      struct ParamsLower(
      i32, 
      );
      unsafe impl Send for ParamsLower {}
      

      use wit_bindgen::rt::async_support::Subtask as _Subtask;
      struct _MySubtask<'a> { _unused: core::marker::PhantomData<&'a ()> }
      #[allow(unused_parens)]
      unsafe impl<'a> _Subtask for _MySubtask<'a> {
        
        type Params = (&'a TcpSocket, );
        type Results = Result<wit_bindgen::rt::async_support::StreamReader<TcpSocket>,ErrorCode>;
        type ParamsLower = ParamsLower;
        fn abi_layout(&mut self) -> ::core::alloc::Layout {
          unsafe {
            ::core::alloc::Layout::from_size_align_unchecked(8, 4)
          }
        }
        
        fn results_offset(&mut self) -> usize { 0 }

        unsafe fn call_import(&mut self, _params: Self::ParamsLower, _results: *mut u8) -> u32 {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2026-01-06")]
          unsafe extern "C" {
            #[link_name = "[async-lower][method]tcp-socket.listen"]
            fn call(_: i32, _: *mut u8, ) -> i32;
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn call(_: i32, _: *mut u8, ) -> i32 { unreachable!() }
          
          unsafe { call(_params.0,_results) as u32 }
        }
        
        unsafe fn params_dealloc_lists(&mut self, _params: Self::ParamsLower) {
          unsafe {  }
        }
        unsafe fn params_dealloc_lists_and_own(&mut self, _params: Self::ParamsLower) {
          unsafe {  }
        }
        unsafe fn params_lower(&mut self, (_lower0,): Self::Params, _ptr: *mut u8) -> Self::ParamsLower {
          unsafe {  ParamsLower((_lower0).handle() as i32,) }
        }
        unsafe fn results_lift(&mut self, _ptr: *mut u8) -> Self::Results {
          unsafe { let l0 = i32::from(*_ptr.add(0).cast::<u8>());

          match l0 {
            0 => {
              let e = {
                let l1 = *_ptr.add(4).cast::<i32>();

                wit_bindgen::rt::async_support::StreamReader::new(l1 as u32, &super::super::super::wit_stream::vtable2::VTABLE)
              };
              Ok(e)
            }
            1 => {
              let e = {
                let l2 = i32::from(*_ptr.add(4).cast::<u8>());

                ErrorCode::_lift(l2 as u8)
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          } }
        }
      }
      _MySubtask { _unused: core::marker::PhantomData }.call((self,)).await
    }
  }
}
impl TcpSocket {
  #[allow(unused_unsafe, clippy::all)]
  /// Transmit data to peer.
  ///
  /// The caller should close the stream when it has no more data to send
  /// to the peer. Under normal circumstances this will cause a FIN packet
  /// to be sent out. Closing the stream is equivalent to calling
  /// `shutdown(SHUT_WR)` in POSIX.
  ///
  /// This function may be called at most once and returns once the full
  /// contents of the stream are transmitted or an error is encountered.
  ///
  /// # Typical errors
  /// - `invalid-state`:             The socket is not in the `connected` state. (ENOTCONN)
  /// - `connection-reset`:          The connection was reset. (ECONNRESET)
  /// - `remote-unreachable`:        The remote address is not reachable. (EHOSTUNREACH, EHOSTDOWN, ENETUNREACH, ENETDOWN, ENONET)
  ///
  ///  # References
  /// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/send.html>
  /// - <https://man7.org/linux/man-pages/man2/send.2.html>
  /// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-send>
  /// - <https://man.freebsd.org/cgi/man.cgi?query=send&sektion=2>
  #[allow(async_fn_in_trait)]
  pub async fn send(&self,data: wit_bindgen::rt::async_support::StreamReader<u8>,) -> Result<(),ErrorCode>{
    unsafe {

      #[derive(Copy, Clone)]
      struct ParamsLower(
      i32, i32, 
      );
      unsafe impl Send for ParamsLower {}
      

      use wit_bindgen::rt::async_support::Subtask as _Subtask;
      struct _MySubtask<'a> { _unused: core::marker::PhantomData<&'a ()> }
      #[allow(unused_parens)]
      unsafe impl<'a> _Subtask for _MySubtask<'a> {
        
        type Params = (&'a TcpSocket, wit_bindgen::rt::async_support::StreamReader<u8>, );
        type Results = Result<(),ErrorCode>;
        type ParamsLower = ParamsLower;
        fn abi_layout(&mut self) -> ::core::alloc::Layout {
          unsafe {
            ::core::alloc::Layout::from_size_align_unchecked(2, 1)
          }
        }
        
        fn results_offset(&mut self) -> usize { 0 }

        unsafe fn call_import(&mut self, _params: Self::ParamsLower, _results: *mut u8) -> u32 {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2026-01-06")]
          unsafe extern "C" {
            #[link_name = "[async-lower][method]tcp-socket.send"]
            fn call(_: i32, _: i32, _: *mut u8, ) -> i32;
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn call(_: i32, _: i32, _: *mut u8, ) -> i32 { unreachable!() }
          
          unsafe { call(_params.0,_params.1,_results) as u32 }
        }
        
        unsafe fn params_dealloc_lists(&mut self, _params: Self::ParamsLower) {
          unsafe {  }
        }
        unsafe fn params_dealloc_lists_and_own(&mut self, _params: Self::ParamsLower) {
          unsafe { let _ = wit_bindgen::rt::async_support::StreamReader::new(_params.1 as u32, &super::super::super::wit_stream::vtable0::VTABLE);
        }
      }
      unsafe fn params_lower(&mut self, (_lower0, _lower1,): Self::Params, _ptr: *mut u8) -> Self::ParamsLower {
        unsafe {  ParamsLower((_lower0).handle() as i32, (_lower1).take_handle() as i32,) }
      }
      unsafe fn results_lift(&mut self, _ptr: *mut u8) -> Self::Results {
        unsafe { let l0 = i32::from(*_ptr.add(0).cast::<u8>());

        match l0 {
          0 => {
            let e = ();
            Ok(e)
          }
          1 => {
            let e = {
              let l1 = i32::from(*_ptr.add(1).cast::<u8>());

              ErrorCode::_lift(l1 as u8)
            };
            Err(e)
          }
          _ => _rt::invalid_enum_discriminant(),
        } }
      }
    }
    _MySubtask { _unused: core::marker::PhantomData }.call((self, data,)).await
  }
}
}
impl TcpSocket {
  #[allow(unused_unsafe, clippy::all)]
  /// Read data from peer.
  ///
  /// This function returns a `stream` which provides the data received from the
  /// socket, and a `future` providing additional error information in case the
  /// socket is closed abnormally.
  ///
  /// If the socket is closed normally, `stream.read` on the `stream` will return
  /// `read-status::closed` with no `error-context` and the future resolves to
  /// the value `ok`. If the socket is closed abnormally, `stream.read` on the
  /// `stream` returns `read-status::closed` with an `error-context` and the future
  /// resolves to `err` with an `error-code`.
  ///
  /// `receive` is meant to be called only once per socket. If it is called more
  /// than once, the subsequent calls return a new `stream` that fails as if it
  /// were closed abnormally.
  ///
  /// If the caller is not expecting to receive any data from the peer,
  /// they may drop the stream. Any data still in the receive queue
  /// will be discarded. This is equivalent to calling `shutdown(SHUT_RD)`
  /// in POSIX.
  ///
  /// # Typical errors
  /// - `invalid-state`:             The socket is not in the `connected` state. (ENOTCONN)
  /// - `connection-reset`:          The connection was reset. (ECONNRESET)
  /// - `remote-unreachable`:        The remote address is not reachable. (EHOSTUNREACH, EHOSTDOWN, ENETUNREACH, ENETDOWN, ENONET)
  ///
  /// # References
  /// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/recv.html>
  /// - <https://man7.org/linux/man-pages/man2/recv.2.html>
  /// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-recv>
  /// - <https://man.freebsd.org/cgi/man.cgi?query=recv&sektion=2>
  #[allow(async_fn_in_trait)]
  pub async fn receive(&self,) -> (wit_bindgen::rt::async_support::StreamReader<u8>,wit_bindgen::rt::async_support::FutureReader<Result<(),ErrorCode>>,){
    unsafe {

      #[derive(Copy, Clone)]
      struct ParamsLower(
      i32, 
      );
      unsafe impl Send for ParamsLower {}
      

      use wit_bindgen::rt::async_support::Subtask as _Subtask;
      struct _MySubtask<'a> { _unused: core::marker::PhantomData<&'a ()> }
      #[allow(unused_parens)]
      unsafe impl<'a> _Subtask for _MySubtask<'a> {
        
        type Params = (&'a TcpSocket, );
        type Results = (wit_bindgen::rt::async_support::StreamReader<u8>,wit_bindgen::rt::async_support::FutureReader<Result<(),ErrorCode>>,);
        type ParamsLower = ParamsLower;
        fn abi_layout(&mut self) -> ::core::alloc::Layout {
          unsafe {
            ::core::alloc::Layout::from_size_align_unchecked(8, 4)
          }
        }
        
        fn results_offset(&mut self) -> usize { 0 }

        unsafe fn call_import(&mut self, _params: Self::ParamsLower, _results: *mut u8) -> u32 {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2026-01-06")]
          unsafe extern "C" {
            #[link_name = "[async-lower][method]tcp-socket.receive"]
            fn call(_: i32, _: *mut u8, ) -> i32;
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn call(_: i32, _: *mut u8, ) -> i32 { unreachable!() }
          
          unsafe { call(_params.0,_results) as u32 }
        }
        
        unsafe fn params_dealloc_lists(&mut self, _params: Self::ParamsLower) {
          unsafe {  }
        }
        unsafe fn params_dealloc_lists_and_own(&mut self, _params: Self::ParamsLower) {
          unsafe {  }
        }
        unsafe fn params_lower(&mut self, (_lower0,): Self::Params, _ptr: *mut u8) -> Self::ParamsLower {
          unsafe {  ParamsLower((_lower0).handle() as i32,) }
        }
        unsafe fn results_lift(&mut self, _ptr: *mut u8) -> Self::Results {
          unsafe { let l0 = *_ptr.add(0).cast::<i32>();
          let l1 = *_ptr.add(4).cast::<i32>();

          (wit_bindgen::rt::async_support::StreamReader::new(l0 as u32, &super::super::super::wit_stream::vtable0::VTABLE), wit_bindgen::rt::async_support::FutureReader::new(l1 as u32, &super::super::super::wit_future::vtable2::VTABLE)) }
        }
      }
      _MySubtask { _unused: core::marker::PhantomData }.call((self,)).await
    }
  }
}
impl TcpSocket {
  #[allow(unused_unsafe, clippy::all)]
  /// Get the bound local address.
  ///
  /// POSIX mentions:
  /// > If the socket has not been bound to a local name, the value
  /// > stored in the object pointed to by `address` is unspecified.
  ///
  /// WASI is stricter and requires `get-local-address` to return `invalid-state` when the socket hasn't been bound yet.
  ///
  /// # Typical errors
  /// - `invalid-state`: The socket is not bound to any local address.
  ///
  /// # References
  /// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/getsockname.html>
  /// - <https://man7.org/linux/man-pages/man2/getsockname.2.html>
  /// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-getsockname>
  /// - <https://man.freebsd.org/cgi/man.cgi?getsockname>
  #[allow(async_fn_in_trait)]
  pub async fn get_local_address(&self,) -> Result<IpSocketAddress,ErrorCode>{
    unsafe {

      #[derive(Copy, Clone)]
      struct ParamsLower(
      i32, 
      );
      unsafe impl Send for ParamsLower {}
      

      use wit_bindgen::rt::async_support::Subtask as _Subtask;
      struct _MySubtask<'a> { _unused: core::marker::PhantomData<&'a ()> }
      #[allow(unused_parens)]
      unsafe impl<'a> _Subtask for _MySubtask<'a> {
        
        type Params = (&'a TcpSocket, );
        type Results = Result<IpSocketAddress,ErrorCode>;
        type ParamsLower = ParamsLower;
        fn abi_layout(&mut self) -> ::core::alloc::Layout {
          unsafe {
            ::core::alloc::Layout::from_size_align_unchecked(36, 4)
          }
        }
        
        fn results_offset(&mut self) -> usize { 0 }

        unsafe fn call_import(&mut self, _params: Self::ParamsLower, _results: *mut u8) -> u32 {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2026-01-06")]
          unsafe extern "C" {
            #[link_name = "[async-lower][method]tcp-socket.get-local-address"]
            fn call(_: i32, _: *mut u8, ) -> i32;
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn call(_: i32, _: *mut u8, ) -> i32 { unreachable!() }
          
          unsafe { call(_params.0,_results) as u32 }
        }
        
        unsafe fn params_dealloc_lists(&mut self, _params: Self::ParamsLower) {
          unsafe {  }
        }
        unsafe fn params_dealloc_lists_and_own(&mut self, _params: Self::ParamsLower) {
          unsafe {  }
        }
        unsafe fn params_lower(&mut self, (_lower0,): Self::Params, _ptr: *mut u8) -> Self::ParamsLower {
          unsafe {  ParamsLower((_lower0).handle() as i32,) }
        }
        unsafe fn results_lift(&mut self, _ptr: *mut u8) -> Self::Results {
          unsafe { let l0 = i32::from(*_ptr.add(0).cast::<u8>());

          match l0 {
            0 => {
              let e = {
                let l1 = i32::from(*_ptr.add(4).cast::<u8>());
                let v18 = match l1 {
                  0 => {
                    let e18 = {
                      let l2 = i32::from(*_ptr.add(8).cast::<u16>());
                      let l3 = i32::from(*_ptr.add(10).cast::<u8>());
                      let l4 = i32::from(*_ptr.add(11).cast::<u8>());
                      let l5 = i32::from(*_ptr.add(12).cast::<u8>());
                      let l6 = i32::from(*_ptr.add(13).cast::<u8>());

                      Ipv4SocketAddress{
                        port: l2 as u16,
                        address: (l3 as u8, l4 as u8, l5 as u8, l6 as u8),
                      }
                    };
                    IpSocketAddress::Ipv4(e18)
                  }
                  n => {
                    debug_assert_eq!(n, 1, "invalid enum discriminant");
                    let e18 = {
                      let l7 = i32::from(*_ptr.add(8).cast::<u16>());
                      let l8 = *_ptr.add(12).cast::<i32>();
                      let l9 = i32::from(*_ptr.add(16).cast::<u16>());
                      let l10 = i32::from(*_ptr.add(18).cast::<u16>());
                      let l11 = i32::from(*_ptr.add(20).cast::<u16>());
                      let l12 = i32::from(*_ptr.add(22).cast::<u16>());
                      let l13 = i32::from(*_ptr.add(24).cast::<u16>());
                      let l14 = i32::from(*_ptr.add(26).cast::<u16>());
                      let l15 = i32::from(*_ptr.add(28).cast::<u16>());
                      let l16 = i32::from(*_ptr.add(30).cast::<u16>());
                      let l17 = *_ptr.add(32).cast::<i32>();

                      Ipv6SocketAddress{
                        port: l7 as u16,
                        flow_info: l8 as u32,
                        address: (l9 as u16, l10 as u16, l11 as u16, l12 as u16, l13 as u16, l14 as u16, l15 as u16, l16 as u16),
                        scope_id: l17 as u32,
                      }
                    };
                    IpSocketAddress::Ipv6(e18)
                  }
                };

                v18
              };
              Ok(e)
            }
            1 => {
              let e = {
                let l19 = i32::from(*_ptr.add(4).cast::<u8>());

                ErrorCode::_lift(l19 as u8)
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          } }
        }
      }
      _MySubtask { _unused: core::marker::PhantomData }.call((self,)).await
    }
  }
}
impl TcpSocket {
  #[allow(unused_unsafe, clippy::all)]
  /// Get the remote address.
  ///
  /// # Typical errors
  /// - `invalid-state`: The socket is not connected to a remote address. (ENOTCONN)
  ///
  /// # References
  /// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/getpeername.html>
  /// - <https://man7.org/linux/man-pages/man2/getpeername.2.html>
  /// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-getpeername>
  /// - <https://man.freebsd.org/cgi/man.cgi?query=getpeername&sektion=2&n=1>
  #[allow(async_fn_in_trait)]
  pub async fn get_remote_address(&self,) -> Result<IpSocketAddress,ErrorCode>{
    unsafe {

      #[derive(Copy, Clone)]
      struct ParamsLower(
      i32, 
      );
      unsafe impl Send for ParamsLower {}
      

      use wit_bindgen::rt::async_support::Subtask as _Subtask;
      struct _MySubtask<'a> { _unused: core::marker::PhantomData<&'a ()> }
      #[allow(unused_parens)]
      unsafe impl<'a> _Subtask for _MySubtask<'a> {
        
        type Params = (&'a TcpSocket, );
        type Results = Result<IpSocketAddress,ErrorCode>;
        type ParamsLower = ParamsLower;
        fn abi_layout(&mut self) -> ::core::alloc::Layout {
          unsafe {
            ::core::alloc::Layout::from_size_align_unchecked(36, 4)
          }
        }
        
        fn results_offset(&mut self) -> usize { 0 }

        unsafe fn call_import(&mut self, _params: Self::ParamsLower, _results: *mut u8) -> u32 {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2026-01-06")]
          unsafe extern "C" {
            #[link_name = "[async-lower][method]tcp-socket.get-remote-address"]
            fn call(_: i32, _: *mut u8, ) -> i32;
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn call(_: i32, _: *mut u8, ) -> i32 { unreachable!() }
          
          unsafe { call(_params.0,_results) as u32 }
        }
        
        unsafe fn params_dealloc_lists(&mut self, _params: Self::ParamsLower) {
          unsafe {  }
        }
        unsafe fn params_dealloc_lists_and_own(&mut self, _params: Self::ParamsLower) {
          unsafe {  }
        }
        unsafe fn params_lower(&mut self, (_lower0,): Self::Params, _ptr: *mut u8) -> Self::ParamsLower {
          unsafe {  ParamsLower((_lower0).handle() as i32,) }
        }
        unsafe fn results_lift(&mut self, _ptr: *mut u8) -> Self::Results {
          unsafe { let l0 = i32::from(*_ptr.add(0).cast::<u8>());

          match l0 {
            0 => {
              let e = {
                let l1 = i32::from(*_ptr.add(4).cast::<u8>());
                let v18 = match l1 {
                  0 => {
                    let e18 = {
                      let l2 = i32::from(*_ptr.add(8).cast::<u16>());
                      let l3 = i32::from(*_ptr.add(10).cast::<u8>());
                      let l4 = i32::from(*_ptr.add(11).cast::<u8>());
                      let l5 = i32::from(*_ptr.add(12).cast::<u8>());
                      let l6 = i32::from(*_ptr.add(13).cast::<u8>());

                      Ipv4SocketAddress{
                        port: l2 as u16,
                        address: (l3 as u8, l4 as u8, l5 as u8, l6 as u8),
                      }
                    };
                    IpSocketAddress::Ipv4(e18)
                  }
                  n => {
                    debug_assert_eq!(n, 1, "invalid enum discriminant");
                    let e18 = {
                      let l7 = i32::from(*_ptr.add(8).cast::<u16>());
                      let l8 = *_ptr.add(12).cast::<i32>();
                      let l9 = i32::from(*_ptr.add(16).cast::<u16>());
                      let l10 = i32::from(*_ptr.add(18).cast::<u16>());
                      let l11 = i32::from(*_ptr.add(20).cast::<u16>());
                      let l12 = i32::from(*_ptr.add(22).cast::<u16>());
                      let l13 = i32::from(*_ptr.add(24).cast::<u16>());
                      let l14 = i32::from(*_ptr.add(26).cast::<u16>());
                      let l15 = i32::from(*_ptr.add(28).cast::<u16>());
                      let l16 = i32::from(*_ptr.add(30).cast::<u16>());
                      let l17 = *_ptr.add(32).cast::<i32>();

                      Ipv6SocketAddress{
                        port: l7 as u16,
                        flow_info: l8 as u32,
                        address: (l9 as u16, l10 as u16, l11 as u16, l12 as u16, l13 as u16, l14 as u16, l15 as u16, l16 as u16),
                        scope_id: l17 as u32,
                      }
                    };
                    IpSocketAddress::Ipv6(e18)
                  }
                };

                v18
              };
              Ok(e)
            }
            1 => {
              let e = {
                let l19 = i32::from(*_ptr.add(4).cast::<u8>());

                ErrorCode::_lift(l19 as u8)
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          } }
        }
      }
      _MySubtask { _unused: core::marker::PhantomData }.call((self,)).await
    }
  }
}
impl TcpSocket {
  #[allow(unused_unsafe, clippy::all)]
  /// Whether the socket is in the `listening` state.
  ///
  /// Equivalent to the SO_ACCEPTCONN socket option.
  #[allow(async_fn_in_trait)]
  pub async fn get_is_listening(&self,) -> bool{
    unsafe {

      #[derive(Copy, Clone)]
      struct ParamsLower(
      i32, 
      );
      unsafe impl Send for ParamsLower {}
      

      use wit_bindgen::rt::async_support::Subtask as _Subtask;
      struct _MySubtask<'a> { _unused: core::marker::PhantomData<&'a ()> }
      #[allow(unused_parens)]
      unsafe impl<'a> _Subtask for _MySubtask<'a> {
        
        type Params = (&'a TcpSocket, );
        type Results = bool;
        type ParamsLower = ParamsLower;
        fn abi_layout(&mut self) -> ::core::alloc::Layout {
          unsafe {
            ::core::alloc::Layout::from_size_align_unchecked(1, 1)
          }
        }
        
        fn results_offset(&mut self) -> usize { 0 }

        unsafe fn call_import(&mut self, _params: Self::ParamsLower, _results: *mut u8) -> u32 {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2026-01-06")]
          unsafe extern "C" {
            #[link_name = "[async-lower][method]tcp-socket.get-is-listening"]
            fn call(_: i32, _: *mut u8, ) -> i32;
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn call(_: i32, _: *mut u8, ) -> i32 { unreachable!() }
          
          unsafe { call(_params.0,_results) as u32 }
        }
        
        unsafe fn params_dealloc_lists(&mut self, _params: Self::ParamsLower) {
          unsafe {  }
        }
        unsafe fn params_dealloc_lists_and_own(&mut self, _params: Self::ParamsLower) {
          unsafe {  }
        }
        unsafe fn params_lower(&mut self, (_lower0,): Self::Params, _ptr: *mut u8) -> Self::ParamsLower {
          unsafe {  ParamsLower((_lower0).handle() as i32,) }
        }
        unsafe fn results_lift(&mut self, _ptr: *mut u8) -> Self::Results {
          unsafe { let l0 = i32::from(*_ptr.add(0).cast::<u8>());

          _rt::bool_lift(l0 as u8) }
        }
      }
      _MySubtask { _unused: core::marker::PhantomData }.call((self,)).await
    }
  }
}
impl TcpSocket {
  #[allow(unused_unsafe, clippy::all)]
  /// Whether this is a IPv4 or IPv6 socket.
  ///
  /// This is the value passed to the constructor.
  ///
  /// Equivalent to the SO_DOMAIN socket option.
  #[allow(async_fn_in_trait)]
  pub async fn get_address_family(&self,) -> IpAddressFamily{
    unsafe {

      #[derive(Copy, Clone)]
      struct ParamsLower(
      i32, 
      );
      unsafe impl Send for ParamsLower {}
      

      use wit_bindgen::rt::async_support::Subtask as _Subtask;
      struct _MySubtask<'a> { _unused: core::marker::PhantomData<&'a ()> }
      #[allow(unused_parens)]
      unsafe impl<'a> _Subtask for _MySubtask<'a> {
        
        type Params = (&'a TcpSocket, );
        type Results = IpAddressFamily;
        type ParamsLower = ParamsLower;
        fn abi_layout(&mut self) -> ::core::alloc::Layout {
          unsafe {
            ::core::alloc::Layout::from_size_align_unchecked(1, 1)
          }
        }
        
        fn results_offset(&mut self) -> usize { 0 }

        unsafe fn call_import(&mut self, _params: Self::ParamsLower, _results: *mut u8) -> u32 {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2026-01-06")]
          unsafe extern "C" {
            #[link_name = "[async-lower][method]tcp-socket.get-address-family"]
            fn call(_: i32, _: *mut u8, ) -> i32;
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn call(_: i32, _: *mut u8, ) -> i32 { unreachable!() }
          
          unsafe { call(_params.0,_results) as u32 }
        }
        
        unsafe fn params_dealloc_lists(&mut self, _params: Self::ParamsLower) {
          unsafe {  }
        }
        unsafe fn params_dealloc_lists_and_own(&mut self, _params: Self::ParamsLower) {
          unsafe {  }
        }
        unsafe fn params_lower(&mut self, (_lower0,): Self::Params, _ptr: *mut u8) -> Self::ParamsLower {
          unsafe {  ParamsLower((_lower0).handle() as i32,) }
        }
        unsafe fn results_lift(&mut self, _ptr: *mut u8) -> Self::Results {
          unsafe { let l0 = i32::from(*_ptr.add(0).cast::<u8>());

          IpAddressFamily::_lift(l0 as u8) }
        }
      }
      _MySubtask { _unused: core::marker::PhantomData }.call((self,)).await
    }
  }
}
impl TcpSocket {
  #[allow(unused_unsafe, clippy::all)]
  /// Hints the desired listen queue size. Implementations are free to ignore this.
  ///
  /// If the provided value is 0, an `invalid-argument` error is returned.
  /// Any other value will never cause an error, but it might be silently clamped and/or rounded.
  ///
  /// # Typical errors
  /// - `not-supported`:        (set) The platform does not support changing the backlog size after the initial listen.
  /// - `invalid-argument`:     (set) The provided value was 0.
  /// - `invalid-state`:        (set) The socket is in the `connecting` or `connected` state.
  #[allow(async_fn_in_trait)]
  pub async fn set_listen_backlog_size(&self,value: u64,) -> Result<(),ErrorCode>{
    unsafe {

      #[derive(Copy, Clone)]
      struct ParamsLower(
      i32, i64, 
      );
      unsafe impl Send for ParamsLower {}
      

      use wit_bindgen::rt::async_support::Subtask as _Subtask;
      struct _MySubtask<'a> { _unused: core::marker::PhantomData<&'a ()> }
      #[allow(unused_parens)]
      unsafe impl<'a> _Subtask for _MySubtask<'a> {
        
        type Params = (&'a TcpSocket, u64, );
        type Results = Result<(),ErrorCode>;
        type ParamsLower = ParamsLower;
        fn abi_layout(&mut self) -> ::core::alloc::Layout {
          unsafe {
            ::core::alloc::Layout::from_size_align_unchecked(2, 1)
          }
        }
        
        fn results_offset(&mut self) -> usize { 0 }

        unsafe fn call_import(&mut self, _params: Self::ParamsLower, _results: *mut u8) -> u32 {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2026-01-06")]
          unsafe extern "C" {
            #[link_name = "[async-lower][method]tcp-socket.set-listen-backlog-size"]
            fn call(_: i32, _: i64, _: *mut u8, ) -> i32;
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn call(_: i32, _: i64, _: *mut u8, ) -> i32 { unreachable!() }
          
          unsafe { call(_params.0,_params.1,_results) as u32 }
        }
        
        unsafe fn params_dealloc_lists(&mut self, _params: Self::ParamsLower) {
          unsafe {  }
        }
        unsafe fn params_dealloc_lists_and_own(&mut self, _params: Self::ParamsLower) {
          unsafe {  }
        }
        unsafe fn params_lower(&mut self, (_lower0, _lower1,): Self::Params, _ptr: *mut u8) -> Self::ParamsLower {
          unsafe {  ParamsLower((_lower0).handle() as i32, _rt::as_i64(_lower1),) }
        }
        unsafe fn results_lift(&mut self, _ptr: *mut u8) -> Self::Results {
          unsafe { let l0 = i32::from(*_ptr.add(0).cast::<u8>());

          match l0 {
            0 => {
              let e = ();
              Ok(e)
            }
            1 => {
              let e = {
                let l1 = i32::from(*_ptr.add(1).cast::<u8>());

                ErrorCode::_lift(l1 as u8)
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          } }
        }
      }
      _MySubtask { _unused: core::marker::PhantomData }.call((self, value,)).await
    }
  }
}
impl TcpSocket {
  #[allow(unused_unsafe, clippy::all)]
  /// Enables or disables keepalive.
  ///
  /// The keepalive behavior can be adjusted using:
  /// - `keep-alive-idle-time`
  /// - `keep-alive-interval`
  /// - `keep-alive-count`
  /// These properties can be configured while `keep-alive-enabled` is false, but only come into effect when `keep-alive-enabled` is true.
  ///
  /// Equivalent to the SO_KEEPALIVE socket option.
  #[allow(async_fn_in_trait)]
  pub async fn get_keep_alive_enabled(&self,) -> Result<bool,ErrorCode>{
    unsafe {

      #[derive(Copy, Clone)]
      struct ParamsLower(
      i32, 
      );
      unsafe impl Send for ParamsLower {}
      

      use wit_bindgen::rt::async_support::Subtask as _Subtask;
      struct _MySubtask<'a> { _unused: core::marker::PhantomData<&'a ()> }
      #[allow(unused_parens)]
      unsafe impl<'a> _Subtask for _MySubtask<'a> {
        
        type Params = (&'a TcpSocket, );
        type Results = Result<bool,ErrorCode>;
        type ParamsLower = ParamsLower;
        fn abi_layout(&mut self) -> ::core::alloc::Layout {
          unsafe {
            ::core::alloc::Layout::from_size_align_unchecked(2, 1)
          }
        }
        
        fn results_offset(&mut self) -> usize { 0 }

        unsafe fn call_import(&mut self, _params: Self::ParamsLower, _results: *mut u8) -> u32 {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2026-01-06")]
          unsafe extern "C" {
            #[link_name = "[async-lower][method]tcp-socket.get-keep-alive-enabled"]
            fn call(_: i32, _: *mut u8, ) -> i32;
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn call(_: i32, _: *mut u8, ) -> i32 { unreachable!() }
          
          unsafe { call(_params.0,_results) as u32 }
        }
        
        unsafe fn params_dealloc_lists(&mut self, _params: Self::ParamsLower) {
          unsafe {  }
        }
        unsafe fn params_dealloc_lists_and_own(&mut self, _params: Self::ParamsLower) {
          unsafe {  }
        }
        unsafe fn params_lower(&mut self, (_lower0,): Self::Params, _ptr: *mut u8) -> Self::ParamsLower {
          unsafe {  ParamsLower((_lower0).handle() as i32,) }
        }
        unsafe fn results_lift(&mut self, _ptr: *mut u8) -> Self::Results {
          unsafe { let l0 = i32::from(*_ptr.add(0).cast::<u8>());

          match l0 {
            0 => {
              let e = {
                let l1 = i32::from(*_ptr.add(1).cast::<u8>());

                _rt::bool_lift(l1 as u8)
              };
              Ok(e)
            }
            1 => {
              let e = {
                let l2 = i32::from(*_ptr.add(1).cast::<u8>());

                ErrorCode::_lift(l2 as u8)
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          } }
        }
      }
      _MySubtask { _unused: core::marker::PhantomData }.call((self,)).await
    }
  }
}
impl TcpSocket {
  #[allow(unused_unsafe, clippy::all)]
  #[allow(async_fn_in_trait)]
  pub async fn set_keep_alive_enabled(&self,value: bool,) -> Result<(),ErrorCode>{
    unsafe {

      #[derive(Copy, Clone)]
      struct ParamsLower(
      i32, i32, 
      );
      unsafe impl Send for ParamsLower {}
      

      use wit_bindgen::rt::async_support::Subtask as _Subtask;
      struct _MySubtask<'a> { _unused: core::marker::PhantomData<&'a ()> }
      #[allow(unused_parens)]
      unsafe impl<'a> _Subtask for _MySubtask<'a> {
        
        type Params = (&'a TcpSocket, bool, );
        type Results = Result<(),ErrorCode>;
        type ParamsLower = ParamsLower;
        fn abi_layout(&mut self) -> ::core::alloc::Layout {
          unsafe {
            ::core::alloc::Layout::from_size_align_unchecked(2, 1)
          }
        }
        
        fn results_offset(&mut self) -> usize { 0 }

        unsafe fn call_import(&mut self, _params: Self::ParamsLower, _results: *mut u8) -> u32 {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2026-01-06")]
          unsafe extern "C" {
            #[link_name = "[async-lower][method]tcp-socket.set-keep-alive-enabled"]
            fn call(_: i32, _: i32, _: *mut u8, ) -> i32;
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn call(_: i32, _: i32, _: *mut u8, ) -> i32 { unreachable!() }
          
          unsafe { call(_params.0,_params.1,_results) as u32 }
        }
        
        unsafe fn params_dealloc_lists(&mut self, _params: Self::ParamsLower) {
          unsafe {  }
        }
        unsafe fn params_dealloc_lists_and_own(&mut self, _params: Self::ParamsLower) {
          unsafe {  }
        }
        unsafe fn params_lower(&mut self, (_lower0, _lower1,): Self::Params, _ptr: *mut u8) -> Self::ParamsLower {
          unsafe {  ParamsLower((_lower0).handle() as i32, match _lower1 { true => 1, false => 0 },) }
        }
        unsafe fn results_lift(&mut self, _ptr: *mut u8) -> Self::Results {
          unsafe { let l0 = i32::from(*_ptr.add(0).cast::<u8>());

          match l0 {
            0 => {
              let e = ();
              Ok(e)
            }
            1 => {
              let e = {
                let l1 = i32::from(*_ptr.add(1).cast::<u8>());

                ErrorCode::_lift(l1 as u8)
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          } }
        }
      }
      _MySubtask { _unused: core::marker::PhantomData }.call((self, value,)).await
    }
  }
}
impl TcpSocket {
  #[allow(unused_unsafe, clippy::all)]
  /// Amount of time the connection has to be idle before TCP starts sending keepalive packets.
  ///
  /// If the provided value is 0, an `invalid-argument` error is returned.
  /// Any other value will never cause an error, but it might be silently clamped and/or rounded.
  /// I.e. after setting a value, reading the same setting back may return a different value.
  ///
  /// Equivalent to the TCP_KEEPIDLE socket option. (TCP_KEEPALIVE on MacOS)
  ///
  /// # Typical errors
  /// - `invalid-argument`:     (set) The provided value was 0.
  #[allow(async_fn_in_trait)]
  pub async fn get_keep_alive_idle_time(&self,) -> Result<Duration,ErrorCode>{
    unsafe {

      #[derive(Copy, Clone)]
      struct ParamsLower(
      i32, 
      );
      unsafe impl Send for ParamsLower {}
      

      use wit_bindgen::rt::async_support::Subtask as _Subtask;
      struct _MySubtask<'a> { _unused: core::marker::PhantomData<&'a ()> }
      #[allow(unused_parens)]
      unsafe impl<'a> _Subtask for _MySubtask<'a> {
        
        type Params = (&'a TcpSocket, );
        type Results = Result<Duration,ErrorCode>;
        type ParamsLower = ParamsLower;
        fn abi_layout(&mut self) -> ::core::alloc::Layout {
          unsafe {
            ::core::alloc::Layout::from_size_align_unchecked(16, 8)
          }
        }
        
        fn results_offset(&mut self) -> usize { 0 }

        unsafe fn call_import(&mut self, _params: Self::ParamsLower, _results: *mut u8) -> u32 {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2026-01-06")]
          unsafe extern "C" {
            #[link_name = "[async-lower][method]tcp-socket.get-keep-alive-idle-time"]
            fn call(_: i32, _: *mut u8, ) -> i32;
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn call(_: i32, _: *mut u8, ) -> i32 { unreachable!() }
          
          unsafe { call(_params.0,_results) as u32 }
        }
        
        unsafe fn params_dealloc_lists(&mut self, _params: Self::ParamsLower) {
          unsafe {  }
        }
        unsafe fn params_dealloc_lists_and_own(&mut self, _params: Self::ParamsLower) {
          unsafe {  }
        }
        unsafe fn params_lower(&mut self, (_lower0,): Self::Params, _ptr: *mut u8) -> Self::ParamsLower {
          unsafe {  ParamsLower((_lower0).handle() as i32,) }
        }
        unsafe fn results_lift(&mut self, _ptr: *mut u8) -> Self::Results {
          unsafe { let l0 = i32::from(*_ptr.add(0).cast::<u8>());

          match l0 {
            0 => {
              let e = {
                let l1 = *_ptr.add(8).cast::<i64>();

                l1 as u64
              };
              Ok(e)
            }
            1 => {
              let e = {
                let l2 = i32::from(*_ptr.add(8).cast::<u8>());

                ErrorCode::_lift(l2 as u8)
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          } }
        }
      }
      _MySubtask { _unused: core::marker::PhantomData }.call((self,)).await
    }
  }
}
impl TcpSocket {
  #[allow(unused_unsafe, clippy::all)]
  #[allow(async_fn_in_trait)]
  pub async fn set_keep_alive_idle_time(&self,value: Duration,) -> Result<(),ErrorCode>{
    unsafe {

      #[derive(Copy, Clone)]
      struct ParamsLower(
      i32, i64, 
      );
      unsafe impl Send for ParamsLower {}
      

      use wit_bindgen::rt::async_support::Subtask as _Subtask;
      struct _MySubtask<'a> { _unused: core::marker::PhantomData<&'a ()> }
      #[allow(unused_parens)]
      unsafe impl<'a> _Subtask for _MySubtask<'a> {
        
        type Params = (&'a TcpSocket, Duration, );
        type Results = Result<(),ErrorCode>;
        type ParamsLower = ParamsLower;
        fn abi_layout(&mut self) -> ::core::alloc::Layout {
          unsafe {
            ::core::alloc::Layout::from_size_align_unchecked(2, 1)
          }
        }
        
        fn results_offset(&mut self) -> usize { 0 }

        unsafe fn call_import(&mut self, _params: Self::ParamsLower, _results: *mut u8) -> u32 {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2026-01-06")]
          unsafe extern "C" {
            #[link_name = "[async-lower][method]tcp-socket.set-keep-alive-idle-time"]
            fn call(_: i32, _: i64, _: *mut u8, ) -> i32;
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn call(_: i32, _: i64, _: *mut u8, ) -> i32 { unreachable!() }
          
          unsafe { call(_params.0,_params.1,_results) as u32 }
        }
        
        unsafe fn params_dealloc_lists(&mut self, _params: Self::ParamsLower) {
          unsafe {  }
        }
        unsafe fn params_dealloc_lists_and_own(&mut self, _params: Self::ParamsLower) {
          unsafe {  }
        }
        unsafe fn params_lower(&mut self, (_lower0, _lower1,): Self::Params, _ptr: *mut u8) -> Self::ParamsLower {
          unsafe {  ParamsLower((_lower0).handle() as i32, _rt::as_i64(_lower1),) }
        }
        unsafe fn results_lift(&mut self, _ptr: *mut u8) -> Self::Results {
          unsafe { let l0 = i32::from(*_ptr.add(0).cast::<u8>());

          match l0 {
            0 => {
              let e = ();
              Ok(e)
            }
            1 => {
              let e = {
                let l1 = i32::from(*_ptr.add(1).cast::<u8>());

                ErrorCode::_lift(l1 as u8)
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          } }
        }
      }
      _MySubtask { _unused: core::marker::PhantomData }.call((self, value,)).await
    }
  }
}
impl TcpSocket {
  #[allow(unused_unsafe, clippy::all)]
  /// The time between keepalive packets.
  ///
  /// If the provided value is 0, an `invalid-argument` error is returned.
  /// Any other value will never cause an error, but it might be silently clamped and/or rounded.
  /// I.e. after setting a value, reading the same setting back may return a different value.
  ///
  /// Equivalent to the TCP_KEEPINTVL socket option.
  ///
  /// # Typical errors
  /// - `invalid-argument`:     (set) The provided value was 0.
  #[allow(async_fn_in_trait)]
  pub async fn get_keep_alive_interval(&self,) -> Result<Duration,ErrorCode>{
    unsafe {

      #[derive(Copy, Clone)]
      struct ParamsLower(
      i32, 
      );
      unsafe impl Send for ParamsLower {}
      

      use wit_bindgen::rt::async_support::Subtask as _Subtask;
      struct _MySubtask<'a> { _unused: core::marker::PhantomData<&'a ()> }
      #[allow(unused_parens)]
      unsafe impl<'a> _Subtask for _MySubtask<'a> {
        
        type Params = (&'a TcpSocket, );
        type Results = Result<Duration,ErrorCode>;
        type ParamsLower = ParamsLower;
        fn abi_layout(&mut self) -> ::core::alloc::Layout {
          unsafe {
            ::core::alloc::Layout::from_size_align_unchecked(16, 8)
          }
        }
        
        fn results_offset(&mut self) -> usize { 0 }

        unsafe fn call_import(&mut self, _params: Self::ParamsLower, _results: *mut u8) -> u32 {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2026-01-06")]
          unsafe extern "C" {
            #[link_name = "[async-lower][method]tcp-socket.get-keep-alive-interval"]
            fn call(_: i32, _: *mut u8, ) -> i32;
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn call(_: i32, _: *mut u8, ) -> i32 { unreachable!() }
          
          unsafe { call(_params.0,_results) as u32 }
        }
        
        unsafe fn params_dealloc_lists(&mut self, _params: Self::ParamsLower) {
          unsafe {  }
        }
        unsafe fn params_dealloc_lists_and_own(&mut self, _params: Self::ParamsLower) {
          unsafe {  }
        }
        unsafe fn params_lower(&mut self, (_lower0,): Self::Params, _ptr: *mut u8) -> Self::ParamsLower {
          unsafe {  ParamsLower((_lower0).handle() as i32,) }
        }
        unsafe fn results_lift(&mut self, _ptr: *mut u8) -> Self::Results {
          unsafe { let l0 = i32::from(*_ptr.add(0).cast::<u8>());

          match l0 {
            0 => {
              let e = {
                let l1 = *_ptr.add(8).cast::<i64>();

                l1 as u64
              };
              Ok(e)
            }
            1 => {
              let e = {
                let l2 = i32::from(*_ptr.add(8).cast::<u8>());

                ErrorCode::_lift(l2 as u8)
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          } }
        }
      }
      _MySubtask { _unused: core::marker::PhantomData }.call((self,)).await
    }
  }
}
impl TcpSocket {
  #[allow(unused_unsafe, clippy::all)]
  #[allow(async_fn_in_trait)]
  pub async fn set_keep_alive_interval(&self,value: Duration,) -> Result<(),ErrorCode>{
    unsafe {

      #[derive(Copy, Clone)]
      struct ParamsLower(
      i32, i64, 
      );
      unsafe impl Send for ParamsLower {}
      

      use wit_bindgen::rt::async_support::Subtask as _Subtask;
      struct _MySubtask<'a> { _unused: core::marker::PhantomData<&'a ()> }
      #[allow(unused_parens)]
      unsafe impl<'a> _Subtask for _MySubtask<'a> {
        
        type Params = (&'a TcpSocket, Duration, );
        type Results = Result<(),ErrorCode>;
        type ParamsLower = ParamsLower;
        fn abi_layout(&mut self) -> ::core::alloc::Layout {
          unsafe {
            ::core::alloc::Layout::from_size_align_unchecked(2, 1)
          }
        }
        
        fn results_offset(&mut self) -> usize { 0 }

        unsafe fn call_import(&mut self, _params: Self::ParamsLower, _results: *mut u8) -> u32 {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2026-01-06")]
          unsafe extern "C" {
            #[link_name = "[async-lower][method]tcp-socket.set-keep-alive-interval"]
            fn call(_: i32, _: i64, _: *mut u8, ) -> i32;
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn call(_: i32, _: i64, _: *mut u8, ) -> i32 { unreachable!() }
          
          unsafe { call(_params.0,_params.1,_results) as u32 }
        }
        
        unsafe fn params_dealloc_lists(&mut self, _params: Self::ParamsLower) {
          unsafe {  }
        }
        unsafe fn params_dealloc_lists_and_own(&mut self, _params: Self::ParamsLower) {
          unsafe {  }
        }
        unsafe fn params_lower(&mut self, (_lower0, _lower1,): Self::Params, _ptr: *mut u8) -> Self::ParamsLower {
          unsafe {  ParamsLower((_lower0).handle() as i32, _rt::as_i64(_lower1),) }
        }
        unsafe fn results_lift(&mut self, _ptr: *mut u8) -> Self::Results {
          unsafe { let l0 = i32::from(*_ptr.add(0).cast::<u8>());

          match l0 {
            0 => {
              let e = ();
              Ok(e)
            }
            1 => {
              let e = {
                let l1 = i32::from(*_ptr.add(1).cast::<u8>());

                ErrorCode::_lift(l1 as u8)
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          } }
        }
      }
      _MySubtask { _unused: core::marker::PhantomData }.call((self, value,)).await
    }
  }
}
impl TcpSocket {
  #[allow(unused_unsafe, clippy::all)]
  /// The maximum amount of keepalive packets TCP should send before aborting the connection.
  ///
  /// If the provided value is 0, an `invalid-argument` error is returned.
  /// Any other value will never cause an error, but it might be silently clamped and/or rounded.
  /// I.e. after setting a value, reading the same setting back may return a different value.
  ///
  /// Equivalent to the TCP_KEEPCNT socket option.
  ///
  /// # Typical errors
  /// - `invalid-argument`:     (set) The provided value was 0.
  #[allow(async_fn_in_trait)]
  pub async fn get_keep_alive_count(&self,) -> Result<u32,ErrorCode>{
    unsafe {

      #[derive(Copy, Clone)]
      struct ParamsLower(
      i32, 
      );
      unsafe impl Send for ParamsLower {}
      

      use wit_bindgen::rt::async_support::Subtask as _Subtask;
      struct _MySubtask<'a> { _unused: core::marker::PhantomData<&'a ()> }
      #[allow(unused_parens)]
      unsafe impl<'a> _Subtask for _MySubtask<'a> {
        
        type Params = (&'a TcpSocket, );
        type Results = Result<u32,ErrorCode>;
        type ParamsLower = ParamsLower;
        fn abi_layout(&mut self) -> ::core::alloc::Layout {
          unsafe {
            ::core::alloc::Layout::from_size_align_unchecked(8, 4)
          }
        }
        
        fn results_offset(&mut self) -> usize { 0 }

        unsafe fn call_import(&mut self, _params: Self::ParamsLower, _results: *mut u8) -> u32 {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2026-01-06")]
          unsafe extern "C" {
            #[link_name = "[async-lower][method]tcp-socket.get-keep-alive-count"]
            fn call(_: i32, _: *mut u8, ) -> i32;
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn call(_: i32, _: *mut u8, ) -> i32 { unreachable!() }
          
          unsafe { call(_params.0,_results) as u32 }
        }
        
        unsafe fn params_dealloc_lists(&mut self, _params: Self::ParamsLower) {
          unsafe {  }
        }
        unsafe fn params_dealloc_lists_and_own(&mut self, _params: Self::ParamsLower) {
          unsafe {  }
        }
        unsafe fn params_lower(&mut self, (_lower0,): Self::Params, _ptr: *mut u8) -> Self::ParamsLower {
          unsafe {  ParamsLower((_lower0).handle() as i32,) }
        }
        unsafe fn results_lift(&mut self, _ptr: *mut u8) -> Self::Results {
          unsafe { let l0 = i32::from(*_ptr.add(0).cast::<u8>());

          match l0 {
            0 => {
              let e = {
                let l1 = *_ptr.add(4).cast::<i32>();

                l1 as u32
              };
              Ok(e)
            }
            1 => {
              let e = {
                let l2 = i32::from(*_ptr.add(4).cast::<u8>());

                ErrorCode::_lift(l2 as u8)
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          } }
        }
      }
      _MySubtask { _unused: core::marker::PhantomData }.call((self,)).await
    }
  }
}
impl TcpSocket {
  #[allow(unused_unsafe, clippy::all)]
  #[allow(async_fn_in_trait)]
  pub async fn set_keep_alive_count(&self,value: u32,) -> Result<(),ErrorCode>{
    unsafe {

      #[derive(Copy, Clone)]
      struct ParamsLower(
      i32, i32, 
      );
      unsafe impl Send for ParamsLower {}
      

      use wit_bindgen::rt::async_support::Subtask as _Subtask;
      struct _MySubtask<'a> { _unused: core::marker::PhantomData<&'a ()> }
      #[allow(unused_parens)]
      unsafe impl<'a> _Subtask for _MySubtask<'a> {
        
        type Params = (&'a TcpSocket, u32, );
        type Results = Result<(),ErrorCode>;
        type ParamsLower = ParamsLower;
        fn abi_layout(&mut self) -> ::core::alloc::Layout {
          unsafe {
            ::core::alloc::Layout::from_size_align_unchecked(2, 1)
          }
        }
        
        fn results_offset(&mut self) -> usize { 0 }

        unsafe fn call_import(&mut self, _params: Self::ParamsLower, _results: *mut u8) -> u32 {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2026-01-06")]
          unsafe extern "C" {
            #[link_name = "[async-lower][method]tcp-socket.set-keep-alive-count"]
            fn call(_: i32, _: i32, _: *mut u8, ) -> i32;
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn call(_: i32, _: i32, _: *mut u8, ) -> i32 { unreachable!() }
          
          unsafe { call(_params.0,_params.1,_results) as u32 }
        }
        
        unsafe fn params_dealloc_lists(&mut self, _params: Self::ParamsLower) {
          unsafe {  }
        }
        unsafe fn params_dealloc_lists_and_own(&mut self, _params: Self::ParamsLower) {
          unsafe {  }
        }
        unsafe fn params_lower(&mut self, (_lower0, _lower1,): Self::Params, _ptr: *mut u8) -> Self::ParamsLower {
          unsafe {  ParamsLower((_lower0).handle() as i32, _rt::as_i32(_lower1),) }
        }
        unsafe fn results_lift(&mut self, _ptr: *mut u8) -> Self::Results {
          unsafe { let l0 = i32::from(*_ptr.add(0).cast::<u8>());

          match l0 {
            0 => {
              let e = ();
              Ok(e)
            }
            1 => {
              let e = {
                let l1 = i32::from(*_ptr.add(1).cast::<u8>());

                ErrorCode::_lift(l1 as u8)
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          } }
        }
      }
      _MySubtask { _unused: core::marker::PhantomData }.call((self, value,)).await
    }
  }
}
impl TcpSocket {
  #[allow(unused_unsafe, clippy::all)]
  /// Equivalent to the IP_TTL & IPV6_UNICAST_HOPS socket options.
  ///
  /// If the provided value is 0, an `invalid-argument` error is returned.
  ///
  /// # Typical errors
  /// - `invalid-argument`:     (set) The TTL value must be 1 or higher.
  #[allow(async_fn_in_trait)]
  pub async fn get_hop_limit(&self,) -> Result<u8,ErrorCode>{
    unsafe {

      #[derive(Copy, Clone)]
      struct ParamsLower(
      i32, 
      );
      unsafe impl Send for ParamsLower {}
      

      use wit_bindgen::rt::async_support::Subtask as _Subtask;
      struct _MySubtask<'a> { _unused: core::marker::PhantomData<&'a ()> }
      #[allow(unused_parens)]
      unsafe impl<'a> _Subtask for _MySubtask<'a> {
        
        type Params = (&'a TcpSocket, );
        type Results = Result<u8,ErrorCode>;
        type ParamsLower = ParamsLower;
        fn abi_layout(&mut self) -> ::core::alloc::Layout {
          unsafe {
            ::core::alloc::Layout::from_size_align_unchecked(2, 1)
          }
        }
        
        fn results_offset(&mut self) -> usize { 0 }

        unsafe fn call_import(&mut self, _params: Self::ParamsLower, _results: *mut u8) -> u32 {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2026-01-06")]
          unsafe extern "C" {
            #[link_name = "[async-lower][method]tcp-socket.get-hop-limit"]
            fn call(_: i32, _: *mut u8, ) -> i32;
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn call(_: i32, _: *mut u8, ) -> i32 { unreachable!() }
          
          unsafe { call(_params.0,_results) as u32 }
        }
        
        unsafe fn params_dealloc_lists(&mut self, _params: Self::ParamsLower) {
          unsafe {  }
        }
        unsafe fn params_dealloc_lists_and_own(&mut self, _params: Self::ParamsLower) {
          unsafe {  }
        }
        unsafe fn params_lower(&mut self, (_lower0,): Self::Params, _ptr: *mut u8) -> Self::ParamsLower {
          unsafe {  ParamsLower((_lower0).handle() as i32,) }
        }
        unsafe fn results_lift(&mut self, _ptr: *mut u8) -> Self::Results {
          unsafe { let l0 = i32::from(*_ptr.add(0).cast::<u8>());

          match l0 {
            0 => {
              let e = {
                let l1 = i32::from(*_ptr.add(1).cast::<u8>());

                l1 as u8
              };
              Ok(e)
            }
            1 => {
              let e = {
                let l2 = i32::from(*_ptr.add(1).cast::<u8>());

                ErrorCode::_lift(l2 as u8)
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          } }
        }
      }
      _MySubtask { _unused: core::marker::PhantomData }.call((self,)).await
    }
  }
}
impl TcpSocket {
  #[allow(unused_unsafe, clippy::all)]
  #[allow(async_fn_in_trait)]
  pub async fn set_hop_limit(&self,value: u8,) -> Result<(),ErrorCode>{
    unsafe {

      #[derive(Copy, Clone)]
      struct ParamsLower(
      i32, i32, 
      );
      unsafe impl Send for ParamsLower {}
      

      use wit_bindgen::rt::async_support::Subtask as _Subtask;
      struct _MySubtask<'a> { _unused: core::marker::PhantomData<&'a ()> }
      #[allow(unused_parens)]
      unsafe impl<'a> _Subtask for _MySubtask<'a> {
        
        type Params = (&'a TcpSocket, u8, );
        type Results = Result<(),ErrorCode>;
        type ParamsLower = ParamsLower;
        fn abi_layout(&mut self) -> ::core::alloc::Layout {
          unsafe {
            ::core::alloc::Layout::from_size_align_unchecked(2, 1)
          }
        }
        
        fn results_offset(&mut self) -> usize { 0 }

        unsafe fn call_import(&mut self, _params: Self::ParamsLower, _results: *mut u8) -> u32 {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2026-01-06")]
          unsafe extern "C" {
            #[link_name = "[async-lower][method]tcp-socket.set-hop-limit"]
            fn call(_: i32, _: i32, _: *mut u8, ) -> i32;
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn call(_: i32, _: i32, _: *mut u8, ) -> i32 { unreachable!() }
          
          unsafe { call(_params.0,_params.1,_results) as u32 }
        }
        
        unsafe fn params_dealloc_lists(&mut self, _params: Self::ParamsLower) {
          unsafe {  }
        }
        unsafe fn params_dealloc_lists_and_own(&mut self, _params: Self::ParamsLower) {
          unsafe {  }
        }
        unsafe fn params_lower(&mut self, (_lower0, _lower1,): Self::Params, _ptr: *mut u8) -> Self::ParamsLower {
          unsafe {  ParamsLower((_lower0).handle() as i32, _rt::as_i32(_lower1),) }
        }
        unsafe fn results_lift(&mut self, _ptr: *mut u8) -> Self::Results {
          unsafe { let l0 = i32::from(*_ptr.add(0).cast::<u8>());

          match l0 {
            0 => {
              let e = ();
              Ok(e)
            }
            1 => {
              let e = {
                let l1 = i32::from(*_ptr.add(1).cast::<u8>());

                ErrorCode::_lift(l1 as u8)
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          } }
        }
      }
      _MySubtask { _unused: core::marker::PhantomData }.call((self, value,)).await
    }
  }
}
impl TcpSocket {
  #[allow(unused_unsafe, clippy::all)]
  /// The kernel buffer space reserved for sends/receives on this socket.
  ///
  /// If the provided value is 0, an `invalid-argument` error is returned.
  /// Any other value will never cause an error, but it might be silently clamped and/or rounded.
  /// I.e. after setting a value, reading the same setting back may return a different value.
  ///
  /// Equivalent to the SO_RCVBUF and SO_SNDBUF socket options.
  ///
  /// # Typical errors
  /// - `invalid-argument`:     (set) The provided value was 0.
  #[allow(async_fn_in_trait)]
  pub async fn get_receive_buffer_size(&self,) -> Result<u64,ErrorCode>{
    unsafe {

      #[derive(Copy, Clone)]
      struct ParamsLower(
      i32, 
      );
      unsafe impl Send for ParamsLower {}
      

      use wit_bindgen::rt::async_support::Subtask as _Subtask;
      struct _MySubtask<'a> { _unused: core::marker::PhantomData<&'a ()> }
      #[allow(unused_parens)]
      unsafe impl<'a> _Subtask for _MySubtask<'a> {
        
        type Params = (&'a TcpSocket, );
        type Results = Result<u64,ErrorCode>;
        type ParamsLower = ParamsLower;
        fn abi_layout(&mut self) -> ::core::alloc::Layout {
          unsafe {
            ::core::alloc::Layout::from_size_align_unchecked(16, 8)
          }
        }
        
        fn results_offset(&mut self) -> usize { 0 }

        unsafe fn call_import(&mut self, _params: Self::ParamsLower, _results: *mut u8) -> u32 {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2026-01-06")]
          unsafe extern "C" {
            #[link_name = "[async-lower][method]tcp-socket.get-receive-buffer-size"]
            fn call(_: i32, _: *mut u8, ) -> i32;
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn call(_: i32, _: *mut u8, ) -> i32 { unreachable!() }
          
          unsafe { call(_params.0,_results) as u32 }
        }
        
        unsafe fn params_dealloc_lists(&mut self, _params: Self::ParamsLower) {
          unsafe {  }
        }
        unsafe fn params_dealloc_lists_and_own(&mut self, _params: Self::ParamsLower) {
          unsafe {  }
        }
        unsafe fn params_lower(&mut self, (_lower0,): Self::Params, _ptr: *mut u8) -> Self::ParamsLower {
          unsafe {  ParamsLower((_lower0).handle() as i32,) }
        }
        unsafe fn results_lift(&mut self, _ptr: *mut u8) -> Self::Results {
          unsafe { let l0 = i32::from(*_ptr.add(0).cast::<u8>());

          match l0 {
            0 => {
              let e = {
                let l1 = *_ptr.add(8).cast::<i64>();

                l1 as u64
              };
              Ok(e)
            }
            1 => {
              let e = {
                let l2 = i32::from(*_ptr.add(8).cast::<u8>());

                ErrorCode::_lift(l2 as u8)
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          } }
        }
      }
      _MySubtask { _unused: core::marker::PhantomData }.call((self,)).await
    }
  }
}
impl TcpSocket {
  #[allow(unused_unsafe, clippy::all)]
  #[allow(async_fn_in_trait)]
  pub async fn set_receive_buffer_size(&self,value: u64,) -> Result<(),ErrorCode>{
    unsafe {

      #[derive(Copy, Clone)]
      struct ParamsLower(
      i32, i64, 
      );
      unsafe impl Send for ParamsLower {}
      

      use wit_bindgen::rt::async_support::Subtask as _Subtask;
      struct _MySubtask<'a> { _unused: core::marker::PhantomData<&'a ()> }
      #[allow(unused_parens)]
      unsafe impl<'a> _Subtask for _MySubtask<'a> {
        
        type Params = (&'a TcpSocket, u64, );
        type Results = Result<(),ErrorCode>;
        type ParamsLower = ParamsLower;
        fn abi_layout(&mut self) -> ::core::alloc::Layout {
          unsafe {
            ::core::alloc::Layout::from_size_align_unchecked(2, 1)
          }
        }
        
        fn results_offset(&mut self) -> usize { 0 }

        unsafe fn call_import(&mut self, _params: Self::ParamsLower, _results: *mut u8) -> u32 {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2026-01-06")]
          unsafe extern "C" {
            #[link_name = "[async-lower][method]tcp-socket.set-receive-buffer-size"]
            fn call(_: i32, _: i64, _: *mut u8, ) -> i32;
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn call(_: i32, _: i64, _: *mut u8, ) -> i32 { unreachable!() }
          
          unsafe { call(_params.0,_params.1,_results) as u32 }
        }
        
        unsafe fn params_dealloc_lists(&mut self, _params: Self::ParamsLower) {
          unsafe {  }
        }
        unsafe fn params_dealloc_lists_and_own(&mut self, _params: Self::ParamsLower) {
          unsafe {  }
        }
        unsafe fn params_lower(&mut self, (_lower0, _lower1,): Self::Params, _ptr: *mut u8) -> Self::ParamsLower {
          unsafe {  ParamsLower((_lower0).handle() as i32, _rt::as_i64(_lower1),) }
        }
        unsafe fn results_lift(&mut self, _ptr: *mut u8) -> Self::Results {
          unsafe { let l0 = i32::from(*_ptr.add(0).cast::<u8>());

          match l0 {
            0 => {
              let e = ();
              Ok(e)
            }
            1 => {
              let e = {
                let l1 = i32::from(*_ptr.add(1).cast::<u8>());

                ErrorCode::_lift(l1 as u8)
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          } }
        }
      }
      _MySubtask { _unused: core::marker::PhantomData }.call((self, value,)).await
    }
  }
}
impl TcpSocket {
  #[allow(unused_unsafe, clippy::all)]
  #[allow(async_fn_in_trait)]
  pub async fn get_send_buffer_size(&self,) -> Result<u64,ErrorCode>{
    unsafe {

      #[derive(Copy, Clone)]
      struct ParamsLower(
      i32, 
      );
      unsafe impl Send for ParamsLower {}
      

      use wit_bindgen::rt::async_support::Subtask as _Subtask;
      struct _MySubtask<'a> { _unused: core::marker::PhantomData<&'a ()> }
      #[allow(unused_parens)]
      unsafe impl<'a> _Subtask for _MySubtask<'a> {
        
        type Params = (&'a TcpSocket, );
        type Results = Result<u64,ErrorCode>;
        type ParamsLower = ParamsLower;
        fn abi_layout(&mut self) -> ::core::alloc::Layout {
          unsafe {
            ::core::alloc::Layout::from_size_align_unchecked(16, 8)
          }
        }
        
        fn results_offset(&mut self) -> usize { 0 }

        unsafe fn call_import(&mut self, _params: Self::ParamsLower, _results: *mut u8) -> u32 {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2026-01-06")]
          unsafe extern "C" {
            #[link_name = "[async-lower][method]tcp-socket.get-send-buffer-size"]
            fn call(_: i32, _: *mut u8, ) -> i32;
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn call(_: i32, _: *mut u8, ) -> i32 { unreachable!() }
          
          unsafe { call(_params.0,_results) as u32 }
        }
        
        unsafe fn params_dealloc_lists(&mut self, _params: Self::ParamsLower) {
          unsafe {  }
        }
        unsafe fn params_dealloc_lists_and_own(&mut self, _params: Self::ParamsLower) {
          unsafe {  }
        }
        unsafe fn params_lower(&mut self, (_lower0,): Self::Params, _ptr: *mut u8) -> Self::ParamsLower {
          unsafe {  ParamsLower((_lower0).handle() as i32,) }
        }
        unsafe fn results_lift(&mut self, _ptr: *mut u8) -> Self::Results {
          unsafe { let l0 = i32::from(*_ptr.add(0).cast::<u8>());

          match l0 {
            0 => {
              let e = {
                let l1 = *_ptr.add(8).cast::<i64>();

                l1 as u64
              };
              Ok(e)
            }
            1 => {
              let e = {
                let l2 = i32::from(*_ptr.add(8).cast::<u8>());

                ErrorCode::_lift(l2 as u8)
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          } }
        }
      }
      _MySubtask { _unused: core::marker::PhantomData }.call((self,)).await
    }
  }
}
impl TcpSocket {
  #[allow(unused_unsafe, clippy::all)]
  #[allow(async_fn_in_trait)]
  pub async fn set_send_buffer_size(&self,value: u64,) -> Result<(),ErrorCode>{
    unsafe {

      #[derive(Copy, Clone)]
      struct ParamsLower(
      i32, i64, 
      );
      unsafe impl Send for ParamsLower {}
      

      use wit_bindgen::rt::async_support::Subtask as _Subtask;
      struct _MySubtask<'a> { _unused: core::marker::PhantomData<&'a ()> }
      #[allow(unused_parens)]
      unsafe impl<'a> _Subtask for _MySubtask<'a> {
        
        type Params = (&'a TcpSocket, u64, );
        type Results = Result<(),ErrorCode>;
        type ParamsLower = ParamsLower;
        fn abi_layout(&mut self) -> ::core::alloc::Layout {
          unsafe {
            ::core::alloc::Layout::from_size_align_unchecked(2, 1)
          }
        }
        
        fn results_offset(&mut self) -> usize { 0 }

        unsafe fn call_import(&mut self, _params: Self::ParamsLower, _results: *mut u8) -> u32 {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2026-01-06")]
          unsafe extern "C" {
            #[link_name = "[async-lower][method]tcp-socket.set-send-buffer-size"]
            fn call(_: i32, _: i64, _: *mut u8, ) -> i32;
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn call(_: i32, _: i64, _: *mut u8, ) -> i32 { unreachable!() }
          
          unsafe { call(_params.0,_params.1,_results) as u32 }
        }
        
        unsafe fn params_dealloc_lists(&mut self, _params: Self::ParamsLower) {
          unsafe {  }
        }
        unsafe fn params_dealloc_lists_and_own(&mut self, _params: Self::ParamsLower) {
          unsafe {  }
        }
        unsafe fn params_lower(&mut self, (_lower0, _lower1,): Self::Params, _ptr: *mut u8) -> Self::ParamsLower {
          unsafe {  ParamsLower((_lower0).handle() as i32, _rt::as_i64(_lower1),) }
        }
        unsafe fn results_lift(&mut self, _ptr: *mut u8) -> Self::Results {
          unsafe { let l0 = i32::from(*_ptr.add(0).cast::<u8>());

          match l0 {
            0 => {
              let e = ();
              Ok(e)
            }
            1 => {
              let e = {
                let l1 = i32::from(*_ptr.add(1).cast::<u8>());

                ErrorCode::_lift(l1 as u8)
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          } }
        }
      }
      _MySubtask { _unused: core::marker::PhantomData }.call((self, value,)).await
    }
  }
}
impl UdpSocket {
  #[allow(unused_unsafe, clippy::all)]
  /// Create a new UDP socket.
  ///
  /// Similar to `socket(AF_INET or AF_INET6, SOCK_DGRAM, IPPROTO_UDP)` in POSIX.
  /// On IPv6 sockets, IPV6_V6ONLY is enabled by default and can't be configured otherwise.
  ///
  /// Unlike POSIX, WASI sockets have no notion of a socket-level
  /// `O_NONBLOCK` flag. Instead they fully rely on the Component Model's
  /// async support.
  ///
  /// # References:
  /// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/socket.html>
  /// - <https://man7.org/linux/man-pages/man2/socket.2.html>
  /// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-wsasocketw>
  /// - <https://man.freebsd.org/cgi/man.cgi?query=socket&sektion=2>
  #[allow(async_fn_in_trait)]
  pub async fn create(address_family: IpAddressFamily,) -> Result<UdpSocket,ErrorCode>{
    unsafe {

      #[derive(Copy, Clone)]
      struct ParamsLower(
      i32, 
      );
      unsafe impl Send for ParamsLower {}
      

      use wit_bindgen::rt::async_support::Subtask as _Subtask;
      struct _MySubtask<'a> { _unused: core::marker::PhantomData<&'a ()> }
      #[allow(unused_parens)]
      unsafe impl<'a> _Subtask for _MySubtask<'a> {
        
        type Params = (IpAddressFamily, );
        type Results = Result<UdpSocket,ErrorCode>;
        type ParamsLower = ParamsLower;
        fn abi_layout(&mut self) -> ::core::alloc::Layout {
          unsafe {
            ::core::alloc::Layout::from_size_align_unchecked(8, 4)
          }
        }
        
        fn results_offset(&mut self) -> usize { 0 }

        unsafe fn call_import(&mut self, _params: Self::ParamsLower, _results: *mut u8) -> u32 {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2026-01-06")]
          unsafe extern "C" {
            #[link_name = "[async-lower][static]udp-socket.create"]
            fn call(_: i32, _: *mut u8, ) -> i32;
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn call(_: i32, _: *mut u8, ) -> i32 { unreachable!() }
          
          unsafe { call(_params.0,_results) as u32 }
        }
        
        unsafe fn params_dealloc_lists(&mut self, _params: Self::ParamsLower) {
          unsafe {  }
        }
        unsafe fn params_dealloc_lists_and_own(&mut self, _params: Self::ParamsLower) {
          unsafe {  }
        }
        unsafe fn params_lower(&mut self, (_lower0,): Self::Params, _ptr: *mut u8) -> Self::ParamsLower {
          unsafe {  ParamsLower(_lower0.clone() as i32,) }
        }
        unsafe fn results_lift(&mut self, _ptr: *mut u8) -> Self::Results {
          unsafe { let l0 = i32::from(*_ptr.add(0).cast::<u8>());

          match l0 {
            0 => {
              let e = {
                let l1 = *_ptr.add(4).cast::<i32>();

                UdpSocket::from_handle(l1 as u32)
              };
              Ok(e)
            }
            1 => {
              let e = {
                let l2 = i32::from(*_ptr.add(4).cast::<u8>());

                ErrorCode::_lift(l2 as u8)
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          } }
        }
      }
      _MySubtask { _unused: core::marker::PhantomData }.call((address_family,)).await
    }
  }
}
impl UdpSocket {
  #[allow(unused_unsafe, clippy::all)]
  /// Bind the socket to the provided IP address and port.
  ///
  /// If the IP address is zero (`0.0.0.0` in IPv4, `::` in IPv6), it is left to the implementation to decide which
  /// network interface(s) to bind to.
  /// If the port is zero, the socket will be bound to a random free port.
  ///
  /// # Typical errors
  /// - `invalid-argument`:          The `local-address` has the wrong address family. (EAFNOSUPPORT, EFAULT on Windows)
  /// - `invalid-state`:             The socket is already bound. (EINVAL)
  /// - `address-in-use`:            No ephemeral ports available. (EADDRINUSE, ENOBUFS on Windows)
  /// - `address-in-use`:            Address is already in use. (EADDRINUSE)
  /// - `address-not-bindable`:      `local-address` is not an address that can be bound to. (EADDRNOTAVAIL)
  ///
  /// # References
  /// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/bind.html>
  /// - <https://man7.org/linux/man-pages/man2/bind.2.html>
  /// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-bind>
  /// - <https://man.freebsd.org/cgi/man.cgi?query=bind&sektion=2&format=html>
  #[allow(async_fn_in_trait)]
  pub async fn bind(&self,local_address: IpSocketAddress,) -> Result<(),ErrorCode>{
    unsafe {

      #[derive(Copy, Clone)]
      struct ParamsLower(
      *mut u8, 
      );
      unsafe impl Send for ParamsLower {}
      

      use wit_bindgen::rt::async_support::Subtask as _Subtask;
      struct _MySubtask<'a> { _unused: core::marker::PhantomData<&'a ()> }
      #[allow(unused_parens)]
      unsafe impl<'a> _Subtask for _MySubtask<'a> {
        
        type Params = (&'a UdpSocket, IpSocketAddress, );
        type Results = Result<(),ErrorCode>;
        type ParamsLower = ParamsLower;
        fn abi_layout(&mut self) -> ::core::alloc::Layout {
          unsafe {
            ::core::alloc::Layout::from_size_align_unchecked(40, 4)
          }
        }
        
        fn results_offset(&mut self) -> usize { 36 }

        unsafe fn call_import(&mut self, _params: Self::ParamsLower, _results: *mut u8) -> u32 {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2026-01-06")]
          unsafe extern "C" {
            #[link_name = "[async-lower][method]udp-socket.bind"]
            fn call(_: *mut u8, _: *mut u8, ) -> i32;
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn call(_: *mut u8, _: *mut u8, ) -> i32 { unreachable!() }
          
          unsafe { call(_params.0,_results) as u32 }
        }
        
        unsafe fn params_dealloc_lists(&mut self, _params: Self::ParamsLower) {
          unsafe {  }
        }
        unsafe fn params_dealloc_lists_and_own(&mut self, _params: Self::ParamsLower) {
          unsafe {  }
        }
        unsafe fn params_lower(&mut self, (_lower0, _lower1,): Self::Params, _ptr: *mut u8) -> Self::ParamsLower {
          let _param_ptr = unsafe { _ptr.add(0) };
          unsafe { *_param_ptr.add(0).cast::<i32>() = (_lower0).handle() as i32;
        }
        let _param_ptr = unsafe { _ptr.add(4) };
        unsafe { match _lower1 {
          IpSocketAddress::Ipv4(e) => {
            *_param_ptr.add(0).cast::<u8>() = (0i32) as u8;
            let Ipv4SocketAddress{ port:port0, address:address0, } = e;
            *_param_ptr.add(4).cast::<u16>() = (_rt::as_i32(port0)) as u16;
            let (t1_0, t1_1, t1_2, t1_3, ) = address0;
            *_param_ptr.add(6).cast::<u8>() = (_rt::as_i32(t1_0)) as u8;
            *_param_ptr.add(7).cast::<u8>() = (_rt::as_i32(t1_1)) as u8;
            *_param_ptr.add(8).cast::<u8>() = (_rt::as_i32(t1_2)) as u8;
            *_param_ptr.add(9).cast::<u8>() = (_rt::as_i32(t1_3)) as u8;
          },
          IpSocketAddress::Ipv6(e) => {
            *_param_ptr.add(0).cast::<u8>() = (1i32) as u8;
            let Ipv6SocketAddress{ port:port2, flow_info:flow_info2, address:address2, scope_id:scope_id2, } = e;
            *_param_ptr.add(4).cast::<u16>() = (_rt::as_i32(port2)) as u16;
            *_param_ptr.add(8).cast::<i32>() = _rt::as_i32(flow_info2);
            let (t3_0, t3_1, t3_2, t3_3, t3_4, t3_5, t3_6, t3_7, ) = address2;
            *_param_ptr.add(12).cast::<u16>() = (_rt::as_i32(t3_0)) as u16;
            *_param_ptr.add(14).cast::<u16>() = (_rt::as_i32(t3_1)) as u16;
            *_param_ptr.add(16).cast::<u16>() = (_rt::as_i32(t3_2)) as u16;
            *_param_ptr.add(18).cast::<u16>() = (_rt::as_i32(t3_3)) as u16;
            *_param_ptr.add(20).cast::<u16>() = (_rt::as_i32(t3_4)) as u16;
            *_param_ptr.add(22).cast::<u16>() = (_rt::as_i32(t3_5)) as u16;
            *_param_ptr.add(24).cast::<u16>() = (_rt::as_i32(t3_6)) as u16;
            *_param_ptr.add(26).cast::<u16>() = (_rt::as_i32(t3_7)) as u16;
            *_param_ptr.add(28).cast::<i32>() = _rt::as_i32(scope_id2);
          },
        }
      }
      ParamsLower(_ptr,)
    }
    unsafe fn results_lift(&mut self, _ptr: *mut u8) -> Self::Results {
      unsafe { let l0 = i32::from(*_ptr.add(0).cast::<u8>());

      match l0 {
        0 => {
          let e = ();
          Ok(e)
        }
        1 => {
          let e = {
            let l1 = i32::from(*_ptr.add(1).cast::<u8>());

            ErrorCode::_lift(l1 as u8)
          };
          Err(e)
        }
        _ => _rt::invalid_enum_discriminant(),
      } }
    }
  }
  _MySubtask { _unused: core::marker::PhantomData }.call((self, local_address,)).await
}
}
}
impl UdpSocket {
  #[allow(unused_unsafe, clippy::all)]
  /// Associate this socket with a specific peer address.
  ///
  /// On success, the `remote-address` of the socket is updated.
  /// The `local-address` may be updated as well, based on the best network
  /// path to `remote-address`. If the socket was not already explicitly
  /// bound, this function will implicitly bind the socket to a random
  /// free port.
  ///
  /// When a UDP socket is "connected", the `send` and `receive` methods
  /// are limited to communicating with that peer only:
  /// - `send` can only be used to send to this destination.
  /// - `receive` will only return datagrams sent from the provided `remote-address`.
  ///
  /// The name "connect" was kept to align with the existing POSIX
  /// terminology. Other than that, this function only changes the local
  /// socket configuration and does not generate any network traffic.
  /// The peer is not aware of this "connection".
  ///
  /// This method may be called multiple times on the same socket to change
  /// its association, but only the most recent one will be effective.
  ///
  /// # Typical errors
  /// - `invalid-argument`:          The `remote-address` has the wrong address family. (EAFNOSUPPORT)
  /// - `invalid-argument`:          The IP address in `remote-address` is set to INADDR_ANY (`0.0.0.0` / `::`). (EDESTADDRREQ, EADDRNOTAVAIL)
  /// - `invalid-argument`:          The port in `remote-address` is set to 0. (EDESTADDRREQ, EADDRNOTAVAIL)
  /// - `address-in-use`:            Tried to perform an implicit bind, but there were no ephemeral ports available. (EADDRINUSE, EADDRNOTAVAIL on Linux, EAGAIN on BSD)
  ///
  /// # Implementors note
  /// If the socket is already connected, some platforms (e.g. Linux)
  /// require a disconnect before connecting to a different peer address.
  ///
  /// # References
  /// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/connect.html>
  /// - <https://man7.org/linux/man-pages/man2/connect.2.html>
  /// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-connect>
  /// - <https://man.freebsd.org/cgi/man.cgi?connect>
  #[allow(async_fn_in_trait)]
  pub async fn connect(&self,remote_address: IpSocketAddress,) -> Result<(),ErrorCode>{
    unsafe {

      #[derive(Copy, Clone)]
      struct ParamsLower(
      *mut u8, 
      );
      unsafe impl Send for ParamsLower {}
      

      use wit_bindgen::rt::async_support::Subtask as _Subtask;
      struct _MySubtask<'a> { _unused: core::marker::PhantomData<&'a ()> }
      #[allow(unused_parens)]
      unsafe impl<'a> _Subtask for _MySubtask<'a> {
        
        type Params = (&'a UdpSocket, IpSocketAddress, );
        type Results = Result<(),ErrorCode>;
        type ParamsLower = ParamsLower;
        fn abi_layout(&mut self) -> ::core::alloc::Layout {
          unsafe {
            ::core::alloc::Layout::from_size_align_unchecked(40, 4)
          }
        }
        
        fn results_offset(&mut self) -> usize { 36 }

        unsafe fn call_import(&mut self, _params: Self::ParamsLower, _results: *mut u8) -> u32 {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2026-01-06")]
          unsafe extern "C" {
            #[link_name = "[async-lower][method]udp-socket.connect"]
            fn call(_: *mut u8, _: *mut u8, ) -> i32;
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn call(_: *mut u8, _: *mut u8, ) -> i32 { unreachable!() }
          
          unsafe { call(_params.0,_results) as u32 }
        }
        
        unsafe fn params_dealloc_lists(&mut self, _params: Self::ParamsLower) {
          unsafe {  }
        }
        unsafe fn params_dealloc_lists_and_own(&mut self, _params: Self::ParamsLower) {
          unsafe {  }
        }
        unsafe fn params_lower(&mut self, (_lower0, _lower1,): Self::Params, _ptr: *mut u8) -> Self::ParamsLower {
          let _param_ptr = unsafe { _ptr.add(0) };
          unsafe { *_param_ptr.add(0).cast::<i32>() = (_lower0).handle() as i32;
        }
        let _param_ptr = unsafe { _ptr.add(4) };
        unsafe { match _lower1 {
          IpSocketAddress::Ipv4(e) => {
            *_param_ptr.add(0).cast::<u8>() = (0i32) as u8;
            let Ipv4SocketAddress{ port:port0, address:address0, } = e;
            *_param_ptr.add(4).cast::<u16>() = (_rt::as_i32(port0)) as u16;
            let (t1_0, t1_1, t1_2, t1_3, ) = address0;
            *_param_ptr.add(6).cast::<u8>() = (_rt::as_i32(t1_0)) as u8;
            *_param_ptr.add(7).cast::<u8>() = (_rt::as_i32(t1_1)) as u8;
            *_param_ptr.add(8).cast::<u8>() = (_rt::as_i32(t1_2)) as u8;
            *_param_ptr.add(9).cast::<u8>() = (_rt::as_i32(t1_3)) as u8;
          },
          IpSocketAddress::Ipv6(e) => {
            *_param_ptr.add(0).cast::<u8>() = (1i32) as u8;
            let Ipv6SocketAddress{ port:port2, flow_info:flow_info2, address:address2, scope_id:scope_id2, } = e;
            *_param_ptr.add(4).cast::<u16>() = (_rt::as_i32(port2)) as u16;
            *_param_ptr.add(8).cast::<i32>() = _rt::as_i32(flow_info2);
            let (t3_0, t3_1, t3_2, t3_3, t3_4, t3_5, t3_6, t3_7, ) = address2;
            *_param_ptr.add(12).cast::<u16>() = (_rt::as_i32(t3_0)) as u16;
            *_param_ptr.add(14).cast::<u16>() = (_rt::as_i32(t3_1)) as u16;
            *_param_ptr.add(16).cast::<u16>() = (_rt::as_i32(t3_2)) as u16;
            *_param_ptr.add(18).cast::<u16>() = (_rt::as_i32(t3_3)) as u16;
            *_param_ptr.add(20).cast::<u16>() = (_rt::as_i32(t3_4)) as u16;
            *_param_ptr.add(22).cast::<u16>() = (_rt::as_i32(t3_5)) as u16;
            *_param_ptr.add(24).cast::<u16>() = (_rt::as_i32(t3_6)) as u16;
            *_param_ptr.add(26).cast::<u16>() = (_rt::as_i32(t3_7)) as u16;
            *_param_ptr.add(28).cast::<i32>() = _rt::as_i32(scope_id2);
          },
        }
      }
      ParamsLower(_ptr,)
    }
    unsafe fn results_lift(&mut self, _ptr: *mut u8) -> Self::Results {
      unsafe { let l0 = i32::from(*_ptr.add(0).cast::<u8>());

      match l0 {
        0 => {
          let e = ();
          Ok(e)
        }
        1 => {
          let e = {
            let l1 = i32::from(*_ptr.add(1).cast::<u8>());

            ErrorCode::_lift(l1 as u8)
          };
          Err(e)
        }
        _ => _rt::invalid_enum_discriminant(),
      } }
    }
  }
  _MySubtask { _unused: core::marker::PhantomData }.call((self, remote_address,)).await
}
}
}
impl UdpSocket {
  #[allow(unused_unsafe, clippy::all)]
  /// Dissociate this socket from its peer address.
  ///
  /// After calling this method, `send` & `receive` are free to communicate
  /// with any address again.
  ///
  /// The POSIX equivalent of this is calling `connect` with an `AF_UNSPEC` address.
  ///
  /// # Typical errors
  /// - `invalid-state`:           The socket is not connected.
  ///
  /// # References
  /// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/connect.html>
  /// - <https://man7.org/linux/man-pages/man2/connect.2.html>
  /// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-connect>
  /// - <https://man.freebsd.org/cgi/man.cgi?connect>
  #[allow(async_fn_in_trait)]
  pub async fn disconnect(&self,) -> Result<(),ErrorCode>{
    unsafe {

      #[derive(Copy, Clone)]
      struct ParamsLower(
      i32, 
      );
      unsafe impl Send for ParamsLower {}
      

      use wit_bindgen::rt::async_support::Subtask as _Subtask;
      struct _MySubtask<'a> { _unused: core::marker::PhantomData<&'a ()> }
      #[allow(unused_parens)]
      unsafe impl<'a> _Subtask for _MySubtask<'a> {
        
        type Params = (&'a UdpSocket, );
        type Results = Result<(),ErrorCode>;
        type ParamsLower = ParamsLower;
        fn abi_layout(&mut self) -> ::core::alloc::Layout {
          unsafe {
            ::core::alloc::Layout::from_size_align_unchecked(2, 1)
          }
        }
        
        fn results_offset(&mut self) -> usize { 0 }

        unsafe fn call_import(&mut self, _params: Self::ParamsLower, _results: *mut u8) -> u32 {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2026-01-06")]
          unsafe extern "C" {
            #[link_name = "[async-lower][method]udp-socket.disconnect"]
            fn call(_: i32, _: *mut u8, ) -> i32;
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn call(_: i32, _: *mut u8, ) -> i32 { unreachable!() }
          
          unsafe { call(_params.0,_results) as u32 }
        }
        
        unsafe fn params_dealloc_lists(&mut self, _params: Self::ParamsLower) {
          unsafe {  }
        }
        unsafe fn params_dealloc_lists_and_own(&mut self, _params: Self::ParamsLower) {
          unsafe {  }
        }
        unsafe fn params_lower(&mut self, (_lower0,): Self::Params, _ptr: *mut u8) -> Self::ParamsLower {
          unsafe {  ParamsLower((_lower0).handle() as i32,) }
        }
        unsafe fn results_lift(&mut self, _ptr: *mut u8) -> Self::Results {
          unsafe { let l0 = i32::from(*_ptr.add(0).cast::<u8>());

          match l0 {
            0 => {
              let e = ();
              Ok(e)
            }
            1 => {
              let e = {
                let l1 = i32::from(*_ptr.add(1).cast::<u8>());

                ErrorCode::_lift(l1 as u8)
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          } }
        }
      }
      _MySubtask { _unused: core::marker::PhantomData }.call((self,)).await
    }
  }
}
impl UdpSocket {
  #[allow(unused_unsafe, clippy::all)]
  /// Send a message on the socket to a particular peer.
  ///
  /// If the socket is connected, the peer address may be left empty. In
  /// that case this is equivalent to `send` in POSIX. Otherwise it is
  /// equivalent to `sendto`.
  ///
  /// Additionally, if the socket is connected, a `remote-address` argument
  /// _may_ be provided but then it must be identical to the address
  /// passed to `connect`.
  ///
  /// Implementations may trap if the `data` length exceeds 64 KiB.
  ///
  /// # Typical errors
  /// - `invalid-argument`:        The `remote-address` has the wrong address family. (EAFNOSUPPORT)
  /// - `invalid-argument`:        The IP address in `remote-address` is set to INADDR_ANY (`0.0.0.0` / `::`). (EDESTADDRREQ, EADDRNOTAVAIL)
  /// - `invalid-argument`:        The port in `remote-address` is set to 0. (EDESTADDRREQ, EADDRNOTAVAIL)
  /// - `invalid-argument`:        The socket is in "connected" mode and `remote-address` is `some` value that does not match the address passed to `connect`. (EISCONN)
  /// - `invalid-argument`:        The socket is not "connected" and no value for `remote-address` was provided. (EDESTADDRREQ)
  /// - `remote-unreachable`:      The remote address is not reachable. (ECONNRESET, ENETRESET on Windows, EHOSTUNREACH, EHOSTDOWN, ENETUNREACH, ENETDOWN, ENONET)
  /// - `connection-refused`:      The connection was refused. (ECONNREFUSED)
  /// - `datagram-too-large`:      The datagram is too large. (EMSGSIZE)
  ///
  /// # References
  /// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/sendto.html>
  /// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/sendmsg.html>
  /// - <https://man7.org/linux/man-pages/man2/send.2.html>
  /// - <https://man7.org/linux/man-pages/man2/sendmmsg.2.html>
  /// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-send>
  /// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-sendto>
  /// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-wsasendmsg>
  /// - <https://man.freebsd.org/cgi/man.cgi?query=send&sektion=2>
  #[allow(async_fn_in_trait)]
  pub async fn send(&self,data: _rt::Vec::<u8>,remote_address: Option<IpSocketAddress>,) -> Result<(),ErrorCode>{
    unsafe {

      #[derive(Copy, Clone)]
      struct ParamsLower(
      *mut u8, 
      );
      unsafe impl Send for ParamsLower {}
      

      use wit_bindgen::rt::async_support::Subtask as _Subtask;
      struct _MySubtask<'a> { _unused: core::marker::PhantomData<&'a ()> }
      #[allow(unused_parens)]
      unsafe impl<'a> _Subtask for _MySubtask<'a> {
        
        type Params = (&'a UdpSocket, _rt::Vec::<u8>, Option<IpSocketAddress>, );
        type Results = Result<(),ErrorCode>;
        type ParamsLower = ParamsLower;
        fn abi_layout(&mut self) -> ::core::alloc::Layout {
          unsafe {
            ::core::alloc::Layout::from_size_align_unchecked((40+3*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>())
          }
        }
        
        fn results_offset(&mut self) -> usize { (36+3*::core::mem::size_of::<*const u8>()) }

        unsafe fn call_import(&mut self, _params: Self::ParamsLower, _results: *mut u8) -> u32 {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2026-01-06")]
          unsafe extern "C" {
            #[link_name = "[async-lower][method]udp-socket.send"]
            fn call(_: *mut u8, _: *mut u8, ) -> i32;
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn call(_: *mut u8, _: *mut u8, ) -> i32 { unreachable!() }
          
          unsafe { call(_params.0,_results) as u32 }
        }
        
        unsafe fn params_dealloc_lists(&mut self, _params: Self::ParamsLower) {
          unsafe { let l0 = *_params.0.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
          let l1 = *_params.0.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>();
          let base2 = l0;
          let len2 = l1;
          _rt::cabi_dealloc(base2, len2 * 1, 1);
        }
      }
      unsafe fn params_dealloc_lists_and_own(&mut self, _params: Self::ParamsLower) {
        unsafe { let l0 = *_params.0.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
        let l1 = *_params.0.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>();
        let base2 = l0;
        let len2 = l1;
        _rt::cabi_dealloc(base2, len2 * 1, 1);
      }
    }
    unsafe fn params_lower(&mut self, (_lower0, _lower1, _lower2,): Self::Params, _ptr: *mut u8) -> Self::ParamsLower {
      let _param_ptr = unsafe { _ptr.add(0) };
      unsafe { *_param_ptr.add(0).cast::<i32>() = (_lower0).handle() as i32;
    }
    let _param_ptr = unsafe { _ptr.add(::core::mem::size_of::<*const u8>()) };
    unsafe { let vec0 = <_ as Into<_rt::Vec<_>>>::into(_lower1).into_boxed_slice();
    let ptr0 = vec0.as_ptr().cast::<u8>();
    let len0 = vec0.len();
    ::core::mem::forget(vec0);
    *_param_ptr.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len0;
    *_param_ptr.add(0).cast::<*mut u8>() = ptr0.cast_mut();
  }
  let _param_ptr = unsafe { _ptr.add((3*::core::mem::size_of::<*const u8>())) };
  unsafe { match _lower2 {
    Some(e) => {
      *_param_ptr.add(0).cast::<u8>() = (1i32) as u8;
      match e {
        IpSocketAddress::Ipv4(e) => {
          *_param_ptr.add(4).cast::<u8>() = (0i32) as u8;
          let Ipv4SocketAddress{ port:port0, address:address0, } = e;
          *_param_ptr.add(8).cast::<u16>() = (_rt::as_i32(port0)) as u16;
          let (t1_0, t1_1, t1_2, t1_3, ) = address0;
          *_param_ptr.add(10).cast::<u8>() = (_rt::as_i32(t1_0)) as u8;
          *_param_ptr.add(11).cast::<u8>() = (_rt::as_i32(t1_1)) as u8;
          *_param_ptr.add(12).cast::<u8>() = (_rt::as_i32(t1_2)) as u8;
          *_param_ptr.add(13).cast::<u8>() = (_rt::as_i32(t1_3)) as u8;
        },
        IpSocketAddress::Ipv6(e) => {
          *_param_ptr.add(4).cast::<u8>() = (1i32) as u8;
          let Ipv6SocketAddress{ port:port2, flow_info:flow_info2, address:address2, scope_id:scope_id2, } = e;
          *_param_ptr.add(8).cast::<u16>() = (_rt::as_i32(port2)) as u16;
          *_param_ptr.add(12).cast::<i32>() = _rt::as_i32(flow_info2);
          let (t3_0, t3_1, t3_2, t3_3, t3_4, t3_5, t3_6, t3_7, ) = address2;
          *_param_ptr.add(16).cast::<u16>() = (_rt::as_i32(t3_0)) as u16;
          *_param_ptr.add(18).cast::<u16>() = (_rt::as_i32(t3_1)) as u16;
          *_param_ptr.add(20).cast::<u16>() = (_rt::as_i32(t3_2)) as u16;
          *_param_ptr.add(22).cast::<u16>() = (_rt::as_i32(t3_3)) as u16;
          *_param_ptr.add(24).cast::<u16>() = (_rt::as_i32(t3_4)) as u16;
          *_param_ptr.add(26).cast::<u16>() = (_rt::as_i32(t3_5)) as u16;
          *_param_ptr.add(28).cast::<u16>() = (_rt::as_i32(t3_6)) as u16;
          *_param_ptr.add(30).cast::<u16>() = (_rt::as_i32(t3_7)) as u16;
          *_param_ptr.add(32).cast::<i32>() = _rt::as_i32(scope_id2);
        },
      }
    },
    None => {
      {
        *_param_ptr.add(0).cast::<u8>() = (0i32) as u8;
      }
    },
  }; }
  ParamsLower(_ptr,)
}
unsafe fn results_lift(&mut self, _ptr: *mut u8) -> Self::Results {
  unsafe { let l0 = i32::from(*_ptr.add(0).cast::<u8>());

  match l0 {
    0 => {
      let e = ();
      Ok(e)
    }
    1 => {
      let e = {
        let l1 = i32::from(*_ptr.add(1).cast::<u8>());

        ErrorCode::_lift(l1 as u8)
      };
      Err(e)
    }
    _ => _rt::invalid_enum_discriminant(),
  } }
}
}
_MySubtask { _unused: core::marker::PhantomData }.call((self, data, remote_address,)).await
}
}
}
impl UdpSocket {
  #[allow(unused_unsafe, clippy::all)]
  /// Receive a message on the socket.
  ///
  /// On success, the return value contains a tuple of the received data
  /// and the address of the sender. Theoretical maximum length of the
  /// data is 64 KiB. Though in practice, it will typically be less than
  /// 1500 bytes.
  ///
  /// If the socket is connected, the sender address is guaranteed to
  /// match the remote address passed to `connect`.
  ///
  /// # Typical errors
  /// - `invalid-state`:        The socket has not been bound yet.
  /// - `remote-unreachable`:   The remote address is not reachable. (ECONNRESET, ENETRESET on Windows, EHOSTUNREACH, EHOSTDOWN, ENETUNREACH, ENETDOWN, ENONET)
  /// - `connection-refused`:   The connection was refused. (ECONNREFUSED)
  ///
  /// # References
  /// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/recvfrom.html>
  /// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/recvmsg.html>
  /// - <https://man7.org/linux/man-pages/man2/recv.2.html>
  /// - <https://man7.org/linux/man-pages/man2/recvmmsg.2.html>
  /// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-recvfrom>
  /// - <https://learn.microsoft.com/en-us/windows/win32/api/mswsock/nc-mswsock-lpfn_wsarecvmsg>
  /// - <https://man.freebsd.org/cgi/man.cgi?query=recv&sektion=2>
  #[allow(async_fn_in_trait)]
  pub async fn receive(&self,) -> Result<(_rt::Vec::<u8>,IpSocketAddress,),ErrorCode>{
    unsafe {

      #[derive(Copy, Clone)]
      struct ParamsLower(
      i32, 
      );
      unsafe impl Send for ParamsLower {}
      

      use wit_bindgen::rt::async_support::Subtask as _Subtask;
      struct _MySubtask<'a> { _unused: core::marker::PhantomData<&'a ()> }
      #[allow(unused_parens)]
      unsafe impl<'a> _Subtask for _MySubtask<'a> {
        
        type Params = (&'a UdpSocket, );
        type Results = Result<(_rt::Vec::<u8>,IpSocketAddress,),ErrorCode>;
        type ParamsLower = ParamsLower;
        fn abi_layout(&mut self) -> ::core::alloc::Layout {
          unsafe {
            ::core::alloc::Layout::from_size_align_unchecked((32+3*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>())
          }
        }
        
        fn results_offset(&mut self) -> usize { 0 }

        unsafe fn call_import(&mut self, _params: Self::ParamsLower, _results: *mut u8) -> u32 {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2026-01-06")]
          unsafe extern "C" {
            #[link_name = "[async-lower][method]udp-socket.receive"]
            fn call(_: i32, _: *mut u8, ) -> i32;
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn call(_: i32, _: *mut u8, ) -> i32 { unreachable!() }
          
          unsafe { call(_params.0,_results) as u32 }
        }
        
        unsafe fn params_dealloc_lists(&mut self, _params: Self::ParamsLower) {
          unsafe {  }
        }
        unsafe fn params_dealloc_lists_and_own(&mut self, _params: Self::ParamsLower) {
          unsafe {  }
        }
        unsafe fn params_lower(&mut self, (_lower0,): Self::Params, _ptr: *mut u8) -> Self::ParamsLower {
          unsafe {  ParamsLower((_lower0).handle() as i32,) }
        }
        unsafe fn results_lift(&mut self, _ptr: *mut u8) -> Self::Results {
          unsafe { let l0 = i32::from(*_ptr.add(0).cast::<u8>());

          match l0 {
            0 => {
              let e = {
                let l1 = *_ptr.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                let l2 = *_ptr.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>();
                let len3 = l2;
                let l4 = i32::from(*_ptr.add(3*::core::mem::size_of::<*const u8>()).cast::<u8>());
                let v21 = match l4 {
                  0 => {
                    let e21 = {
                      let l5 = i32::from(*_ptr.add(4+3*::core::mem::size_of::<*const u8>()).cast::<u16>());
                      let l6 = i32::from(*_ptr.add(6+3*::core::mem::size_of::<*const u8>()).cast::<u8>());
                      let l7 = i32::from(*_ptr.add(7+3*::core::mem::size_of::<*const u8>()).cast::<u8>());
                      let l8 = i32::from(*_ptr.add(8+3*::core::mem::size_of::<*const u8>()).cast::<u8>());
                      let l9 = i32::from(*_ptr.add(9+3*::core::mem::size_of::<*const u8>()).cast::<u8>());

                      Ipv4SocketAddress{
                        port: l5 as u16,
                        address: (l6 as u8, l7 as u8, l8 as u8, l9 as u8),
                      }
                    };
                    IpSocketAddress::Ipv4(e21)
                  }
                  n => {
                    debug_assert_eq!(n, 1, "invalid enum discriminant");
                    let e21 = {
                      let l10 = i32::from(*_ptr.add(4+3*::core::mem::size_of::<*const u8>()).cast::<u16>());
                      let l11 = *_ptr.add(8+3*::core::mem::size_of::<*const u8>()).cast::<i32>();
                      let l12 = i32::from(*_ptr.add(12+3*::core::mem::size_of::<*const u8>()).cast::<u16>());
                      let l13 = i32::from(*_ptr.add(14+3*::core::mem::size_of::<*const u8>()).cast::<u16>());
                      let l14 = i32::from(*_ptr.add(16+3*::core::mem::size_of::<*const u8>()).cast::<u16>());
                      let l15 = i32::from(*_ptr.add(18+3*::core::mem::size_of::<*const u8>()).cast::<u16>());
                      let l16 = i32::from(*_ptr.add(20+3*::core::mem::size_of::<*const u8>()).cast::<u16>());
                      let l17 = i32::from(*_ptr.add(22+3*::core::mem::size_of::<*const u8>()).cast::<u16>());
                      let l18 = i32::from(*_ptr.add(24+3*::core::mem::size_of::<*const u8>()).cast::<u16>());
                      let l19 = i32::from(*_ptr.add(26+3*::core::mem::size_of::<*const u8>()).cast::<u16>());
                      let l20 = *_ptr.add(28+3*::core::mem::size_of::<*const u8>()).cast::<i32>();

                      Ipv6SocketAddress{
                        port: l10 as u16,
                        flow_info: l11 as u32,
                        address: (l12 as u16, l13 as u16, l14 as u16, l15 as u16, l16 as u16, l17 as u16, l18 as u16, l19 as u16),
                        scope_id: l20 as u32,
                      }
                    };
                    IpSocketAddress::Ipv6(e21)
                  }
                };

                (<_ as From<_rt::Vec<_>>>::from(_rt::Vec::from_raw_parts(l1.cast(), len3, len3)), v21)
              };
              Ok(e)
            }
            1 => {
              let e = {
                let l22 = i32::from(*_ptr.add(::core::mem::size_of::<*const u8>()).cast::<u8>());

                ErrorCode::_lift(l22 as u8)
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          } }
        }
      }
      _MySubtask { _unused: core::marker::PhantomData }.call((self,)).await
    }
  }
}
impl UdpSocket {
  #[allow(unused_unsafe, clippy::all)]
  /// Get the current bound address.
  ///
  /// POSIX mentions:
  /// > If the socket has not been bound to a local name, the value
  /// > stored in the object pointed to by `address` is unspecified.
  ///
  /// WASI is stricter and requires `get-local-address` to return `invalid-state` when the socket hasn't been bound yet.
  ///
  /// # Typical errors
  /// - `invalid-state`: The socket is not bound to any local address.
  ///
  /// # References
  /// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/getsockname.html>
  /// - <https://man7.org/linux/man-pages/man2/getsockname.2.html>
  /// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-getsockname>
  /// - <https://man.freebsd.org/cgi/man.cgi?getsockname>
  #[allow(async_fn_in_trait)]
  pub async fn get_local_address(&self,) -> Result<IpSocketAddress,ErrorCode>{
    unsafe {

      #[derive(Copy, Clone)]
      struct ParamsLower(
      i32, 
      );
      unsafe impl Send for ParamsLower {}
      

      use wit_bindgen::rt::async_support::Subtask as _Subtask;
      struct _MySubtask<'a> { _unused: core::marker::PhantomData<&'a ()> }
      #[allow(unused_parens)]
      unsafe impl<'a> _Subtask for _MySubtask<'a> {
        
        type Params = (&'a UdpSocket, );
        type Results = Result<IpSocketAddress,ErrorCode>;
        type ParamsLower = ParamsLower;
        fn abi_layout(&mut self) -> ::core::alloc::Layout {
          unsafe {
            ::core::alloc::Layout::from_size_align_unchecked(36, 4)
          }
        }
        
        fn results_offset(&mut self) -> usize { 0 }

        unsafe fn call_import(&mut self, _params: Self::ParamsLower, _results: *mut u8) -> u32 {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2026-01-06")]
          unsafe extern "C" {
            #[link_name = "[async-lower][method]udp-socket.get-local-address"]
            fn call(_: i32, _: *mut u8, ) -> i32;
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn call(_: i32, _: *mut u8, ) -> i32 { unreachable!() }
          
          unsafe { call(_params.0,_results) as u32 }
        }
        
        unsafe fn params_dealloc_lists(&mut self, _params: Self::ParamsLower) {
          unsafe {  }
        }
        unsafe fn params_dealloc_lists_and_own(&mut self, _params: Self::ParamsLower) {
          unsafe {  }
        }
        unsafe fn params_lower(&mut self, (_lower0,): Self::Params, _ptr: *mut u8) -> Self::ParamsLower {
          unsafe {  ParamsLower((_lower0).handle() as i32,) }
        }
        unsafe fn results_lift(&mut self, _ptr: *mut u8) -> Self::Results {
          unsafe { let l0 = i32::from(*_ptr.add(0).cast::<u8>());

          match l0 {
            0 => {
              let e = {
                let l1 = i32::from(*_ptr.add(4).cast::<u8>());
                let v18 = match l1 {
                  0 => {
                    let e18 = {
                      let l2 = i32::from(*_ptr.add(8).cast::<u16>());
                      let l3 = i32::from(*_ptr.add(10).cast::<u8>());
                      let l4 = i32::from(*_ptr.add(11).cast::<u8>());
                      let l5 = i32::from(*_ptr.add(12).cast::<u8>());
                      let l6 = i32::from(*_ptr.add(13).cast::<u8>());

                      Ipv4SocketAddress{
                        port: l2 as u16,
                        address: (l3 as u8, l4 as u8, l5 as u8, l6 as u8),
                      }
                    };
                    IpSocketAddress::Ipv4(e18)
                  }
                  n => {
                    debug_assert_eq!(n, 1, "invalid enum discriminant");
                    let e18 = {
                      let l7 = i32::from(*_ptr.add(8).cast::<u16>());
                      let l8 = *_ptr.add(12).cast::<i32>();
                      let l9 = i32::from(*_ptr.add(16).cast::<u16>());
                      let l10 = i32::from(*_ptr.add(18).cast::<u16>());
                      let l11 = i32::from(*_ptr.add(20).cast::<u16>());
                      let l12 = i32::from(*_ptr.add(22).cast::<u16>());
                      let l13 = i32::from(*_ptr.add(24).cast::<u16>());
                      let l14 = i32::from(*_ptr.add(26).cast::<u16>());
                      let l15 = i32::from(*_ptr.add(28).cast::<u16>());
                      let l16 = i32::from(*_ptr.add(30).cast::<u16>());
                      let l17 = *_ptr.add(32).cast::<i32>();

                      Ipv6SocketAddress{
                        port: l7 as u16,
                        flow_info: l8 as u32,
                        address: (l9 as u16, l10 as u16, l11 as u16, l12 as u16, l13 as u16, l14 as u16, l15 as u16, l16 as u16),
                        scope_id: l17 as u32,
                      }
                    };
                    IpSocketAddress::Ipv6(e18)
                  }
                };

                v18
              };
              Ok(e)
            }
            1 => {
              let e = {
                let l19 = i32::from(*_ptr.add(4).cast::<u8>());

                ErrorCode::_lift(l19 as u8)
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          } }
        }
      }
      _MySubtask { _unused: core::marker::PhantomData }.call((self,)).await
    }
  }
}
impl UdpSocket {
  #[allow(unused_unsafe, clippy::all)]
  /// Get the address the socket is currently "connected" to.
  ///
  /// # Typical errors
  /// - `invalid-state`: The socket is not "connected" to a specific remote address. (ENOTCONN)
  ///
  /// # References
  /// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/getpeername.html>
  /// - <https://man7.org/linux/man-pages/man2/getpeername.2.html>
  /// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-getpeername>
  /// - <https://man.freebsd.org/cgi/man.cgi?query=getpeername&sektion=2&n=1>
  #[allow(async_fn_in_trait)]
  pub async fn get_remote_address(&self,) -> Result<IpSocketAddress,ErrorCode>{
    unsafe {

      #[derive(Copy, Clone)]
      struct ParamsLower(
      i32, 
      );
      unsafe impl Send for ParamsLower {}
      

      use wit_bindgen::rt::async_support::Subtask as _Subtask;
      struct _MySubtask<'a> { _unused: core::marker::PhantomData<&'a ()> }
      #[allow(unused_parens)]
      unsafe impl<'a> _Subtask for _MySubtask<'a> {
        
        type Params = (&'a UdpSocket, );
        type Results = Result<IpSocketAddress,ErrorCode>;
        type ParamsLower = ParamsLower;
        fn abi_layout(&mut self) -> ::core::alloc::Layout {
          unsafe {
            ::core::alloc::Layout::from_size_align_unchecked(36, 4)
          }
        }
        
        fn results_offset(&mut self) -> usize { 0 }

        unsafe fn call_import(&mut self, _params: Self::ParamsLower, _results: *mut u8) -> u32 {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2026-01-06")]
          unsafe extern "C" {
            #[link_name = "[async-lower][method]udp-socket.get-remote-address"]
            fn call(_: i32, _: *mut u8, ) -> i32;
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn call(_: i32, _: *mut u8, ) -> i32 { unreachable!() }
          
          unsafe { call(_params.0,_results) as u32 }
        }
        
        unsafe fn params_dealloc_lists(&mut self, _params: Self::ParamsLower) {
          unsafe {  }
        }
        unsafe fn params_dealloc_lists_and_own(&mut self, _params: Self::ParamsLower) {
          unsafe {  }
        }
        unsafe fn params_lower(&mut self, (_lower0,): Self::Params, _ptr: *mut u8) -> Self::ParamsLower {
          unsafe {  ParamsLower((_lower0).handle() as i32,) }
        }
        unsafe fn results_lift(&mut self, _ptr: *mut u8) -> Self::Results {
          unsafe { let l0 = i32::from(*_ptr.add(0).cast::<u8>());

          match l0 {
            0 => {
              let e = {
                let l1 = i32::from(*_ptr.add(4).cast::<u8>());
                let v18 = match l1 {
                  0 => {
                    let e18 = {
                      let l2 = i32::from(*_ptr.add(8).cast::<u16>());
                      let l3 = i32::from(*_ptr.add(10).cast::<u8>());
                      let l4 = i32::from(*_ptr.add(11).cast::<u8>());
                      let l5 = i32::from(*_ptr.add(12).cast::<u8>());
                      let l6 = i32::from(*_ptr.add(13).cast::<u8>());

                      Ipv4SocketAddress{
                        port: l2 as u16,
                        address: (l3 as u8, l4 as u8, l5 as u8, l6 as u8),
                      }
                    };
                    IpSocketAddress::Ipv4(e18)
                  }
                  n => {
                    debug_assert_eq!(n, 1, "invalid enum discriminant");
                    let e18 = {
                      let l7 = i32::from(*_ptr.add(8).cast::<u16>());
                      let l8 = *_ptr.add(12).cast::<i32>();
                      let l9 = i32::from(*_ptr.add(16).cast::<u16>());
                      let l10 = i32::from(*_ptr.add(18).cast::<u16>());
                      let l11 = i32::from(*_ptr.add(20).cast::<u16>());
                      let l12 = i32::from(*_ptr.add(22).cast::<u16>());
                      let l13 = i32::from(*_ptr.add(24).cast::<u16>());
                      let l14 = i32::from(*_ptr.add(26).cast::<u16>());
                      let l15 = i32::from(*_ptr.add(28).cast::<u16>());
                      let l16 = i32::from(*_ptr.add(30).cast::<u16>());
                      let l17 = *_ptr.add(32).cast::<i32>();

                      Ipv6SocketAddress{
                        port: l7 as u16,
                        flow_info: l8 as u32,
                        address: (l9 as u16, l10 as u16, l11 as u16, l12 as u16, l13 as u16, l14 as u16, l15 as u16, l16 as u16),
                        scope_id: l17 as u32,
                      }
                    };
                    IpSocketAddress::Ipv6(e18)
                  }
                };

                v18
              };
              Ok(e)
            }
            1 => {
              let e = {
                let l19 = i32::from(*_ptr.add(4).cast::<u8>());

                ErrorCode::_lift(l19 as u8)
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          } }
        }
      }
      _MySubtask { _unused: core::marker::PhantomData }.call((self,)).await
    }
  }
}
impl UdpSocket {
  #[allow(unused_unsafe, clippy::all)]
  /// Whether this is a IPv4 or IPv6 socket.
  ///
  /// This is the value passed to the constructor.
  ///
  /// Equivalent to the SO_DOMAIN socket option.
  #[allow(async_fn_in_trait)]
  pub async fn get_address_family(&self,) -> IpAddressFamily{
    unsafe {

      #[derive(Copy, Clone)]
      struct ParamsLower(
      i32, 
      );
      unsafe impl Send for ParamsLower {}
      

      use wit_bindgen::rt::async_support::Subtask as _Subtask;
      struct _MySubtask<'a> { _unused: core::marker::PhantomData<&'a ()> }
      #[allow(unused_parens)]
      unsafe impl<'a> _Subtask for _MySubtask<'a> {
        
        type Params = (&'a UdpSocket, );
        type Results = IpAddressFamily;
        type ParamsLower = ParamsLower;
        fn abi_layout(&mut self) -> ::core::alloc::Layout {
          unsafe {
            ::core::alloc::Layout::from_size_align_unchecked(1, 1)
          }
        }
        
        fn results_offset(&mut self) -> usize { 0 }

        unsafe fn call_import(&mut self, _params: Self::ParamsLower, _results: *mut u8) -> u32 {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2026-01-06")]
          unsafe extern "C" {
            #[link_name = "[async-lower][method]udp-socket.get-address-family"]
            fn call(_: i32, _: *mut u8, ) -> i32;
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn call(_: i32, _: *mut u8, ) -> i32 { unreachable!() }
          
          unsafe { call(_params.0,_results) as u32 }
        }
        
        unsafe fn params_dealloc_lists(&mut self, _params: Self::ParamsLower) {
          unsafe {  }
        }
        unsafe fn params_dealloc_lists_and_own(&mut self, _params: Self::ParamsLower) {
          unsafe {  }
        }
        unsafe fn params_lower(&mut self, (_lower0,): Self::Params, _ptr: *mut u8) -> Self::ParamsLower {
          unsafe {  ParamsLower((_lower0).handle() as i32,) }
        }
        unsafe fn results_lift(&mut self, _ptr: *mut u8) -> Self::Results {
          unsafe { let l0 = i32::from(*_ptr.add(0).cast::<u8>());

          IpAddressFamily::_lift(l0 as u8) }
        }
      }
      _MySubtask { _unused: core::marker::PhantomData }.call((self,)).await
    }
  }
}
impl UdpSocket {
  #[allow(unused_unsafe, clippy::all)]
  /// Equivalent to the IP_TTL & IPV6_UNICAST_HOPS socket options.
  ///
  /// If the provided value is 0, an `invalid-argument` error is returned.
  ///
  /// # Typical errors
  /// - `invalid-argument`:     (set) The TTL value must be 1 or higher.
  #[allow(async_fn_in_trait)]
  pub async fn get_unicast_hop_limit(&self,) -> Result<u8,ErrorCode>{
    unsafe {

      #[derive(Copy, Clone)]
      struct ParamsLower(
      i32, 
      );
      unsafe impl Send for ParamsLower {}
      

      use wit_bindgen::rt::async_support::Subtask as _Subtask;
      struct _MySubtask<'a> { _unused: core::marker::PhantomData<&'a ()> }
      #[allow(unused_parens)]
      unsafe impl<'a> _Subtask for _MySubtask<'a> {
        
        type Params = (&'a UdpSocket, );
        type Results = Result<u8,ErrorCode>;
        type ParamsLower = ParamsLower;
        fn abi_layout(&mut self) -> ::core::alloc::Layout {
          unsafe {
            ::core::alloc::Layout::from_size_align_unchecked(2, 1)
          }
        }
        
        fn results_offset(&mut self) -> usize { 0 }

        unsafe fn call_import(&mut self, _params: Self::ParamsLower, _results: *mut u8) -> u32 {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2026-01-06")]
          unsafe extern "C" {
            #[link_name = "[async-lower][method]udp-socket.get-unicast-hop-limit"]
            fn call(_: i32, _: *mut u8, ) -> i32;
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn call(_: i32, _: *mut u8, ) -> i32 { unreachable!() }
          
          unsafe { call(_params.0,_results) as u32 }
        }
        
        unsafe fn params_dealloc_lists(&mut self, _params: Self::ParamsLower) {
          unsafe {  }
        }
        unsafe fn params_dealloc_lists_and_own(&mut self, _params: Self::ParamsLower) {
          unsafe {  }
        }
        unsafe fn params_lower(&mut self, (_lower0,): Self::Params, _ptr: *mut u8) -> Self::ParamsLower {
          unsafe {  ParamsLower((_lower0).handle() as i32,) }
        }
        unsafe fn results_lift(&mut self, _ptr: *mut u8) -> Self::Results {
          unsafe { let l0 = i32::from(*_ptr.add(0).cast::<u8>());

          match l0 {
            0 => {
              let e = {
                let l1 = i32::from(*_ptr.add(1).cast::<u8>());

                l1 as u8
              };
              Ok(e)
            }
            1 => {
              let e = {
                let l2 = i32::from(*_ptr.add(1).cast::<u8>());

                ErrorCode::_lift(l2 as u8)
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          } }
        }
      }
      _MySubtask { _unused: core::marker::PhantomData }.call((self,)).await
    }
  }
}
impl UdpSocket {
  #[allow(unused_unsafe, clippy::all)]
  #[allow(async_fn_in_trait)]
  pub async fn set_unicast_hop_limit(&self,value: u8,) -> Result<(),ErrorCode>{
    unsafe {

      #[derive(Copy, Clone)]
      struct ParamsLower(
      i32, i32, 
      );
      unsafe impl Send for ParamsLower {}
      

      use wit_bindgen::rt::async_support::Subtask as _Subtask;
      struct _MySubtask<'a> { _unused: core::marker::PhantomData<&'a ()> }
      #[allow(unused_parens)]
      unsafe impl<'a> _Subtask for _MySubtask<'a> {
        
        type Params = (&'a UdpSocket, u8, );
        type Results = Result<(),ErrorCode>;
        type ParamsLower = ParamsLower;
        fn abi_layout(&mut self) -> ::core::alloc::Layout {
          unsafe {
            ::core::alloc::Layout::from_size_align_unchecked(2, 1)
          }
        }
        
        fn results_offset(&mut self) -> usize { 0 }

        unsafe fn call_import(&mut self, _params: Self::ParamsLower, _results: *mut u8) -> u32 {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2026-01-06")]
          unsafe extern "C" {
            #[link_name = "[async-lower][method]udp-socket.set-unicast-hop-limit"]
            fn call(_: i32, _: i32, _: *mut u8, ) -> i32;
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn call(_: i32, _: i32, _: *mut u8, ) -> i32 { unreachable!() }
          
          unsafe { call(_params.0,_params.1,_results) as u32 }
        }
        
        unsafe fn params_dealloc_lists(&mut self, _params: Self::ParamsLower) {
          unsafe {  }
        }
        unsafe fn params_dealloc_lists_and_own(&mut self, _params: Self::ParamsLower) {
          unsafe {  }
        }
        unsafe fn params_lower(&mut self, (_lower0, _lower1,): Self::Params, _ptr: *mut u8) -> Self::ParamsLower {
          unsafe {  ParamsLower((_lower0).handle() as i32, _rt::as_i32(_lower1),) }
        }
        unsafe fn results_lift(&mut self, _ptr: *mut u8) -> Self::Results {
          unsafe { let l0 = i32::from(*_ptr.add(0).cast::<u8>());

          match l0 {
            0 => {
              let e = ();
              Ok(e)
            }
            1 => {
              let e = {
                let l1 = i32::from(*_ptr.add(1).cast::<u8>());

                ErrorCode::_lift(l1 as u8)
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          } }
        }
      }
      _MySubtask { _unused: core::marker::PhantomData }.call((self, value,)).await
    }
  }
}
impl UdpSocket {
  #[allow(unused_unsafe, clippy::all)]
  /// The kernel buffer space reserved for sends/receives on this socket.
  ///
  /// If the provided value is 0, an `invalid-argument` error is returned.
  /// Any other value will never cause an error, but it might be silently clamped and/or rounded.
  /// I.e. after setting a value, reading the same setting back may return a different value.
  ///
  /// Equivalent to the SO_RCVBUF and SO_SNDBUF socket options.
  ///
  /// # Typical errors
  /// - `invalid-argument`:     (set) The provided value was 0.
  #[allow(async_fn_in_trait)]
  pub async fn get_receive_buffer_size(&self,) -> Result<u64,ErrorCode>{
    unsafe {

      #[derive(Copy, Clone)]
      struct ParamsLower(
      i32, 
      );
      unsafe impl Send for ParamsLower {}
      

      use wit_bindgen::rt::async_support::Subtask as _Subtask;
      struct _MySubtask<'a> { _unused: core::marker::PhantomData<&'a ()> }
      #[allow(unused_parens)]
      unsafe impl<'a> _Subtask for _MySubtask<'a> {
        
        type Params = (&'a UdpSocket, );
        type Results = Result<u64,ErrorCode>;
        type ParamsLower = ParamsLower;
        fn abi_layout(&mut self) -> ::core::alloc::Layout {
          unsafe {
            ::core::alloc::Layout::from_size_align_unchecked(16, 8)
          }
        }
        
        fn results_offset(&mut self) -> usize { 0 }

        unsafe fn call_import(&mut self, _params: Self::ParamsLower, _results: *mut u8) -> u32 {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2026-01-06")]
          unsafe extern "C" {
            #[link_name = "[async-lower][method]udp-socket.get-receive-buffer-size"]
            fn call(_: i32, _: *mut u8, ) -> i32;
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn call(_: i32, _: *mut u8, ) -> i32 { unreachable!() }
          
          unsafe { call(_params.0,_results) as u32 }
        }
        
        unsafe fn params_dealloc_lists(&mut self, _params: Self::ParamsLower) {
          unsafe {  }
        }
        unsafe fn params_dealloc_lists_and_own(&mut self, _params: Self::ParamsLower) {
          unsafe {  }
        }
        unsafe fn params_lower(&mut self, (_lower0,): Self::Params, _ptr: *mut u8) -> Self::ParamsLower {
          unsafe {  ParamsLower((_lower0).handle() as i32,) }
        }
        unsafe fn results_lift(&mut self, _ptr: *mut u8) -> Self::Results {
          unsafe { let l0 = i32::from(*_ptr.add(0).cast::<u8>());

          match l0 {
            0 => {
              let e = {
                let l1 = *_ptr.add(8).cast::<i64>();

                l1 as u64
              };
              Ok(e)
            }
            1 => {
              let e = {
                let l2 = i32::from(*_ptr.add(8).cast::<u8>());

                ErrorCode::_lift(l2 as u8)
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          } }
        }
      }
      _MySubtask { _unused: core::marker::PhantomData }.call((self,)).await
    }
  }
}
impl UdpSocket {
  #[allow(unused_unsafe, clippy::all)]
  #[allow(async_fn_in_trait)]
  pub async fn set_receive_buffer_size(&self,value: u64,) -> Result<(),ErrorCode>{
    unsafe {

      #[derive(Copy, Clone)]
      struct ParamsLower(
      i32, i64, 
      );
      unsafe impl Send for ParamsLower {}
      

      use wit_bindgen::rt::async_support::Subtask as _Subtask;
      struct _MySubtask<'a> { _unused: core::marker::PhantomData<&'a ()> }
      #[allow(unused_parens)]
      unsafe impl<'a> _Subtask for _MySubtask<'a> {
        
        type Params = (&'a UdpSocket, u64, );
        type Results = Result<(),ErrorCode>;
        type ParamsLower = ParamsLower;
        fn abi_layout(&mut self) -> ::core::alloc::Layout {
          unsafe {
            ::core::alloc::Layout::from_size_align_unchecked(2, 1)
          }
        }
        
        fn results_offset(&mut self) -> usize { 0 }

        unsafe fn call_import(&mut self, _params: Self::ParamsLower, _results: *mut u8) -> u32 {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2026-01-06")]
          unsafe extern "C" {
            #[link_name = "[async-lower][method]udp-socket.set-receive-buffer-size"]
            fn call(_: i32, _: i64, _: *mut u8, ) -> i32;
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn call(_: i32, _: i64, _: *mut u8, ) -> i32 { unreachable!() }
          
          unsafe { call(_params.0,_params.1,_results) as u32 }
        }
        
        unsafe fn params_dealloc_lists(&mut self, _params: Self::ParamsLower) {
          unsafe {  }
        }
        unsafe fn params_dealloc_lists_and_own(&mut self, _params: Self::ParamsLower) {
          unsafe {  }
        }
        unsafe fn params_lower(&mut self, (_lower0, _lower1,): Self::Params, _ptr: *mut u8) -> Self::ParamsLower {
          unsafe {  ParamsLower((_lower0).handle() as i32, _rt::as_i64(_lower1),) }
        }
        unsafe fn results_lift(&mut self, _ptr: *mut u8) -> Self::Results {
          unsafe { let l0 = i32::from(*_ptr.add(0).cast::<u8>());

          match l0 {
            0 => {
              let e = ();
              Ok(e)
            }
            1 => {
              let e = {
                let l1 = i32::from(*_ptr.add(1).cast::<u8>());

                ErrorCode::_lift(l1 as u8)
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          } }
        }
      }
      _MySubtask { _unused: core::marker::PhantomData }.call((self, value,)).await
    }
  }
}
impl UdpSocket {
  #[allow(unused_unsafe, clippy::all)]
  #[allow(async_fn_in_trait)]
  pub async fn get_send_buffer_size(&self,) -> Result<u64,ErrorCode>{
    unsafe {

      #[derive(Copy, Clone)]
      struct ParamsLower(
      i32, 
      );
      unsafe impl Send for ParamsLower {}
      

      use wit_bindgen::rt::async_support::Subtask as _Subtask;
      struct _MySubtask<'a> { _unused: core::marker::PhantomData<&'a ()> }
      #[allow(unused_parens)]
      unsafe impl<'a> _Subtask for _MySubtask<'a> {
        
        type Params = (&'a UdpSocket, );
        type Results = Result<u64,ErrorCode>;
        type ParamsLower = ParamsLower;
        fn abi_layout(&mut self) -> ::core::alloc::Layout {
          unsafe {
            ::core::alloc::Layout::from_size_align_unchecked(16, 8)
          }
        }
        
        fn results_offset(&mut self) -> usize { 0 }

        unsafe fn call_import(&mut self, _params: Self::ParamsLower, _results: *mut u8) -> u32 {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2026-01-06")]
          unsafe extern "C" {
            #[link_name = "[async-lower][method]udp-socket.get-send-buffer-size"]
            fn call(_: i32, _: *mut u8, ) -> i32;
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn call(_: i32, _: *mut u8, ) -> i32 { unreachable!() }
          
          unsafe { call(_params.0,_results) as u32 }
        }
        
        unsafe fn params_dealloc_lists(&mut self, _params: Self::ParamsLower) {
          unsafe {  }
        }
        unsafe fn params_dealloc_lists_and_own(&mut self, _params: Self::ParamsLower) {
          unsafe {  }
        }
        unsafe fn params_lower(&mut self, (_lower0,): Self::Params, _ptr: *mut u8) -> Self::ParamsLower {
          unsafe {  ParamsLower((_lower0).handle() as i32,) }
        }
        unsafe fn results_lift(&mut self, _ptr: *mut u8) -> Self::Results {
          unsafe { let l0 = i32::from(*_ptr.add(0).cast::<u8>());

          match l0 {
            0 => {
              let e = {
                let l1 = *_ptr.add(8).cast::<i64>();

                l1 as u64
              };
              Ok(e)
            }
            1 => {
              let e = {
                let l2 = i32::from(*_ptr.add(8).cast::<u8>());

                ErrorCode::_lift(l2 as u8)
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          } }
        }
      }
      _MySubtask { _unused: core::marker::PhantomData }.call((self,)).await
    }
  }
}
impl UdpSocket {
  #[allow(unused_unsafe, clippy::all)]
  #[allow(async_fn_in_trait)]
  pub async fn set_send_buffer_size(&self,value: u64,) -> Result<(),ErrorCode>{
    unsafe {

      #[derive(Copy, Clone)]
      struct ParamsLower(
      i32, i64, 
      );
      unsafe impl Send for ParamsLower {}
      

      use wit_bindgen::rt::async_support::Subtask as _Subtask;
      struct _MySubtask<'a> { _unused: core::marker::PhantomData<&'a ()> }
      #[allow(unused_parens)]
      unsafe impl<'a> _Subtask for _MySubtask<'a> {
        
        type Params = (&'a UdpSocket, u64, );
        type Results = Result<(),ErrorCode>;
        type ParamsLower = ParamsLower;
        fn abi_layout(&mut self) -> ::core::alloc::Layout {
          unsafe {
            ::core::alloc::Layout::from_size_align_unchecked(2, 1)
          }
        }
        
        fn results_offset(&mut self) -> usize { 0 }

        unsafe fn call_import(&mut self, _params: Self::ParamsLower, _results: *mut u8) -> u32 {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2026-01-06")]
          unsafe extern "C" {
            #[link_name = "[async-lower][method]udp-socket.set-send-buffer-size"]
            fn call(_: i32, _: i64, _: *mut u8, ) -> i32;
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn call(_: i32, _: i64, _: *mut u8, ) -> i32 { unreachable!() }
          
          unsafe { call(_params.0,_params.1,_results) as u32 }
        }
        
        unsafe fn params_dealloc_lists(&mut self, _params: Self::ParamsLower) {
          unsafe {  }
        }
        unsafe fn params_dealloc_lists_and_own(&mut self, _params: Self::ParamsLower) {
          unsafe {  }
        }
        unsafe fn params_lower(&mut self, (_lower0, _lower1,): Self::Params, _ptr: *mut u8) -> Self::ParamsLower {
          unsafe {  ParamsLower((_lower0).handle() as i32, _rt::as_i64(_lower1),) }
        }
        unsafe fn results_lift(&mut self, _ptr: *mut u8) -> Self::Results {
          unsafe { let l0 = i32::from(*_ptr.add(0).cast::<u8>());

          match l0 {
            0 => {
              let e = ();
              Ok(e)
            }
            1 => {
              let e = {
                let l1 = i32::from(*_ptr.add(1).cast::<u8>());

                ErrorCode::_lift(l1 as u8)
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          } }
        }
      }
      _MySubtask { _unused: core::marker::PhantomData }.call((self, value,)).await
    }
  }
}

}


#[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
pub mod ip_name_lookup {
  #[used]
  #[doc(hidden)]
  static __FORCE_SECTION_REF: fn() =
  super::super::super::__link_custom_section_describing_imports;
  
  use super::super::super::_rt;
  pub type IpAddress = super::super::super::wasi::sockets::types::IpAddress;
  /// Lookup error codes.
  #[repr(u8)]
  #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd, serde::Deserialize, serde::Serialize)]
  pub enum ErrorCode {
    /// Unknown error
    Unknown,
    /// Access denied.
    ///
    /// POSIX equivalent: EACCES, EPERM
    AccessDenied,
    /// `name` is a syntactically invalid domain name or IP address.
    ///
    /// POSIX equivalent: EINVAL
    InvalidArgument,
    /// Name does not exist or has no suitable associated IP addresses.
    ///
    /// POSIX equivalent: EAI_NONAME, EAI_NODATA, EAI_ADDRFAMILY
    NameUnresolvable,
    /// A temporary failure in name resolution occurred.
    ///
    /// POSIX equivalent: EAI_AGAIN
    TemporaryResolverFailure,
    /// A permanent failure in name resolution occurred.
    ///
    /// POSIX equivalent: EAI_FAIL
    PermanentResolverFailure,
  }
  impl ErrorCode{
    pub fn name(&self) -> &'static str {
      match self {
        ErrorCode::Unknown => "unknown",
        ErrorCode::AccessDenied => "access-denied",
        ErrorCode::InvalidArgument => "invalid-argument",
        ErrorCode::NameUnresolvable => "name-unresolvable",
        ErrorCode::TemporaryResolverFailure => "temporary-resolver-failure",
        ErrorCode::PermanentResolverFailure => "permanent-resolver-failure",
      }
    }
    pub fn message(&self) -> &'static str {
      match self {
        ErrorCode::Unknown => "Unknown error",
        ErrorCode::AccessDenied => "Access denied.

        POSIX equivalent: EACCES, EPERM",
        ErrorCode::InvalidArgument => "`name` is a syntactically invalid domain name or IP address.

        POSIX equivalent: EINVAL",
        ErrorCode::NameUnresolvable => "Name does not exist or has no suitable associated IP addresses.

        POSIX equivalent: EAI_NONAME, EAI_NODATA, EAI_ADDRFAMILY",
        ErrorCode::TemporaryResolverFailure => "A temporary failure in name resolution occurred.

        POSIX equivalent: EAI_AGAIN",
        ErrorCode::PermanentResolverFailure => "A permanent failure in name resolution occurred.

        POSIX equivalent: EAI_FAIL",
      }
    }
  }
  impl ::core::fmt::Debug for ErrorCode{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
      f.debug_struct("ErrorCode")
      .field("code", &(*self as i32))
      .field("name", &self.name())
      .field("message", &self.message())
      .finish()
    }
  }
  impl ::core::fmt::Display for ErrorCode{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
      write!(f, "{} (error {})", self.name(), *self as i32)
    }
  }

  impl ::core::error::Error for ErrorCode {}

  impl ErrorCode{
    #[doc(hidden)]
    pub unsafe fn _lift(val: u8) -> ErrorCode{
      if !cfg!(debug_assertions) {
        return unsafe { ::core::mem::transmute(val) };
      }

      match val {
        0 => ErrorCode::Unknown,
        1 => ErrorCode::AccessDenied,
        2 => ErrorCode::InvalidArgument,
        3 => ErrorCode::NameUnresolvable,
        4 => ErrorCode::TemporaryResolverFailure,
        5 => ErrorCode::PermanentResolverFailure,

        _ => panic!("invalid enum discriminant"),
      }
    }
  }

  #[allow(unused_unsafe, clippy::all)]
  /// Resolve an internet host name to a list of IP addresses.
  ///
  /// Unicode domain names are automatically converted to ASCII using IDNA encoding.
  /// If the input is an IP address string, the address is parsed and returned
  /// as-is without making any external requests.
  ///
  /// See the wasi-socket proposal README.md for a comparison with getaddrinfo.
  ///
  /// The results are returned in connection order preference.
  ///
  /// This function never succeeds with 0 results. It either fails or succeeds
  /// with at least one address. Additionally, this function never returns
  /// IPv4-mapped IPv6 addresses.
  ///
  /// The returned future will resolve to an error code in case of failure.
  /// It will resolve to success once the returned stream is exhausted.
  ///
  /// # References:
  /// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/getaddrinfo.html>
  /// - <https://man7.org/linux/man-pages/man3/getaddrinfo.3.html>
  /// - <https://learn.microsoft.com/en-us/windows/win32/api/ws2tcpip/nf-ws2tcpip-getaddrinfo>
  /// - <https://man.freebsd.org/cgi/man.cgi?query=getaddrinfo&sektion=3>
  #[allow(async_fn_in_trait)]
  pub async fn resolve_addresses(name: _rt::String,) -> Result<_rt::Vec::<IpAddress>,ErrorCode>{
    unsafe {

      #[derive(Copy, Clone)]
      struct ParamsLower(
      *mut u8, usize, 
      );
      unsafe impl Send for ParamsLower {}
      

      use wit_bindgen::rt::async_support::Subtask as _Subtask;
      struct _MySubtask<'a> { _unused: core::marker::PhantomData<&'a ()> }
      #[allow(unused_parens)]
      unsafe impl<'a> _Subtask for _MySubtask<'a> {
        
        type Params = (_rt::String, );
        type Results = Result<_rt::Vec::<IpAddress>,ErrorCode>;
        type ParamsLower = ParamsLower;
        fn abi_layout(&mut self) -> ::core::alloc::Layout {
          unsafe {
            ::core::alloc::Layout::from_size_align_unchecked((3*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>())
          }
        }
        
        fn results_offset(&mut self) -> usize { 0 }

        unsafe fn call_import(&mut self, _params: Self::ParamsLower, _results: *mut u8) -> u32 {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:sockets/ip-name-lookup@0.3.0-rc-2026-01-06")]
          unsafe extern "C" {
            #[link_name = "[async-lower]resolve-addresses"]
            fn call(_: *mut u8, _: usize, _: *mut u8, ) -> i32;
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn call(_: *mut u8, _: usize, _: *mut u8, ) -> i32 { unreachable!() }
          
          unsafe { call(_params.0,_params.1,_results) as u32 }
        }
        
        unsafe fn params_dealloc_lists(&mut self, _params: Self::ParamsLower) {
          unsafe { _rt::cabi_dealloc(_params.0, _params.1, 1);
        }
      }
      unsafe fn params_dealloc_lists_and_own(&mut self, _params: Self::ParamsLower) {
        unsafe { _rt::cabi_dealloc(_params.0, _params.1, 1);
      }
    }
    unsafe fn params_lower(&mut self, (_lower0,): Self::Params, _ptr: *mut u8) -> Self::ParamsLower {
      unsafe { let vec0 = (_lower0.into_bytes()).into_boxed_slice();
      let ptr0 = vec0.as_ptr().cast::<u8>();
      let len0 = vec0.len();
      ::core::mem::forget(vec0);
      ParamsLower(ptr0.cast_mut(), len0,) }
    }
    unsafe fn results_lift(&mut self, _ptr: *mut u8) -> Self::Results {
      unsafe { let l0 = i32::from(*_ptr.add(0).cast::<u8>());

      match l0 {
        0 => {
          let e = {
            let l1 = *_ptr.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
            let l2 = *_ptr.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>();
            let base17 = l1;
            let len17 = l2;
            let mut result17 = _rt::Vec::with_capacity(len17);
            for i in 0..len17 {
              let base = base17.add(i * 18);
              let e17 = {
                let l3 = i32::from(*base.add(0).cast::<u8>());
                use super::super::super::wasi::sockets::types::IpAddress as V16;
                let v16 = match l3 {
                  0 => {
                    let e16 = {
                      let l4 = i32::from(*base.add(2).cast::<u8>());
                      let l5 = i32::from(*base.add(3).cast::<u8>());
                      let l6 = i32::from(*base.add(4).cast::<u8>());
                      let l7 = i32::from(*base.add(5).cast::<u8>());

                      (l4 as u8, l5 as u8, l6 as u8, l7 as u8)
                    };
                    V16::Ipv4(e16)
                  }
                  n => {
                    debug_assert_eq!(n, 1, "invalid enum discriminant");
                    let e16 = {
                      let l8 = i32::from(*base.add(2).cast::<u16>());
                      let l9 = i32::from(*base.add(4).cast::<u16>());
                      let l10 = i32::from(*base.add(6).cast::<u16>());
                      let l11 = i32::from(*base.add(8).cast::<u16>());
                      let l12 = i32::from(*base.add(10).cast::<u16>());
                      let l13 = i32::from(*base.add(12).cast::<u16>());
                      let l14 = i32::from(*base.add(14).cast::<u16>());
                      let l15 = i32::from(*base.add(16).cast::<u16>());

                      (l8 as u16, l9 as u16, l10 as u16, l11 as u16, l12 as u16, l13 as u16, l14 as u16, l15 as u16)
                    };
                    V16::Ipv6(e16)
                  }
                };

                v16
              };
              result17.push(e17);
            }
            _rt::cabi_dealloc(base17, len17 * 18, 2);

            result17
          };
          Ok(e)
        }
        1 => {
          let e = {
            let l18 = i32::from(*_ptr.add(::core::mem::size_of::<*const u8>()).cast::<u8>());

            ErrorCode::_lift(l18 as u8)
          };
          Err(e)
        }
        _ => _rt::invalid_enum_discriminant(),
      } }
    }
  }
  _MySubtask { _unused: core::marker::PhantomData }.call((name,)).await
}
}

}

}
}
#[allow(dead_code, clippy::all)]
pub mod exports {
  pub mod igloo {
    pub mod lib {

      #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
      pub mod core_to_extension_sp {
        #[used]
        #[doc(hidden)]
        static __FORCE_SECTION_REF: fn() =
        super::super::super::super::__link_custom_section_describing_imports;
        
        use super::super::super::super::_rt;
        pub type DeviceId = super::super::super::super::__with_name0::DeviceId;
        pub type EntityIndex = super::super::super::super::__with_name0::EntityIndex;
        pub type Component = super::super::super::super::__with_name2::Component;
        #[doc(hidden)]
        #[allow(non_snake_case, unused_unsafe)]
        pub unsafe fn _export_put_component_cabi<T: Guest>(arg0: i64,arg1: i64,arg2: i32,arg3: ::core::mem::MaybeUninit::<u64>,arg4: i64,arg5: i64,) -> i32 { unsafe {#[cfg(target_arch="wasm32")]
        _rt::run_ctors_once();wit_bindgen::rt::async_support::start_task(async move {
          let _task_cancel = wit_bindgen::rt::async_support::TaskCancelOnDrop::new();
          let result15 = &{
            use super::super::super::super::__with_name2::Component as V14;
            let v14 = match arg2 {
              0 => {
                let e14 = arg3.assume_init() as i64;
                V14::Integer(e14)
              }
              1 => {
                let e14 = f64::from_bits(arg3.assume_init() as i64 as u64);
                V14::Float(e14)
              }
              2 => {
                let e14 = {
                  let len0 = arg4 as usize;
                  let bytes0 = _rt::Vec::from_raw_parts(arg3.as_ptr().cast::<*mut u8>().read().cast(), len0, len0);

                  _rt::string_lift(bytes0)
                };
                V14::String(e14)
              }
              3 => {
                let e14 = _rt::bool_lift(arg3.assume_init() as i64 as i32 as u8);
                V14::Bool(e14)
              }
              4 => {
                let e14 = super::super::super::super::__with_name1::IglooColor{
                  r: f64::from_bits(arg3.assume_init() as i64 as u64),
                  g: f64::from_bits(arg4 as u64),
                  b: f64::from_bits(arg5 as u64),
                };
                V14::Color(e14)
              }
              5 => {
                let e14 = super::super::super::super::__with_name1::IglooDate{
                  year: arg3.assume_init() as i64 as i32 as u16,
                  month: arg4 as i32 as u8,
                  day: arg5 as i32 as u8,
                };
                V14::Date(e14)
              }
              6 => {
                let e14 = super::super::super::super::__with_name1::IglooTime{
                  hour: arg3.assume_init() as i64 as i32 as u8,
                  minute: arg4 as i32 as u8,
                  second: arg5 as i32 as u8,
                };
                V14::Time(e14)
              }
              7 => {
                let e14 = {
                  let len1 = arg4 as usize;

                  <_ as From<_rt::Vec<_>>>::from(_rt::Vec::from_raw_parts(arg3.as_ptr().cast::<*mut u8>().read().cast(), len1, len1))
                };
                V14::IntegerList(e14)
              }
              8 => {
                let e14 = {
                  let len2 = arg4 as usize;

                  <_ as From<_rt::Vec<_>>>::from(_rt::Vec::from_raw_parts(arg3.as_ptr().cast::<*mut u8>().read().cast(), len2, len2))
                };
                V14::FloatList(e14)
              }
              9 => {
                let e14 = {
                  let base6 = arg3.as_ptr().cast::<*mut u8>().read();
                  let len6 = arg4 as usize;
                  let mut result6 = _rt::Vec::with_capacity(len6);
                  for i in 0..len6 {
                    let base = base6.add(i * (2*::core::mem::size_of::<*const u8>()));
                    let e6 = {
                      let l3 = *base.add(0).cast::<*mut u8>();
                      let l4 = *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
                      let len5 = l4;
                      let bytes5 = _rt::Vec::from_raw_parts(l3.cast(), len5, len5);

                      _rt::string_lift(bytes5)
                    };
                    result6.push(e6);
                  }
                  _rt::cabi_dealloc(base6, len6 * (2*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>());

                  result6
                };
                V14::StringList(e14)
              }
              10 => {
                let e14 = {
                  let base8 = arg3.as_ptr().cast::<*mut u8>().read();
                  let len8 = arg4 as usize;
                  let mut result8 = _rt::Vec::with_capacity(len8);
                  for i in 0..len8 {
                    let base = base8.add(i * 1);
                    let e8 = {
                      let l7 = i32::from(*base.add(0).cast::<u8>());

                      _rt::bool_lift(l7 as u8)
                    };
                    result8.push(e8);
                  }
                  _rt::cabi_dealloc(base8, len8 * 1, 1);

                  result8
                };
                V14::BooleanList(e14)
              }
              11 => {
                let e14 = {
                  let len9 = arg4 as usize;

                  <_ as From<_rt::Vec<_>>>::from(_rt::Vec::from_raw_parts(arg3.as_ptr().cast::<*mut u8>().read().cast(), len9, len9))
                };
                V14::ColorList(e14)
              }
              12 => {
                let e14 = {
                  let len10 = arg4 as usize;

                  <_ as From<_rt::Vec<_>>>::from(_rt::Vec::from_raw_parts(arg3.as_ptr().cast::<*mut u8>().read().cast(), len10, len10))
                };
                V14::DateList(e14)
              }
              13 => {
                let e14 = {
                  let len11 = arg4 as usize;

                  <_ as From<_rt::Vec<_>>>::from(_rt::Vec::from_raw_parts(arg3.as_ptr().cast::<*mut u8>().read().cast(), len11, len11))
                };
                V14::TimeList(e14)
              }
              14 => {
                V14::Trigger
              }
              15 => {
                let e14 = arg3.assume_init() as i64;
                V14::Timestamp(e14)
              }
              16 => {
                let e14 = arg3.assume_init() as i64;
                V14::Duration(e14)
              }
              17 => {
                let e14 = super::super::super::super::__with_name2::Weekday::_lift(arg3.assume_init() as i64 as i32 as u8);
                V14::Weekday(e14)
              }
              18 => {
                V14::Light
              }
              19 => {
                let e14 = _rt::bool_lift(arg3.assume_init() as i64 as i32 as u8);
                V14::Switch(e14)
              }
              20 => {
                let e14 = f64::from_bits(arg3.assume_init() as i64 as u64);
                V14::Dimmer(e14)
              }
              21 => {
                let e14 = _rt::bool_lift(arg3.assume_init() as i64 as i32 as u8);
                V14::Switch(e14)
              }
              22 => {
                let e14 = super::super::super::super::__with_name2::ColorMode::_lift(arg3.assume_init() as i64 as i32 as u8);
                V14::ColorMode(e14)
              }
              23 => {
                let e14 = arg3.assume_init() as i64;
                V14::ColorTemperature(e14)
              }
              24 => {
                let e14 = f64::from_bits(arg3.assume_init() as i64 as u64);
                V14::Volume(e14)
              }
              25 => {
                let e14 = _rt::bool_lift(arg3.assume_init() as i64 as i32 as u8);
                V14::Muted(e14)
              }
              26 => {
                V14::Config
              }
              27 => {
                V14::Diagnostic
              }
              28 => {
                V14::Siren
              }
              29 => {
                V14::Sensor
              }
              30 => {
                let e14 = {
                  let len12 = arg4 as usize;
                  let bytes12 = _rt::Vec::from_raw_parts(arg3.as_ptr().cast::<*mut u8>().read().cast(), len12, len12);

                  _rt::string_lift(bytes12)
                };
                V14::Icon(e14)
              }
              31 => {
                let e14 = arg3.assume_init() as i64;
                V14::AccuracyDecimals(e14)
              }
              32 => {
                let e14 = {
                  let len13 = arg4 as usize;
                  let bytes13 = _rt::Vec::from_raw_parts(arg3.as_ptr().cast::<*mut u8>().read().cast(), len13, len13);

                  _rt::string_lift(bytes13)
                };
                V14::DeviceClass(e14)
              }
              33 => {
                let e14 = super::super::super::super::__with_name2::SensorStateClass::_lift(arg3.assume_init() as i64 as i32 as u8);
                V14::SensorStateClass(e14)
              }
              34 => {
                let e14 = super::super::super::super::__with_name2::UnitApparentPower::_lift(arg3.assume_init() as i64 as i32 as u8);
                V14::UnitApparentPower(e14)
              }
              35 => {
                let e14 = super::super::super::super::__with_name2::UnitPower::_lift(arg3.assume_init() as i64 as i32 as u8);
                V14::UnitPower(e14)
              }
              36 => {
                let e14 = super::super::super::super::__with_name2::UnitReactivePower::_lift(arg3.assume_init() as i64 as i32 as u8);
                V14::UnitReactivePower(e14)
              }
              37 => {
                let e14 = super::super::super::super::__with_name2::UnitEnergy::_lift(arg3.assume_init() as i64 as i32 as u8);
                V14::UnitEnergy(e14)
              }
              38 => {
                let e14 = super::super::super::super::__with_name2::UnitElectricCurrent::_lift(arg3.assume_init() as i64 as i32 as u8);
                V14::UnitElectricCurrent(e14)
              }
              39 => {
                let e14 = super::super::super::super::__with_name2::UnitElectricPotential::_lift(arg3.assume_init() as i64 as i32 as u8);
                V14::UnitElectricPotential(e14)
              }
              40 => {
                let e14 = super::super::super::super::__with_name2::UnitDegree::_lift(arg3.assume_init() as i64 as i32 as u8);
                V14::UnitDegree(e14)
              }
              41 => {
                let e14 = super::super::super::super::__with_name2::UnitCurrency::_lift(arg3.assume_init() as i64 as i32 as u8);
                V14::UnitCurrency(e14)
              }
              42 => {
                let e14 = super::super::super::super::__with_name2::UnitTemperature::_lift(arg3.assume_init() as i64 as i32 as u8);
                V14::UnitTemperature(e14)
              }
              43 => {
                let e14 = super::super::super::super::__with_name2::UnitTime::_lift(arg3.assume_init() as i64 as i32 as u8);
                V14::UnitTime(e14)
              }
              44 => {
                let e14 = super::super::super::super::__with_name2::UnitLength::_lift(arg3.assume_init() as i64 as i32 as u8);
                V14::UnitLength(e14)
              }
              45 => {
                let e14 = super::super::super::super::__with_name2::UnitFrequency::_lift(arg3.assume_init() as i64 as i32 as u8);
                V14::UnitFrequency(e14)
              }
              46 => {
                let e14 = super::super::super::super::__with_name2::UnitPressure::_lift(arg3.assume_init() as i64 as i32 as u8);
                V14::UnitPressure(e14)
              }
              47 => {
                let e14 = super::super::super::super::__with_name2::UnitSoundPressure::_lift(arg3.assume_init() as i64 as i32 as u8);
                V14::UnitSoundPressure(e14)
              }
              48 => {
                let e14 = super::super::super::super::__with_name2::UnitVolume::_lift(arg3.assume_init() as i64 as i32 as u8);
                V14::UnitVolume(e14)
              }
              49 => {
                let e14 = super::super::super::super::__with_name2::UnitVolumeFlowRate::_lift(arg3.assume_init() as i64 as i32 as u8);
                V14::UnitVolumeFlowRate(e14)
              }
              50 => {
                let e14 = super::super::super::super::__with_name2::UnitArea::_lift(arg3.assume_init() as i64 as i32 as u8);
                V14::UnitArea(e14)
              }
              51 => {
                let e14 = super::super::super::super::__with_name2::UnitMass::_lift(arg3.assume_init() as i64 as i32 as u8);
                V14::UnitMass(e14)
              }
              52 => {
                let e14 = super::super::super::super::__with_name2::UnitConductivity::_lift(arg3.assume_init() as i64 as i32 as u8);
                V14::UnitConductivity(e14)
              }
              53 => {
                let e14 = super::super::super::super::__with_name2::UnitLight::_lift(arg3.assume_init() as i64 as i32 as u8);
                V14::UnitLight(e14)
              }
              54 => {
                let e14 = super::super::super::super::__with_name2::UnitUvIndex::_lift(arg3.assume_init() as i64 as i32 as u8);
                V14::UnitUvIndex(e14)
              }
              55 => {
                let e14 = super::super::super::super::__with_name2::UnitPercentage::_lift(arg3.assume_init() as i64 as i32 as u8);
                V14::UnitPercentage(e14)
              }
              56 => {
                let e14 = super::super::super::super::__with_name2::UnitIrradiation::_lift(arg3.assume_init() as i64 as i32 as u8);
                V14::UnitIrradiation(e14)
              }
              57 => {
                let e14 = super::super::super::super::__with_name2::UnitConcentration::_lift(arg3.assume_init() as i64 as i32 as u8);
                V14::UnitConcentration(e14)
              }
              58 => {
                let e14 = super::super::super::super::__with_name2::UnitSpeed::_lift(arg3.assume_init() as i64 as i32 as u8);
                V14::UnitSpeed(e14)
              }
              59 => {
                let e14 = super::super::super::super::__with_name2::UnitData::_lift(arg3.assume_init() as i64 as i32 as u8);
                V14::UnitData(e14)
              }
              60 => {
                let e14 = super::super::super::super::__with_name2::UnitDataRate::_lift(arg3.assume_init() as i64 as i32 as u8);
                V14::UnitDataRate(e14)
              }
              61 => {
                let e14 = super::super::super::super::__with_name2::FanOscillation::_lift(arg3.assume_init() as i64 as i32 as u8);
                V14::FanOscillation(e14)
              }
              62 => {
                let e14 = super::super::super::super::__with_name2::FanDirection::_lift(arg3.assume_init() as i64 as i32 as u8);
                V14::FanDirection(e14)
              }
              63 => {
                let e14 = super::super::super::super::__with_name2::FanSpeed::_lift(arg3.assume_init() as i64 as i32 as u8);
                V14::FanSpeed(e14)
              }
              64 => {
                let e14 = super::super::super::super::__with_name2::ClimateMode::_lift(arg3.assume_init() as i64 as i32 as u8);
                V14::ClimateMode(e14)
              }
              65 => {
                let e14 = super::super::super::super::__with_name2::LockState::_lift(arg3.assume_init() as i64 as i32 as u8);
                V14::LockState(e14)
              }
              66 => {
                let e14 = super::super::super::super::__with_name2::MediaState::_lift(arg3.assume_init() as i64 as i32 as u8);
                V14::MediaState(e14)
              }
              67 => {
                V14::Cover
              }
              68 => {
                let e14 = super::super::super::super::__with_name2::CoverState::_lift(arg3.assume_init() as i64 as i32 as u8);
                V14::CoverState(e14)
              }
              69 => {
                let e14 = f64::from_bits(arg3.assume_init() as i64 as u64);
                V14::Position(e14)
              }
              70 => {
                let e14 = f64::from_bits(arg3.assume_init() as i64 as u64);
                V14::Tilt(e14)
              }
              71 => {
                V14::Valve
              }
              72 => {
                let e14 = super::super::super::super::__with_name2::ValveState::_lift(arg3.assume_init() as i64 as i32 as u8);
                V14::ValveState(e14)
              }
              n => {
                debug_assert_eq!(n, 73, "invalid enum discriminant");
                let e14 = super::super::super::super::__with_name2::AlarmState::_lift(arg3.assume_init() as i64 as i32 as u8);
                V14::AlarmState(e14)
              }
            };
            T::put_component(super::super::super::super::__with_name0::DeviceId{
              packed: arg0 as u64,
            }, super::super::super::super::__with_name0::EntityIndex{
              inner: arg1 as u64,
            }, v14).await
          };
          let (result17_0,result17_1,result17_2,) = match result15 {
            Ok(_) => { (0i32, ::core::ptr::null_mut(), 0usize) },
            Err(e) => { {
              let vec16 = e;
              let ptr16 = vec16.as_ptr().cast::<u8>();
              let len16 = vec16.len();

              (1i32, ptr16.cast_mut(), len16)
            } },
          };
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "[export]igloo:lib/core-to-extension-sp@0.1.0")]
          unsafe extern "C" {
            #[link_name = "[task-return]put-component"]
            fn wit_import18(_: i32, _: *mut u8, _: usize, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn wit_import18(_: i32, _: *mut u8, _: usize, ) { unreachable!() }
          _task_cancel.forget();
          wit_import18(result17_0, result17_1, result17_2);
        })
      } }
      #[doc(hidden)]
      #[allow(non_snake_case)]
      pub unsafe fn __callback_put_component(event0: u32, event1: u32, event2: u32) -> u32 {
        unsafe {
          wit_bindgen::rt::async_support::callback(event0, event1, event2)
        }
      }
      #[doc(hidden)]
      #[allow(non_snake_case, unused_unsafe)]
      pub unsafe fn _export_delete_device_cabi<T: Guest>(arg0: i64,) -> i32 { unsafe {#[cfg(target_arch="wasm32")]
      _rt::run_ctors_once();wit_bindgen::rt::async_support::start_task(async move {
        let _task_cancel = wit_bindgen::rt::async_support::TaskCancelOnDrop::new();
        let result0 = &{
          T::delete_device(super::super::super::super::__with_name0::DeviceId{
            packed: arg0 as u64,
          }).await
        };
        let (result2_0,result2_1,result2_2,) = match result0 {
          Ok(_) => { (0i32, ::core::ptr::null_mut(), 0usize) },
          Err(e) => { {
            let vec1 = e;
            let ptr1 = vec1.as_ptr().cast::<u8>();
            let len1 = vec1.len();

            (1i32, ptr1.cast_mut(), len1)
          } },
        };
        #[cfg(target_arch = "wasm32")]
        #[link(wasm_import_module = "[export]igloo:lib/core-to-extension-sp@0.1.0")]
        unsafe extern "C" {
          #[link_name = "[task-return]delete-device"]
          fn wit_import3(_: i32, _: *mut u8, _: usize, );
        }

        #[cfg(not(target_arch = "wasm32"))]
        unsafe extern "C" fn wit_import3(_: i32, _: *mut u8, _: usize, ) { unreachable!() }
        _task_cancel.forget();
        wit_import3(result2_0, result2_1, result2_2);
      })
    } }
    #[doc(hidden)]
    #[allow(non_snake_case)]
    pub unsafe fn __callback_delete_device(event0: u32, event1: u32, event2: u32) -> u32 {
      unsafe {
        wit_bindgen::rt::async_support::callback(event0, event1, event2)
      }
    }
    #[doc(hidden)]
    #[allow(non_snake_case, unused_unsafe)]
    pub unsafe fn _export_custom_cabi<T: Guest>(arg0: *mut u8,arg1: usize,arg2: *mut u8,arg3: usize,) -> i32 { unsafe {#[cfg(target_arch="wasm32")]
    _rt::run_ctors_once();wit_bindgen::rt::async_support::start_task(async move {
      let _task_cancel = wit_bindgen::rt::async_support::TaskCancelOnDrop::new();
      let result2 = &{
        let len0 = arg1;
        let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
        let len1 = arg3;
        let bytes1 = _rt::Vec::from_raw_parts(arg2.cast(), len1, len1);
        T::custom(_rt::string_lift(bytes0), _rt::string_lift(bytes1)).await
      };
      let (result4_0,result4_1,result4_2,) = match result2 {
        Ok(_) => { (0i32, ::core::ptr::null_mut(), 0usize) },
        Err(e) => { {
          let vec3 = e;
          let ptr3 = vec3.as_ptr().cast::<u8>();
          let len3 = vec3.len();

          (1i32, ptr3.cast_mut(), len3)
        } },
      };
      #[cfg(target_arch = "wasm32")]
      #[link(wasm_import_module = "[export]igloo:lib/core-to-extension-sp@0.1.0")]
      unsafe extern "C" {
        #[link_name = "[task-return]custom"]
        fn wit_import5(_: i32, _: *mut u8, _: usize, );
      }

      #[cfg(not(target_arch = "wasm32"))]
      unsafe extern "C" fn wit_import5(_: i32, _: *mut u8, _: usize, ) { unreachable!() }
      _task_cancel.forget();
      wit_import5(result4_0, result4_1, result4_2);
    })
  } }
  #[doc(hidden)]
  #[allow(non_snake_case)]
  pub unsafe fn __callback_custom(event0: u32, event1: u32, event2: u32) -> u32 {
    unsafe {
      wit_bindgen::rt::async_support::callback(event0, event1, event2)
    }
  }
  pub trait Guest {
    /// Igloo core request to put a component on the given device and entity.
    /// The change will not be applied to the device tree until the extension
    /// confirms by sending a `put-component` back
    /// (usually after response from the physical hardware device)
    ///
    /// The extension _should_ hint to the core whether the operation will
    /// succeed by returning either `Ok` or `Err`
    #[allow(async_fn_in_trait)]
    async fn put_component(device_id: DeviceId,entity_index: EntityIndex,component: Component,) -> Result<(),_rt::String>;
    /// Igloo has deleted device,
    /// extension must cleanup its `Device` reference
    #[allow(async_fn_in_trait)]
    async fn delete_device(device_id: DeviceId,) -> Result<(),_rt::String>;
    /// Custom function defined by extension
    #[allow(async_fn_in_trait)]
    async fn custom(name: _rt::String,params: _rt::String,) -> Result<(),_rt::String>;
  }
  #[doc(hidden)]

  macro_rules! __export_igloo_lib_core_to_extension_sp_0_1_0_cabi{
    ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

      #[unsafe(export_name = "[async-lift]igloo:lib/core-to-extension-sp@0.1.0#put-component")]
      unsafe extern "C" fn export_put_component(arg0: i64,arg1: i64,arg2: i32,arg3: ::core::mem::MaybeUninit::<u64>,arg4: i64,arg5: i64,) -> i32 {
        unsafe { $($path_to_types)*::_export_put_component_cabi::<$ty>(arg0, arg1, arg2, arg3, arg4, arg5) }
      }
      #[unsafe(export_name = "[callback][async-lift]igloo:lib/core-to-extension-sp@0.1.0#put-component")]
      unsafe extern "C" fn _callback_put_component(event0: u32, event1: u32, event2: u32) -> u32 {
        unsafe {
          $($path_to_types)*::__callback_put_component(event0, event1, event2)
        }
      }
      #[unsafe(export_name = "[async-lift]igloo:lib/core-to-extension-sp@0.1.0#delete-device")]
      unsafe extern "C" fn export_delete_device(arg0: i64,) -> i32 {
        unsafe { $($path_to_types)*::_export_delete_device_cabi::<$ty>(arg0) }
      }
      #[unsafe(export_name = "[callback][async-lift]igloo:lib/core-to-extension-sp@0.1.0#delete-device")]
      unsafe extern "C" fn _callback_delete_device(event0: u32, event1: u32, event2: u32) -> u32 {
        unsafe {
          $($path_to_types)*::__callback_delete_device(event0, event1, event2)
        }
      }
      #[unsafe(export_name = "[async-lift]igloo:lib/core-to-extension-sp@0.1.0#custom")]
      unsafe extern "C" fn export_custom(arg0: *mut u8,arg1: usize,arg2: *mut u8,arg3: usize,) -> i32 {
        unsafe { $($path_to_types)*::_export_custom_cabi::<$ty>(arg0, arg1, arg2, arg3) }
      }
      #[unsafe(export_name = "[callback][async-lift]igloo:lib/core-to-extension-sp@0.1.0#custom")]
      unsafe extern "C" fn _callback_custom(event0: u32, event1: u32, event2: u32) -> u32 {
        unsafe {
          $($path_to_types)*::__callback_custom(event0, event1, event2)
        }
      }
    };);
  }
  #[doc(hidden)]
  pub(crate) use __export_igloo_lib_core_to_extension_sp_0_1_0_cabi;

}

}
}
pub mod wasi {
  pub mod cli {

    #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
    pub mod run {
      #[used]
      #[doc(hidden)]
      static __FORCE_SECTION_REF: fn() =
      super::super::super::super::__link_custom_section_describing_imports;
      
      use super::super::super::super::_rt;
      #[doc(hidden)]
      #[allow(non_snake_case, unused_unsafe)]
      pub unsafe fn _export_run_cabi<T: Guest>() -> i32 { unsafe {#[cfg(target_arch="wasm32")]
      _rt::run_ctors_once();wit_bindgen::rt::async_support::start_task(async move {
        let _task_cancel = wit_bindgen::rt::async_support::TaskCancelOnDrop::new();
        let result0 = &{
          T::run().await
        };
        let result1 = match result0 {
          Ok(_) => { 0i32 },
          Err(_) => { 1i32 },
        };
        #[cfg(target_arch = "wasm32")]
        #[link(wasm_import_module = "[export]wasi:cli/run@0.3.0-rc-2026-01-06")]
        unsafe extern "C" {
          #[link_name = "[task-return]run"]
          fn wit_import2(_: i32, );
        }

        #[cfg(not(target_arch = "wasm32"))]
        unsafe extern "C" fn wit_import2(_: i32, ) { unreachable!() }
        _task_cancel.forget();
        wit_import2(result1);
      })
    } }
    #[doc(hidden)]
    #[allow(non_snake_case)]
    pub unsafe fn __callback_run(event0: u32, event1: u32, event2: u32) -> u32 {
      unsafe {
        wit_bindgen::rt::async_support::callback(event0, event1, event2)
      }
    }
    pub trait Guest {
      /// Run the program.
      #[allow(async_fn_in_trait)]
      async fn run() -> Result<(),()>;
    }
    #[doc(hidden)]

    macro_rules! __export_wasi_cli_run_0_3_0_rc_2026_01_06_cabi{
      ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

        #[unsafe(export_name = "[async-lift]wasi:cli/run@0.3.0-rc-2026-01-06#run")]
        unsafe extern "C" fn export_run() -> i32 {
          unsafe { $($path_to_types)*::_export_run_cabi::<$ty>() }
        }
        #[unsafe(export_name = "[callback][async-lift]wasi:cli/run@0.3.0-rc-2026-01-06#run")]
        unsafe extern "C" fn _callback_run(event0: u32, event1: u32, event2: u32) -> u32 {
          unsafe {
            $($path_to_types)*::__callback_run(event0, event1, event2)
          }
        }
      };);
    }
    #[doc(hidden)]
    pub(crate) use __export_wasi_cli_run_0_3_0_rc_2026_01_06_cabi;

  }

}
}
}
mod _rt {
  #![allow(dead_code, unused_imports, clippy::all)]


  use core::fmt;
  use core::marker;
  use core::sync::atomic::{AtomicU32, Ordering::Relaxed};

  /// A type which represents a component model resource, either imported or
  /// exported into this component.
  ///
  /// This is a low-level wrapper which handles the lifetime of the resource
  /// (namely this has a destructor). The `T` provided defines the component model
  /// intrinsics that this wrapper uses.
  ///
  /// One of the chief purposes of this type is to provide `Deref` implementations
  /// to access the underlying data when it is owned.
  ///
  /// This type is primarily used in generated code for exported and imported
  /// resources.
  #[repr(transparent)]
  pub struct Resource<T: WasmResource> {
    // NB: This would ideally be `u32` but it is not. The fact that this has
    // interior mutability is not exposed in the API of this type except for the
    // `take_handle` method which is supposed to in theory be private.
    //
    // This represents, almost all the time, a valid handle value. When it's
    // invalid it's stored as `u32::MAX`.
    handle: AtomicU32,
    _marker: marker::PhantomData<T>,
  }

  /// A trait which all wasm resources implement, namely providing the ability to
  /// drop a resource.
  ///
  /// This generally is implemented by generated code, not user-facing code.
  #[allow(clippy::missing_safety_doc)]
  pub unsafe trait WasmResource {
    /// Invokes the `[resource-drop]...` intrinsic.
    unsafe fn drop(handle: u32);
  }

  impl<T: WasmResource> Resource<T> {
    #[doc(hidden)]
    pub unsafe fn from_handle(handle: u32) -> Self {
      debug_assert!(handle != 0 && handle != u32::MAX);
      Self {
        handle: AtomicU32::new(handle),
        _marker: marker::PhantomData,
      }
    }

    /// Takes ownership of the handle owned by `resource`.
    ///
    /// Note that this ideally would be `into_handle` taking `Resource<T>` by
    /// ownership. The code generator does not enable that in all situations,
    /// unfortunately, so this is provided instead.
    ///
    /// Also note that `take_handle` is in theory only ever called on values
    /// owned by a generated function. For example a generated function might
    /// take `Resource<T>` as an argument but then call `take_handle` on a
    /// reference to that argument. In that sense the dynamic nature of
    /// `take_handle` should only be exposed internally to generated code, not
    /// to user code.
    #[doc(hidden)]
    pub fn take_handle(resource: &Resource<T>) -> u32 {
      resource.handle.swap(u32::MAX, Relaxed)
    }

    #[doc(hidden)]
    pub fn handle(resource: &Resource<T>) -> u32 {
      resource.handle.load(Relaxed)
    }
  }

  impl<T: WasmResource> fmt::Debug for Resource<T> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
      f.debug_struct("Resource")
      .field("handle", &self.handle)
      .finish()
    }
  }

  impl<T: WasmResource> Drop for Resource<T> {
    fn drop(&mut self) {
      unsafe {
        match self.handle.load(Relaxed) {
          // If this handle was "taken" then don't do anything in the
          // destructor.
          u32::MAX => {}

          // ... but otherwise do actually destroy it with the imported
          // component model intrinsic as defined through `T`.
          other => T::drop(other),
        }
      }
    }
  }
  pub use alloc_crate::vec::Vec;
  pub unsafe fn string_lift(bytes: Vec<u8>) -> String {
    if cfg!(debug_assertions) {
      String::from_utf8(bytes).unwrap()
    } else {
      unsafe { String::from_utf8_unchecked(bytes) }
    }
  }
  pub unsafe fn cabi_dealloc(ptr: *mut u8, size: usize, align: usize) {
    if size == 0 {
      return;
    }
    unsafe {
      let layout = alloc::Layout::from_size_align_unchecked(size, align);
      alloc::dealloc(ptr, layout);
    }
  }
  
  pub fn as_i64<T: AsI64>(t: T) -> i64 {
    t.as_i64()
  }

  pub trait AsI64 {
    fn as_i64(self) -> i64;
  }

  impl<'a, T: Copy + AsI64> AsI64 for &'a T {
    fn as_i64(self) -> i64 {
      (*self).as_i64()
    }
  }
  
  impl AsI64 for i64 {
    #[inline]
    fn as_i64(self) -> i64 {
      self as i64
    }
  }
  
  impl AsI64 for u64 {
    #[inline]
    fn as_i64(self) -> i64 {
      self as i64
    }
  }
  
  pub fn as_f64<T: AsF64>(t: T) -> f64 {
    t.as_f64()
  }

  pub trait AsF64 {
    fn as_f64(self) -> f64;
  }

  impl<'a, T: Copy + AsF64> AsF64 for &'a T {
    fn as_f64(self) -> f64 {
      (*self).as_f64()
    }
  }
  
  impl AsF64 for f64 {
    #[inline]
    fn as_f64(self) -> f64 {
      self as f64
    }
  }
  
  pub fn as_i32<T: AsI32>(t: T) -> i32 {
    t.as_i32()
  }

  pub trait AsI32 {
    fn as_i32(self) -> i32;
  }

  impl<'a, T: Copy + AsI32> AsI32 for &'a T {
    fn as_i32(self) -> i32 {
      (*self).as_i32()
    }
  }
  
  impl AsI32 for i32 {
    #[inline]
    fn as_i32(self) -> i32 {
      self as i32
    }
  }
  
  impl AsI32 for u32 {
    #[inline]
    fn as_i32(self) -> i32 {
      self as i32
    }
  }
  
  impl AsI32 for i16 {
    #[inline]
    fn as_i32(self) -> i32 {
      self as i32
    }
  }
  
  impl AsI32 for u16 {
    #[inline]
    fn as_i32(self) -> i32 {
      self as i32
    }
  }
  
  impl AsI32 for i8 {
    #[inline]
    fn as_i32(self) -> i32 {
      self as i32
    }
  }
  
  impl AsI32 for u8 {
    #[inline]
    fn as_i32(self) -> i32 {
      self as i32
    }
  }
  
  impl AsI32 for char {
    #[inline]
    fn as_i32(self) -> i32 {
      self as i32
    }
  }
  
  impl AsI32 for usize {
    #[inline]
    fn as_i32(self) -> i32 {
      self as i32
    }
  }
  pub use alloc_crate::alloc;
  pub unsafe fn invalid_enum_discriminant<T>() -> T {
    if cfg!(debug_assertions) {
      panic!("invalid enum discriminant")
    } else {
      unsafe { core::hint::unreachable_unchecked() }
    }
  }
  pub use alloc_crate::string::String;
  pub unsafe fn bool_lift(val: u8) -> bool {
    if cfg!(debug_assertions) {
      match val {
        0 => false,
        1 => true,
        _ => panic!("invalid bool discriminant"),
      }
    } else {
      val != 0
    }
  }
  
  #[cfg(target_arch = "wasm32")]
  pub fn run_ctors_once() {
    wit_bindgen::rt::run_ctors_once();
  }
  extern crate alloc as alloc_crate;
}
pub mod wit_future {
  #![allow(dead_code, unused_variables, clippy::all)]

  #[doc(hidden)]
  pub trait FuturePayload: Unpin + Sized + 'static {
    const VTABLE: &'static wit_bindgen::rt::async_support::FutureVtable<Self>;
  }
  #[doc(hidden)]
  #[allow(unused_unsafe)]
  pub mod vtable0 {

    #[cfg(not(target_arch = "wasm32"))]
    unsafe extern "C" fn cancel_write(_: u32) -> u32 { unreachable!() }
    #[cfg(not(target_arch = "wasm32"))]
    unsafe extern "C" fn cancel_read(_: u32) -> u32 { unreachable!() }
    #[cfg(not(target_arch = "wasm32"))]
    unsafe extern "C" fn drop_writable(_: u32) { unreachable!() }
    #[cfg(not(target_arch = "wasm32"))]
    unsafe extern "C" fn drop_readable(_: u32) { unreachable!() }
    #[cfg(not(target_arch = "wasm32"))]
    unsafe extern "C" fn new() -> u64 { unreachable!() }
    #[cfg(not(target_arch = "wasm32"))]
    unsafe extern "C" fn start_read(_: u32, _: *mut u8) -> u32 { unreachable!() }
    #[cfg(not(target_arch = "wasm32"))]
    unsafe extern "C" fn start_write(_: u32, _: *const u8) -> u32 { unreachable!() }

    #[cfg(target_arch = "wasm32")]
    #[link(wasm_import_module = "wasi:cli/stdin@0.3.0-rc-2026-01-06")]
    unsafe extern "C" {
      #[link_name = "[future-new-1]read-via-stream"]
      fn new() -> u64;
      #[link_name = "[future-cancel-write-1]read-via-stream"]
      fn cancel_write(_: u32) -> u32;
      #[link_name = "[future-cancel-read-1]read-via-stream"]
      fn cancel_read(_: u32) -> u32;
      #[link_name = "[future-drop-writable-1]read-via-stream"]
      fn drop_writable(_: u32);
      #[link_name = "[future-drop-readable-1]read-via-stream"]
      fn drop_readable(_: u32);
      #[link_name = "[async-lower][future-read-1]read-via-stream"]
      fn start_read(_: u32, _: *mut u8) -> u32;
      #[link_name = "[async-lower][future-write-1]read-via-stream"]
      fn start_write(_: u32, _: *const u8) -> u32;
    }

    unsafe fn lift(ptr: *mut u8) -> Result<(),super::super::wasi::cli::stdin::ErrorCode> { unsafe { let l0 = i32::from(*ptr.add(0).cast::<u8>());

    match l0 {
      0 => {
        let e = ();
        Ok(e)
      }
      1 => {
        let e = {
          let l1 = i32::from(*ptr.add(1).cast::<u8>());

          super::super::wasi::cli::types::ErrorCode::_lift(l1 as u8)
        };
        Err(e)
      }
      _ => super::super::_rt::invalid_enum_discriminant(),
    } } }
    unsafe fn lower(value: Result<(),super::super::wasi::cli::stdin::ErrorCode>, ptr: *mut u8) { unsafe { match value {
      Ok(_) => { {
        *ptr.add(0).cast::<u8>() = (0i32) as u8;
      } },
      Err(e) => { {
        *ptr.add(0).cast::<u8>() = (1i32) as u8;
        *ptr.add(1).cast::<u8>() = (e.clone() as i32) as u8;
      } },
    }; } }
    unsafe fn dealloc_lists(ptr: *mut u8) { unsafe {  } }

    pub static VTABLE: wit_bindgen::rt::async_support::FutureVtable<Result<(),super::super::wasi::cli::stdin::ErrorCode>> = wit_bindgen::rt::async_support::FutureVtable::<Result<(),super::super::wasi::cli::stdin::ErrorCode>> {
      cancel_write,
      cancel_read,
      drop_writable,
      drop_readable,
      dealloc_lists,
      layout: unsafe {
        ::std::alloc::Layout::from_size_align_unchecked(2, 1)
      },
      lift,
      lower,
      new,
      start_read,
      start_write,
    };

    impl super::FuturePayload for Result<(),super::super::wasi::cli::stdin::ErrorCode> {
      const VTABLE: &'static wit_bindgen::rt::async_support::FutureVtable<Self> = &VTABLE;
    }
  }
  
  #[doc(hidden)]
  #[allow(unused_unsafe)]
  pub mod vtable1 {

    #[cfg(not(target_arch = "wasm32"))]
    unsafe extern "C" fn cancel_write(_: u32) -> u32 { unreachable!() }
    #[cfg(not(target_arch = "wasm32"))]
    unsafe extern "C" fn cancel_read(_: u32) -> u32 { unreachable!() }
    #[cfg(not(target_arch = "wasm32"))]
    unsafe extern "C" fn drop_writable(_: u32) { unreachable!() }
    #[cfg(not(target_arch = "wasm32"))]
    unsafe extern "C" fn drop_readable(_: u32) { unreachable!() }
    #[cfg(not(target_arch = "wasm32"))]
    unsafe extern "C" fn new() -> u64 { unreachable!() }
    #[cfg(not(target_arch = "wasm32"))]
    unsafe extern "C" fn start_read(_: u32, _: *mut u8) -> u32 { unreachable!() }
    #[cfg(not(target_arch = "wasm32"))]
    unsafe extern "C" fn start_write(_: u32, _: *const u8) -> u32 { unreachable!() }

    #[cfg(target_arch = "wasm32")]
    #[link(wasm_import_module = "wasi:filesystem/types@0.3.0-rc-2026-01-06")]
    unsafe extern "C" {
      #[link_name = "[future-new-1][method]descriptor.read-via-stream"]
      fn new() -> u64;
      #[link_name = "[future-cancel-write-1][method]descriptor.read-via-stream"]
      fn cancel_write(_: u32) -> u32;
      #[link_name = "[future-cancel-read-1][method]descriptor.read-via-stream"]
      fn cancel_read(_: u32) -> u32;
      #[link_name = "[future-drop-writable-1][method]descriptor.read-via-stream"]
      fn drop_writable(_: u32);
      #[link_name = "[future-drop-readable-1][method]descriptor.read-via-stream"]
      fn drop_readable(_: u32);
      #[link_name = "[async-lower][future-read-1][method]descriptor.read-via-stream"]
      fn start_read(_: u32, _: *mut u8) -> u32;
      #[link_name = "[async-lower][future-write-1][method]descriptor.read-via-stream"]
      fn start_write(_: u32, _: *const u8) -> u32;
    }

    unsafe fn lift(ptr: *mut u8) -> Result<(),super::super::wasi::filesystem::types::ErrorCode> { unsafe { let l0 = i32::from(*ptr.add(0).cast::<u8>());

    match l0 {
      0 => {
        let e = ();
        Ok(e)
      }
      1 => {
        let e = {
          let l1 = i32::from(*ptr.add(1).cast::<u8>());

          super::super::wasi::filesystem::types::ErrorCode::_lift(l1 as u8)
        };
        Err(e)
      }
      _ => super::super::_rt::invalid_enum_discriminant(),
    } } }
    unsafe fn lower(value: Result<(),super::super::wasi::filesystem::types::ErrorCode>, ptr: *mut u8) { unsafe { match value {
      Ok(_) => { {
        *ptr.add(0).cast::<u8>() = (0i32) as u8;
      } },
      Err(e) => { {
        *ptr.add(0).cast::<u8>() = (1i32) as u8;
        *ptr.add(1).cast::<u8>() = (e.clone() as i32) as u8;
      } },
    }; } }
    unsafe fn dealloc_lists(ptr: *mut u8) { unsafe {  } }

    pub static VTABLE: wit_bindgen::rt::async_support::FutureVtable<Result<(),super::super::wasi::filesystem::types::ErrorCode>> = wit_bindgen::rt::async_support::FutureVtable::<Result<(),super::super::wasi::filesystem::types::ErrorCode>> {
      cancel_write,
      cancel_read,
      drop_writable,
      drop_readable,
      dealloc_lists,
      layout: unsafe {
        ::std::alloc::Layout::from_size_align_unchecked(2, 1)
      },
      lift,
      lower,
      new,
      start_read,
      start_write,
    };

    impl super::FuturePayload for Result<(),super::super::wasi::filesystem::types::ErrorCode> {
      const VTABLE: &'static wit_bindgen::rt::async_support::FutureVtable<Self> = &VTABLE;
    }
  }
  
  #[doc(hidden)]
  #[allow(unused_unsafe)]
  pub mod vtable2 {

    #[cfg(not(target_arch = "wasm32"))]
    unsafe extern "C" fn cancel_write(_: u32) -> u32 { unreachable!() }
    #[cfg(not(target_arch = "wasm32"))]
    unsafe extern "C" fn cancel_read(_: u32) -> u32 { unreachable!() }
    #[cfg(not(target_arch = "wasm32"))]
    unsafe extern "C" fn drop_writable(_: u32) { unreachable!() }
    #[cfg(not(target_arch = "wasm32"))]
    unsafe extern "C" fn drop_readable(_: u32) { unreachable!() }
    #[cfg(not(target_arch = "wasm32"))]
    unsafe extern "C" fn new() -> u64 { unreachable!() }
    #[cfg(not(target_arch = "wasm32"))]
    unsafe extern "C" fn start_read(_: u32, _: *mut u8) -> u32 { unreachable!() }
    #[cfg(not(target_arch = "wasm32"))]
    unsafe extern "C" fn start_write(_: u32, _: *const u8) -> u32 { unreachable!() }

    #[cfg(target_arch = "wasm32")]
    #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2026-01-06")]
    unsafe extern "C" {
      #[link_name = "[future-new-1][method]tcp-socket.receive"]
      fn new() -> u64;
      #[link_name = "[future-cancel-write-1][method]tcp-socket.receive"]
      fn cancel_write(_: u32) -> u32;
      #[link_name = "[future-cancel-read-1][method]tcp-socket.receive"]
      fn cancel_read(_: u32) -> u32;
      #[link_name = "[future-drop-writable-1][method]tcp-socket.receive"]
      fn drop_writable(_: u32);
      #[link_name = "[future-drop-readable-1][method]tcp-socket.receive"]
      fn drop_readable(_: u32);
      #[link_name = "[async-lower][future-read-1][method]tcp-socket.receive"]
      fn start_read(_: u32, _: *mut u8) -> u32;
      #[link_name = "[async-lower][future-write-1][method]tcp-socket.receive"]
      fn start_write(_: u32, _: *const u8) -> u32;
    }

    unsafe fn lift(ptr: *mut u8) -> Result<(),super::super::wasi::sockets::types::ErrorCode> { unsafe { let l0 = i32::from(*ptr.add(0).cast::<u8>());

    match l0 {
      0 => {
        let e = ();
        Ok(e)
      }
      1 => {
        let e = {
          let l1 = i32::from(*ptr.add(1).cast::<u8>());

          super::super::wasi::sockets::types::ErrorCode::_lift(l1 as u8)
        };
        Err(e)
      }
      _ => super::super::_rt::invalid_enum_discriminant(),
    } } }
    unsafe fn lower(value: Result<(),super::super::wasi::sockets::types::ErrorCode>, ptr: *mut u8) { unsafe { match value {
      Ok(_) => { {
        *ptr.add(0).cast::<u8>() = (0i32) as u8;
      } },
      Err(e) => { {
        *ptr.add(0).cast::<u8>() = (1i32) as u8;
        *ptr.add(1).cast::<u8>() = (e.clone() as i32) as u8;
      } },
    }; } }
    unsafe fn dealloc_lists(ptr: *mut u8) { unsafe {  } }

    pub static VTABLE: wit_bindgen::rt::async_support::FutureVtable<Result<(),super::super::wasi::sockets::types::ErrorCode>> = wit_bindgen::rt::async_support::FutureVtable::<Result<(),super::super::wasi::sockets::types::ErrorCode>> {
      cancel_write,
      cancel_read,
      drop_writable,
      drop_readable,
      dealloc_lists,
      layout: unsafe {
        ::std::alloc::Layout::from_size_align_unchecked(2, 1)
      },
      lift,
      lower,
      new,
      start_read,
      start_write,
    };

    impl super::FuturePayload for Result<(),super::super::wasi::sockets::types::ErrorCode> {
      const VTABLE: &'static wit_bindgen::rt::async_support::FutureVtable<Self> = &VTABLE;
    }
  }
  /// Creates a new Component Model `future` with the specified payload type.
  ///
  /// The `default` function provided computes the default value to be sent in
  /// this future if no other value was otherwise sent.
  pub fn new<T: FuturePayload>(default: fn() -> T) -> (wit_bindgen::rt::async_support::FutureWriter<T>, wit_bindgen::rt::async_support::FutureReader<T>) {
    unsafe { wit_bindgen::rt::async_support::future_new::<T>(default, T::VTABLE) }
  }
}
pub mod wit_stream {
  #![allow(dead_code, unused_variables, clippy::all)]

  pub trait StreamPayload: Unpin + Sized + 'static {
    const VTABLE: &'static wit_bindgen::rt::async_support::StreamVtable<Self>;
  }
  #[doc(hidden)]
  #[allow(unused_unsafe)]
  pub mod vtable0 {

    #[cfg(not(target_arch = "wasm32"))]
    unsafe extern "C" fn cancel_write(_: u32) -> u32 { unreachable!() }
    #[cfg(not(target_arch = "wasm32"))]
    unsafe extern "C" fn cancel_read(_: u32) -> u32 { unreachable!() }
    #[cfg(not(target_arch = "wasm32"))]
    unsafe extern "C" fn drop_writable(_: u32) { unreachable!() }
    #[cfg(not(target_arch = "wasm32"))]
    unsafe extern "C" fn drop_readable(_: u32) { unreachable!() }
    #[cfg(not(target_arch = "wasm32"))]
    unsafe extern "C" fn new() -> u64 { unreachable!() }
    #[cfg(not(target_arch = "wasm32"))]
    unsafe extern "C" fn start_read(_: u32, _: *mut u8, _: usize) -> u32 { unreachable!() }
    #[cfg(not(target_arch = "wasm32"))]
    unsafe extern "C" fn start_write(_: u32, _: *const u8, _: usize) -> u32 { unreachable!() }

    #[cfg(target_arch = "wasm32")]
    #[link(wasm_import_module = "wasi:cli/stdin@0.3.0-rc-2026-01-06")]
    unsafe extern "C" {
      #[link_name = "[stream-new-0]read-via-stream"]
      fn new() -> u64;
      #[link_name = "[stream-cancel-write-0]read-via-stream"]
      fn cancel_write(_: u32) -> u32;
      #[link_name = "[stream-cancel-read-0]read-via-stream"]
      fn cancel_read(_: u32) -> u32;
      #[link_name = "[stream-drop-writable-0]read-via-stream"]
      fn drop_writable(_: u32);
      #[link_name = "[stream-drop-readable-0]read-via-stream"]
      fn drop_readable(_: u32);
      #[link_name = "[async-lower][stream-read-0]read-via-stream"]
      fn start_read(_: u32, _: *mut u8, _: usize) -> u32;
      #[link_name = "[async-lower][stream-write-0]read-via-stream"]
      fn start_write(_: u32, _: *const u8, _: usize) -> u32;
    }

    
    
    

    pub static VTABLE: wit_bindgen::rt::async_support::StreamVtable<u8> = wit_bindgen::rt::async_support::StreamVtable::<u8> {
      cancel_write,
      cancel_read,
      drop_writable,
      drop_readable,
      dealloc_lists: None,
      layout: unsafe {
        ::std::alloc::Layout::from_size_align_unchecked(1, 1)
      },
      lift: None,
      lower: None,
      new,
      start_read,
      start_write,
    };

    impl super::StreamPayload for u8 {
      const VTABLE: &'static wit_bindgen::rt::async_support::StreamVtable<Self> = &VTABLE;
    }
  }
  
  #[doc(hidden)]
  #[allow(unused_unsafe)]
  pub mod vtable1 {

    #[cfg(not(target_arch = "wasm32"))]
    unsafe extern "C" fn cancel_write(_: u32) -> u32 { unreachable!() }
    #[cfg(not(target_arch = "wasm32"))]
    unsafe extern "C" fn cancel_read(_: u32) -> u32 { unreachable!() }
    #[cfg(not(target_arch = "wasm32"))]
    unsafe extern "C" fn drop_writable(_: u32) { unreachable!() }
    #[cfg(not(target_arch = "wasm32"))]
    unsafe extern "C" fn drop_readable(_: u32) { unreachable!() }
    #[cfg(not(target_arch = "wasm32"))]
    unsafe extern "C" fn new() -> u64 { unreachable!() }
    #[cfg(not(target_arch = "wasm32"))]
    unsafe extern "C" fn start_read(_: u32, _: *mut u8, _: usize) -> u32 { unreachable!() }
    #[cfg(not(target_arch = "wasm32"))]
    unsafe extern "C" fn start_write(_: u32, _: *const u8, _: usize) -> u32 { unreachable!() }

    #[cfg(target_arch = "wasm32")]
    #[link(wasm_import_module = "wasi:filesystem/types@0.3.0-rc-2026-01-06")]
    unsafe extern "C" {
      #[link_name = "[stream-new-0][method]descriptor.read-directory"]
      fn new() -> u64;
      #[link_name = "[stream-cancel-write-0][method]descriptor.read-directory"]
      fn cancel_write(_: u32) -> u32;
      #[link_name = "[stream-cancel-read-0][method]descriptor.read-directory"]
      fn cancel_read(_: u32) -> u32;
      #[link_name = "[stream-drop-writable-0][method]descriptor.read-directory"]
      fn drop_writable(_: u32);
      #[link_name = "[stream-drop-readable-0][method]descriptor.read-directory"]
      fn drop_readable(_: u32);
      #[link_name = "[async-lower][stream-read-0][method]descriptor.read-directory"]
      fn start_read(_: u32, _: *mut u8, _: usize) -> u32;
      #[link_name = "[async-lower][stream-write-0][method]descriptor.read-directory"]
      fn start_write(_: u32, _: *const u8, _: usize) -> u32;
    }

    unsafe fn lift(ptr: *mut u8) -> super::super::wasi::filesystem::types::DirectoryEntry { unsafe { let l0 = i32::from(*ptr.add(0).cast::<u8>());
    let l1 = *ptr.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
    let l2 = *ptr.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>();
    let len3 = l2;
    let bytes3 = super::super::_rt::Vec::from_raw_parts(l1.cast(), len3, len3);

    super::super::wasi::filesystem::types::DirectoryEntry{
      type_: super::super::wasi::filesystem::types::DescriptorType::_lift(l0 as u8),
      name: super::super::_rt::string_lift(bytes3),
    } } }
    unsafe fn lower(value: super::super::wasi::filesystem::types::DirectoryEntry, ptr: *mut u8) { unsafe { let super::super::wasi::filesystem::types::DirectoryEntry{ type_:type_0, name:name0, } = value;
    *ptr.add(0).cast::<u8>() = (type_0.clone() as i32) as u8;
    let vec1 = (name0.into_bytes()).into_boxed_slice();
    let ptr1 = vec1.as_ptr().cast::<u8>();
    let len1 = vec1.len();
    ::core::mem::forget(vec1);
    *ptr.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>() = len1;
    *ptr.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr1.cast_mut();
  } }
  unsafe fn dealloc_lists(ptr: *mut u8) { unsafe { let l0 = *ptr.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
  let l1 = *ptr.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>();
  super::super::_rt::cabi_dealloc(l0, l1, 1);
} }

pub static VTABLE: wit_bindgen::rt::async_support::StreamVtable<super::super::wasi::filesystem::types::DirectoryEntry> = wit_bindgen::rt::async_support::StreamVtable::<super::super::wasi::filesystem::types::DirectoryEntry> {
  cancel_write,
  cancel_read,
  drop_writable,
  drop_readable,
  dealloc_lists: Some(dealloc_lists),
  layout: unsafe {
    ::std::alloc::Layout::from_size_align_unchecked(12, 4)
  },
  lift: Some(lift),
  lower: Some(lower),
  new,
  start_read,
  start_write,
};

impl super::StreamPayload for super::super::wasi::filesystem::types::DirectoryEntry {
  const VTABLE: &'static wit_bindgen::rt::async_support::StreamVtable<Self> = &VTABLE;
}
}

#[doc(hidden)]
#[allow(unused_unsafe)]
pub mod vtable2 {

  #[cfg(not(target_arch = "wasm32"))]
  unsafe extern "C" fn cancel_write(_: u32) -> u32 { unreachable!() }
  #[cfg(not(target_arch = "wasm32"))]
  unsafe extern "C" fn cancel_read(_: u32) -> u32 { unreachable!() }
  #[cfg(not(target_arch = "wasm32"))]
  unsafe extern "C" fn drop_writable(_: u32) { unreachable!() }
  #[cfg(not(target_arch = "wasm32"))]
  unsafe extern "C" fn drop_readable(_: u32) { unreachable!() }
  #[cfg(not(target_arch = "wasm32"))]
  unsafe extern "C" fn new() -> u64 { unreachable!() }
  #[cfg(not(target_arch = "wasm32"))]
  unsafe extern "C" fn start_read(_: u32, _: *mut u8, _: usize) -> u32 { unreachable!() }
  #[cfg(not(target_arch = "wasm32"))]
  unsafe extern "C" fn start_write(_: u32, _: *const u8, _: usize) -> u32 { unreachable!() }

  #[cfg(target_arch = "wasm32")]
  #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2026-01-06")]
  unsafe extern "C" {
    #[link_name = "[stream-new-0][method]tcp-socket.listen"]
    fn new() -> u64;
    #[link_name = "[stream-cancel-write-0][method]tcp-socket.listen"]
    fn cancel_write(_: u32) -> u32;
    #[link_name = "[stream-cancel-read-0][method]tcp-socket.listen"]
    fn cancel_read(_: u32) -> u32;
    #[link_name = "[stream-drop-writable-0][method]tcp-socket.listen"]
    fn drop_writable(_: u32);
    #[link_name = "[stream-drop-readable-0][method]tcp-socket.listen"]
    fn drop_readable(_: u32);
    #[link_name = "[async-lower][stream-read-0][method]tcp-socket.listen"]
    fn start_read(_: u32, _: *mut u8, _: usize) -> u32;
    #[link_name = "[async-lower][stream-write-0][method]tcp-socket.listen"]
    fn start_write(_: u32, _: *const u8, _: usize) -> u32;
  }

  unsafe fn lift(ptr: *mut u8) -> super::super::wasi::sockets::types::TcpSocket { unsafe { let l0 = *ptr.add(0).cast::<i32>();

  super::super::wasi::sockets::types::TcpSocket::from_handle(l0 as u32) } }
  unsafe fn lower(value: super::super::wasi::sockets::types::TcpSocket, ptr: *mut u8) { unsafe { *ptr.add(0).cast::<i32>() = (value).take_handle() as i32;
} }
unsafe fn dealloc_lists(ptr: *mut u8) { unsafe {  } }

pub static VTABLE: wit_bindgen::rt::async_support::StreamVtable<super::super::wasi::sockets::types::TcpSocket> = wit_bindgen::rt::async_support::StreamVtable::<super::super::wasi::sockets::types::TcpSocket> {
  cancel_write,
  cancel_read,
  drop_writable,
  drop_readable,
  dealloc_lists: Some(dealloc_lists),
  layout: unsafe {
    ::std::alloc::Layout::from_size_align_unchecked(4, 4)
  },
  lift: Some(lift),
  lower: Some(lower),
  new,
  start_read,
  start_write,
};

impl super::StreamPayload for super::super::wasi::sockets::types::TcpSocket {
  const VTABLE: &'static wit_bindgen::rt::async_support::StreamVtable<Self> = &VTABLE;
}
}
/// Creates a new Component Model `stream` with the specified payload type.
pub fn new<T: StreamPayload>() -> (wit_bindgen::rt::async_support::StreamWriter<T>, wit_bindgen::rt::async_support::StreamReader<T>) {
  unsafe { wit_bindgen::rt::async_support::stream_new::<T>(T::VTABLE) }
}
}

/// Generates `#[unsafe(no_mangle)]` functions to export the specified type as
/// the root implementation of all generated traits.
///
/// For more information see the documentation of `wit_bindgen::generate!`.
///
/// ```rust
/// # macro_rules! export{ ($($t:tt)*) => (); }
/// # trait Guest {}
/// struct MyType;
///
/// impl Guest for MyType {
///     // ...
/// }
///
/// export!(MyType);
/// ```
#[allow(unused_macros)]
#[doc(hidden)]

macro_rules! __export_extension_sp_impl {
  ($ty:ident) => (self::export!($ty with_types_in self););
  ($ty:ident with_types_in $($path_to_types_root:tt)*) => (
  $($path_to_types_root)*::exports::igloo::lib::core_to_extension_sp::__export_igloo_lib_core_to_extension_sp_0_1_0_cabi!($ty with_types_in $($path_to_types_root)*::exports::igloo::lib::core_to_extension_sp);
  $($path_to_types_root)*::exports::wasi::cli::run::__export_wasi_cli_run_0_3_0_rc_2026_01_06_cabi!($ty with_types_in $($path_to_types_root)*::exports::wasi::cli::run);
  )
}
#[doc(inline)]
pub(crate) use __export_extension_sp_impl as export;

#[cfg(target_arch = "wasm32")]
#[unsafe(link_section = "component-type:wit-bindgen:0.52.0:igloo:lib@0.1.0:extension-sp:encoded world")]
#[doc(hidden)]
#[allow(clippy::octal_escapes)]
pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 13635] = *b"\
\0asm\x0d\0\x01\0\0\x19\x16wit-component-encoding\x04\0\x07\xc0i\x01A\x02\x01AG\x01\
B\x0c\x01r\x01\x06packedw\x04\0\x09device-id\x03\0\0\x01r\x01\x06packedw\x04\0\x08\
group-id\x03\0\x02\x01r\x01\x05inners\x04\0\x0cextension-id\x03\0\x04\x01r\x01\x05\
innerw\x04\0\x0fextension-index\x03\0\x06\x01r\x01\x05inners\x04\0\x09entity-id\x03\
\0\x08\x01r\x01\x05innerw\x04\0\x0centity-index\x03\0\x0a\x03\0\x12igloo:lib/id@\
0.1.0\x05\0\x01B\x06\x01r\x03\x01ru\x01gu\x01bu\x04\0\x0bigloo-color\x03\0\0\x01\
r\x03\x04year{\x05month}\x03day}\x04\0\x0aigloo-date\x03\0\x02\x01r\x03\x04hour}\
\x06minute}\x06second}\x04\0\x0aigloo-time\x03\0\x04\x03\0\x18igloo:lib/compound\
@0.1.0\x05\x01\x02\x03\0\x01\x0bigloo-color\x02\x03\0\x01\x0aigloo-date\x02\x03\0\
\x01\x0aigloo-time\x01B]\x02\x03\x02\x01\x02\x04\0\x0bigloo-color\x03\0\0\x02\x03\
\x02\x01\x03\x04\0\x0aigloo-date\x03\0\x02\x02\x03\x02\x01\x04\x04\0\x0aigloo-ti\
me\x03\0\x04\x01m\x07\x06sunday\x06monday\x07tuesday\x09wednesday\x08thursday\x06\
friday\x08saturday\x04\0\x07weekday\x03\0\x06\x01m\x02\x05r-g-b\x0btemperature\x04\
\0\x0acolor-mode\x03\0\x08\x01m\x03\x0bmeasurement\x10total-increasing\x05total\x04\
\0\x12sensor-state-class\x03\0\x0a\x01m\x01\x0cvolt-amperes\x04\0\x13unit-appare\
nt-power\x03\0\x0c\x01m\x03\x05watts\x0akilo-watts\x0dbtus-per-hour\x04\0\x0auni\
t-power\x03\0\x0e\x01m\x01\x14volt-ampere-reactive\x04\0\x13unit-reactive-power\x03\
\0\x10\x01m\x03\x0awatt-hours\x0fkilo-watt-hours\x0fmega-watt-hours\x04\0\x0buni\
t-energy\x03\0\x12\x01m\x02\x0cmilliamperes\x07amperes\x04\0\x15unit-electric-cu\
rrent\x03\0\x14\x01m\x02\x0amillivolts\x05volts\x04\0\x17unit-electric-potential\
\x03\0\x16\x01m\x01\x07degrees\x04\0\x0bunit-degree\x03\0\x18\x01m\x03\x05euros\x07\
dollars\x05cents\x04\0\x0dunit-currency\x03\0\x1a\x01m\x03\x07celsius\x0afahrenh\
eit\x06kelvin\x04\0\x10unit-temperature\x03\0\x1c\x01m\x09\x0cmicroseconds\x0cmi\
lliseconds\x07seconds\x07minutes\x05hours\x04days\x05weeks\x06months\x05years\x04\
\0\x09unit-time\x03\0\x1e\x01m\x08\x0bmillimeters\x0bcentimeters\x06meters\x0aki\
lometers\x06inches\x04feet\x04yard\x05miles\x04\0\x0bunit-length\x03\0\x20\x01m\x04\
\x05hertz\x09kilohertz\x09megahertz\x09gigahertz\x04\0\x0eunit-frequency\x03\0\"\
\x01m\x09\x06pascal\x0bhectopascal\x0akilopascal\x03bar\x08centibar\x08millibar\x12\
millimeter-mercury\x0cinch-mercury\x03psi\x04\0\x0dunit-pressure\x03\0$\x01m\x03\
\x07decibel\x12decibel-a-weighted\x12decibels-milliwatt\x04\0\x13unit-sound-pres\
sure\x03\0&\x01m\x06\x06liters\x0bmilliliters\x0ccubic-meters\x0acubic-feet\x07g\
allons\x0bfluid-ounce\x04\0\x0bunit-volume\x03\0(\x01m\x02\x15cubic-meters-per-h\
our\x15cubic-feet-per-minute\x04\0\x15unit-volume-flow-rate\x03\0*\x01m\x01\x0ds\
quare-meters\x04\0\x09unit-area\x03\0,\x01m\x06\x05grams\x09kilograms\x0amilligr\
ams\x0amicrograms\x06ounces\x06pounds\x04\0\x09unit-mass\x03\0.\x01m\x01\x1bmicr\
osiemens-per-centimeter\x04\0\x11unit-conductivity\x03\00\x01m\x01\x03lux\x04\0\x0a\
unit-light\x03\02\x01m\x01\x08uv-index\x04\0\x0dunit-uv-index\x03\04\x01m\x01\x0a\
percentage\x04\0\x0funit-percentage\x03\06\x01m\x02\x16watts-per-square-meter\x19\
btus-per-hour-square-foot\x04\0\x10unit-irradiation\x03\08\x01m\x06\x1amicrogram\
s-per-cubic-meter\x1amilligrams-per-cubic-meter\x19micrograms-per-cubic-foot\x15\
parts-per-cubic-meter\x11parts-per-million\x11parts-per-billion\x04\0\x12unit-co\
ncentration\x03\0:\x01m\x09\x13millimeters-per-day\x14millimeters-per-hour\x0ffe\
et-per-second\x0einches-per-day\x11meters-per-second\x0finches-per-hour\x13kilom\
eters-per-hour\x05knots\x0emiles-per-hour\x04\0\x0aunit-speed\x03\0<\x01m\x15\x04\
bits\x08kilobits\x08megabits\x08gigabits\x05bytes\x09kilobytes\x09megabytes\x09g\
igabytes\x09terabytes\x09petabytes\x08exabytes\x0azettabytes\x0ayottabytes\x09ki\
bibytes\x09mebibytes\x09gibibytes\x09tebibytes\x09pebibytes\x09exbibytes\x09zebi\
bytes\x09yobibytes\x04\0\x09unit-data\x03\0>\x01m\x0b\x0fbits-per-second\x13kilo\
bits-per-second\x13megabits-per-second\x13gigabits-per-second\x10bytes-per-secon\
d\x14kilobytes-per-second\x14megabytes-per-second\x14gigabytes-per-second\x14kib\
ibytes-per-second\x14mebibytes-per-second\x14gibibytes-per-second\x04\0\x0eunit-\
data-rate\x03\0@\x01m\x05\x03off\x02on\x08vertical\x0ahorizontal\x04both\x04\0\x0f\
fan-oscillation\x03\0B\x01m\x02\x07forward\x07reverse\x04\0\x0dfan-direction\x03\
\0D\x01m\x0a\x02on\x03off\x04auto\x03low\x06medium\x04high\x06middle\x05focus\x07\
diffuse\x05quiet\x04\0\x09fan-speed\x03\0F\x01m\x08\x03off\x04auto\x04heat\x04co\
ol\x09heat-cool\x08fan-only\x03dry\x03eco\x04\0\x0cclimate-mode\x03\0H\x01m\x06\x07\
unknown\x06locked\x08unlocked\x06jammed\x07locking\x09unlocking\x04\0\x0alock-st\
ate\x03\0J\x01m\x04\x07unknown\x04idle\x07playing\x06paused\x04\0\x0bmedia-state\
\x03\0L\x01m\x06\x04idle\x07opening\x07closing\x07stopped\x04open\x06closed\x04\0\
\x0bcover-state\x03\0N\x01m\x03\x04idle\x07opening\x07closing\x04\0\x0bvalve-sta\
te\x03\0P\x01m\x0a\x08disarmed\x0aarmed-home\x0aarmed-away\x0barmed-night\x0earm\
ed-vacation\x0darmed-unknown\x07pending\x09triggered\x06arming\x09disarming\x04\0\
\x0balarm-state\x03\0R\x01px\x01pu\x01ps\x01p\x7f\x01p\x01\x01p\x03\x01p\x05\x01\
qJ\x07integer\x01x\0\x05float\x01u\0\x06string\x01s\0\x04bool\x01\x7f\0\x05color\
\x01\x01\0\x04date\x01\x03\0\x04time\x01\x05\0\x0cinteger-list\x01\xd4\0\0\x0afl\
oat-list\x01\xd5\0\0\x0bstring-list\x01\xd6\0\0\x0cboolean-list\x01\xd7\0\0\x0ac\
olor-list\x01\xd8\0\0\x09date-list\x01\xd9\0\0\x09time-list\x01\xda\0\0\x07trigg\
er\0\0\x09timestamp\x01x\0\x08duration\x01x\0\x07weekday\x01\x07\0\x05light\0\0\x06\
switch\x01\x7f\0\x06dimmer\x01u\0\x06switch\x01\x7f\0\x0acolor-mode\x01\x09\0\x11\
color-temperature\x01x\0\x06volume\x01u\0\x05muted\x01\x7f\0\x06config\0\0\x0adi\
agnostic\0\0\x05siren\0\0\x06sensor\0\0\x04icon\x01s\0\x11accuracy-decimals\x01x\
\0\x0cdevice-class\x01s\0\x12sensor-state-class\x01\x0b\0\x13unit-apparent-power\
\x01\x0d\0\x0aunit-power\x01\x0f\0\x13unit-reactive-power\x01\x11\0\x0bunit-ener\
gy\x01\x13\0\x15unit-electric-current\x01\x15\0\x17unit-electric-potential\x01\x17\
\0\x0bunit-degree\x01\x19\0\x0dunit-currency\x01\x1b\0\x10unit-temperature\x01\x1d\
\0\x09unit-time\x01\x1f\0\x0bunit-length\x01!\0\x0eunit-frequency\x01#\0\x0dunit\
-pressure\x01%\0\x13unit-sound-pressure\x01'\0\x0bunit-volume\x01)\0\x15unit-vol\
ume-flow-rate\x01+\0\x09unit-area\x01-\0\x09unit-mass\x01/\0\x11unit-conductivit\
y\x011\0\x0aunit-light\x013\0\x0dunit-uv-index\x015\0\x0funit-percentage\x017\0\x10\
unit-irradiation\x019\0\x12unit-concentration\x01;\0\x0aunit-speed\x01=\0\x09uni\
t-data\x01?\0\x0eunit-data-rate\x01\xc1\0\0\x0ffan-oscillation\x01\xc3\0\0\x0dfa\
n-direction\x01\xc5\0\0\x09fan-speed\x01\xc7\0\0\x0cclimate-mode\x01\xc9\0\0\x0a\
lock-state\x01\xcb\0\0\x0bmedia-state\x01\xcd\0\0\x05cover\0\0\x0bcover-state\x01\
\xcf\0\0\x08position\x01u\0\x04tilt\x01u\0\x05valve\0\0\x0bvalve-state\x01\xd1\0\
\0\x0balarm-state\x01\xd3\0\0\x04\0\x09component\x03\0[\x03\0\x19igloo:lib/compo\
nent@0.1.0\x05\x05\x02\x03\0\0\x09entity-id\x02\x03\0\0\x0centity-index\x02\x03\0\
\x02\x09component\x01B\x11\x02\x03\x02\x01\x06\x04\0\x09entity-id\x03\0\0\x02\x03\
\x02\x01\x07\x04\0\x0centity-index\x03\0\x02\x02\x03\x02\x01\x08\x04\0\x09compon\
ent\x03\0\x04\x01m\x01\x0einvalid-entity\x04\0\x0centity-error\x03\0\x06\x04\0\x06\
entity\x03\x01\x01h\x08\x01@\x01\x04self\x09\0\x01\x04\0\x11[method]entity.id\x01\
\x0a\x01@\x01\x04self\x09\0\x03\x04\0\x14[method]entity.index\x01\x0b\x01j\0\x01\
\x07\x01C\x02\x04self\x09\x09component\x05\0\x0c\x04\0\x1c[method]entity.put-com\
ponent\x01\x0d\x03\0\x16igloo:lib/entity@0.1.0\x05\x09\x02\x03\0\0\x09device-id\x02\
\x03\0\x03\x06entity\x01B(\x02\x03\x02\x01\x0a\x04\0\x09device-id\x03\0\0\x02\x03\
\x02\x01\x06\x04\0\x09entity-id\x03\0\x02\x02\x03\x02\x01\x08\x04\0\x09component\
\x03\0\x04\x02\x03\x02\x01\x0b\x04\0\x06entity\x03\0\x06\x01m\x01\x0einvalid-dev\
ice\x04\0\x0cdevice-error\x03\0\x08\x04\0\x06device\x03\x01\x01i\x0a\x01@\x01\x04\
names\0\x0b\x04\0\x13[constructor]device\x01\x0c\x01h\x0a\x01j\x01\x01\x01\x09\x01\
@\x01\x04self\x0d\0\x0e\x04\0\x11[method]device.id\x01\x0f\x01ks\x01j\x01\x10\x01\
\x09\x01C\x02\x04self\x0d\x03keys\0\x11\x04\0\x16[method]device.get-cfg\x01\x12\x01\
j\0\x01\x09\x01C\x03\x04self\x0d\x03keys\x05values\0\x13\x04\0\x17[method]device\
.save-cfg\x01\x14\x01C\x02\x04self\x0d\x03keys\0\x13\x04\0\x19[method]device.rem\
ove-cfg\x01\x15\x01i\x07\x01j\x01\x16\x01\x09\x01C\x02\x04self\x0d\x02id\x03\0\x17\
\x04\0\x1e[method]device.register-entity\x01\x18\x01p\x0b\x01@\0\0\x19\x04\0\x0b\
get-devices\x01\x1a\x01C\x01\x03keys\0\x10\x04\0\x07get-cfg\x01\x1b\x01C\x02\x03\
keys\x05values\x01\0\x04\0\x08save-cfg\x01\x1c\x01C\x01\x03keys\x01\0\x04\0\x0ar\
emove-cfg\x01\x1d\x03\0%igloo:lib/extension-sp-to-igloo@0.1.0\x05\x0c\x01B\x0a\x01\
o\x02ss\x01p\0\x01@\0\0\x01\x04\0\x0fget-environment\x01\x02\x01ps\x01@\0\0\x03\x04\
\0\x0dget-arguments\x01\x04\x01ks\x01@\0\0\x05\x04\0\x0fget-initial-cwd\x01\x06\x03\
\0(wasi:cli/environment@0.3.0-rc-2026-01-06\x05\x0d\x01B\x03\x01j\0\0\x01@\x01\x06\
status\0\x01\0\x04\0\x04exit\x01\x01\x03\0!wasi:cli/exit@0.3.0-rc-2026-01-06\x05\
\x0e\x01B\x02\x01m\x03\x02io\x15illegal-byte-sequence\x04pipe\x04\0\x0aerror-cod\
e\x03\0\0\x03\0\"wasi:cli/types@0.3.0-rc-2026-01-06\x05\x0f\x02\x03\0\x07\x0aerr\
or-code\x01B\x08\x02\x03\x02\x01\x10\x04\0\x0aerror-code\x03\0\0\x01f\x01}\x01j\0\
\x01\x01\x01e\x01\x03\x01o\x02\x02\x04\x01@\0\0\x05\x04\0\x0fread-via-stream\x01\
\x06\x03\0\"wasi:cli/stdin@0.3.0-rc-2026-01-06\x05\x11\x01B\x06\x02\x03\x02\x01\x10\
\x04\0\x0aerror-code\x03\0\0\x01f\x01}\x01j\0\x01\x01\x01C\x01\x04data\x02\0\x03\
\x04\0\x10write-via-stream\x01\x04\x03\0#wasi:cli/stdout@0.3.0-rc-2026-01-06\x05\
\x12\x01B\x06\x02\x03\x02\x01\x10\x04\0\x0aerror-code\x03\0\0\x01f\x01}\x01j\0\x01\
\x01\x01C\x01\x04data\x02\0\x03\x04\0\x10write-via-stream\x01\x04\x03\0#wasi:cli\
/stderr@0.3.0-rc-2026-01-06\x05\x13\x01B\x01\x04\0\x0eterminal-input\x03\x01\x03\
\0+wasi:cli/terminal-input@0.3.0-rc-2026-01-06\x05\x14\x01B\x01\x04\0\x0ftermina\
l-output\x03\x01\x03\0,wasi:cli/terminal-output@0.3.0-rc-2026-01-06\x05\x15\x02\x03\
\0\x0b\x0eterminal-input\x01B\x06\x02\x03\x02\x01\x16\x04\0\x0eterminal-input\x03\
\0\0\x01i\x01\x01k\x02\x01@\0\0\x03\x04\0\x12get-terminal-stdin\x01\x04\x03\0+wa\
si:cli/terminal-stdin@0.3.0-rc-2026-01-06\x05\x17\x02\x03\0\x0c\x0fterminal-outp\
ut\x01B\x06\x02\x03\x02\x01\x18\x04\0\x0fterminal-output\x03\0\0\x01i\x01\x01k\x02\
\x01@\0\0\x03\x04\0\x13get-terminal-stdout\x01\x04\x03\0,wasi:cli/terminal-stdou\
t@0.3.0-rc-2026-01-06\x05\x19\x01B\x06\x02\x03\x02\x01\x18\x04\0\x0fterminal-out\
put\x03\0\0\x01i\x01\x01k\x02\x01@\0\0\x03\x04\0\x13get-terminal-stderr\x01\x04\x03\
\0,wasi:cli/terminal-stderr@0.3.0-rc-2026-01-06\x05\x1a\x01B\x02\x01w\x04\0\x08d\
uration\x03\0\0\x03\0%wasi:clocks/types@0.3.0-rc-2026-01-06\x05\x1b\x02\x03\0\x10\
\x08duration\x01B\x0c\x02\x03\x02\x01\x1c\x04\0\x08duration\x03\0\0\x01w\x04\0\x04\
mark\x03\0\x02\x01@\0\0\x03\x04\0\x03now\x01\x04\x01@\0\0\x01\x04\0\x0eget-resol\
ution\x01\x05\x01C\x01\x04when\x03\x01\0\x04\0\x0await-until\x01\x06\x01C\x01\x08\
how-long\x01\x01\0\x04\0\x08wait-for\x01\x07\x03\0/wasi:clocks/monotonic-clock@0\
.3.0-rc-2026-01-06\x05\x1d\x01B\x08\x02\x03\x02\x01\x1c\x04\0\x08duration\x03\0\0\
\x01r\x02\x07secondsx\x0bnanosecondsy\x04\0\x07instant\x03\0\x02\x01@\0\0\x03\x04\
\0\x03now\x01\x04\x01@\0\0\x01\x04\0\x0eget-resolution\x01\x05\x03\0,wasi:clocks\
/system-clock@0.3.0-rc-2026-01-06\x05\x1e\x02\x03\0\x12\x07instant\x01BY\x02\x03\
\x02\x01\x1f\x04\0\x07instant\x03\0\0\x01w\x04\0\x08filesize\x03\0\x02\x01m\x08\x07\
unknown\x0cblock-device\x10character-device\x09directory\x04fifo\x0dsymbolic-lin\
k\x0cregular-file\x06socket\x04\0\x0fdescriptor-type\x03\0\x04\x01n\x06\x04read\x05\
write\x13file-integrity-sync\x13data-integrity-sync\x14requested-write-sync\x10m\
utate-directory\x04\0\x10descriptor-flags\x03\0\x06\x01n\x01\x0esymlink-follow\x04\
\0\x0apath-flags\x03\0\x08\x01n\x04\x06create\x09directory\x09exclusive\x08trunc\
ate\x04\0\x0aopen-flags\x03\0\x0a\x01w\x04\0\x0alink-count\x03\0\x0c\x01k\x01\x01\
r\x06\x04type\x05\x0alink-count\x0d\x04size\x03\x15data-access-timestamp\x0e\x1b\
data-modification-timestamp\x0e\x17status-change-timestamp\x0e\x04\0\x0fdescript\
or-stat\x03\0\x0f\x01q\x03\x09no-change\0\0\x03now\0\0\x09timestamp\x01\x01\0\x04\
\0\x0dnew-timestamp\x03\0\x11\x01r\x02\x04type\x05\x04names\x04\0\x0fdirectory-e\
ntry\x03\0\x13\x01m$\x06access\x07already\x0ebad-descriptor\x04busy\x08deadlock\x05\
quota\x05exist\x0efile-too-large\x15illegal-byte-sequence\x0bin-progress\x0binte\
rrupted\x07invalid\x02io\x0cis-directory\x04loop\x0etoo-many-links\x0cmessage-si\
ze\x0dname-too-long\x09no-device\x08no-entry\x07no-lock\x13insufficient-memory\x12\
insufficient-space\x0dnot-directory\x09not-empty\x0fnot-recoverable\x0bunsupport\
ed\x06no-tty\x0eno-such-device\x08overflow\x0dnot-permitted\x04pipe\x09read-only\
\x0cinvalid-seek\x0etext-file-busy\x0ccross-device\x04\0\x0aerror-code\x03\0\x15\
\x01m\x06\x06normal\x0asequential\x06random\x09will-need\x09dont-need\x08no-reus\
e\x04\0\x06advice\x03\0\x17\x01r\x02\x05lowerw\x05upperw\x04\0\x13metadata-hash-\
value\x03\0\x19\x04\0\x0adescriptor\x03\x01\x01h\x1b\x01f\x01}\x01j\0\x01\x16\x01\
e\x01\x1e\x01o\x02\x1d\x1f\x01@\x02\x04self\x1c\x06offset\x03\0\x20\x04\0\"[meth\
od]descriptor.read-via-stream\x01!\x01C\x03\x04self\x1c\x04data\x1d\x06offset\x03\
\0\x1e\x04\0#[method]descriptor.write-via-stream\x01\"\x01C\x02\x04self\x1c\x04d\
ata\x1d\0\x1e\x04\0$[method]descriptor.append-via-stream\x01#\x01C\x04\x04self\x1c\
\x06offset\x03\x06length\x03\x06advice\x18\0\x1e\x04\0\x19[method]descriptor.adv\
ise\x01$\x01C\x01\x04self\x1c\0\x1e\x04\0\x1c[method]descriptor.sync-data\x01%\x01\
j\x01\x07\x01\x16\x01C\x01\x04self\x1c\0&\x04\0\x1c[method]descriptor.get-flags\x01\
'\x01j\x01\x05\x01\x16\x01C\x01\x04self\x1c\0(\x04\0\x1b[method]descriptor.get-t\
ype\x01)\x01C\x02\x04self\x1c\x04size\x03\0\x1e\x04\0\x1b[method]descriptor.set-\
size\x01*\x01C\x03\x04self\x1c\x15data-access-timestamp\x12\x1bdata-modification\
-timestamp\x12\0\x1e\x04\0\x1c[method]descriptor.set-times\x01+\x01f\x01\x14\x01\
o\x02,\x1f\x01C\x01\x04self\x1c\0-\x04\0![method]descriptor.read-directory\x01.\x04\
\0\x17[method]descriptor.sync\x01%\x01C\x02\x04self\x1c\x04paths\0\x1e\x04\0&[me\
thod]descriptor.create-directory-at\x01/\x01j\x01\x10\x01\x16\x01C\x01\x04self\x1c\
\00\x04\0\x17[method]descriptor.stat\x011\x01C\x03\x04self\x1c\x0apath-flags\x09\
\x04paths\00\x04\0\x1a[method]descriptor.stat-at\x012\x01C\x05\x04self\x1c\x0apa\
th-flags\x09\x04paths\x15data-access-timestamp\x12\x1bdata-modification-timestam\
p\x12\0\x1e\x04\0\x1f[method]descriptor.set-times-at\x013\x01C\x05\x04self\x1c\x0e\
old-path-flags\x09\x08old-paths\x0enew-descriptor\x1c\x08new-paths\0\x1e\x04\0\x1a\
[method]descriptor.link-at\x014\x01i\x1b\x01j\x015\x01\x16\x01C\x05\x04self\x1c\x0a\
path-flags\x09\x04paths\x0aopen-flags\x0b\x05flags\x07\06\x04\0\x1a[method]descr\
iptor.open-at\x017\x01j\x01s\x01\x16\x01C\x02\x04self\x1c\x04paths\08\x04\0\x1e[\
method]descriptor.readlink-at\x019\x04\0&[method]descriptor.remove-directory-at\x01\
/\x01C\x04\x04self\x1c\x08old-paths\x0enew-descriptor\x1c\x08new-paths\0\x1e\x04\
\0\x1c[method]descriptor.rename-at\x01:\x01C\x03\x04self\x1c\x08old-paths\x08new\
-paths\0\x1e\x04\0\x1d[method]descriptor.symlink-at\x01;\x04\0![method]descripto\
r.unlink-file-at\x01/\x01C\x02\x04self\x1c\x05other\x1c\0\x7f\x04\0![method]desc\
riptor.is-same-object\x01<\x01j\x01\x1a\x01\x16\x01C\x01\x04self\x1c\0=\x04\0\x20\
[method]descriptor.metadata-hash\x01>\x01C\x03\x04self\x1c\x0apath-flags\x09\x04\
paths\0=\x04\0#[method]descriptor.metadata-hash-at\x01?\x03\0)wasi:filesystem/ty\
pes@0.3.0-rc-2026-01-06\x05\x20\x02\x03\0\x13\x0adescriptor\x01B\x07\x02\x03\x02\
\x01!\x04\0\x0adescriptor\x03\0\0\x01i\x01\x01o\x02\x02s\x01p\x03\x01@\0\0\x04\x04\
\0\x0fget-directories\x01\x05\x03\0,wasi:filesystem/preopens@0.3.0-rc-2026-01-06\
\x05\"\x01Bq\x02\x03\x02\x01\x1c\x04\0\x08duration\x03\0\0\x01m\x0e\x07unknown\x0d\
access-denied\x0dnot-supported\x10invalid-argument\x0dout-of-memory\x07timeout\x0d\
invalid-state\x14address-not-bindable\x0eaddress-in-use\x12remote-unreachable\x12\
connection-refused\x10connection-reset\x12connection-aborted\x12datagram-too-lar\
ge\x04\0\x0aerror-code\x03\0\x02\x01m\x02\x04ipv4\x04ipv6\x04\0\x11ip-address-fa\
mily\x03\0\x04\x01o\x04}}}}\x04\0\x0cipv4-address\x03\0\x06\x01o\x08{{{{{{{{\x04\
\0\x0cipv6-address\x03\0\x08\x01q\x02\x04ipv4\x01\x07\0\x04ipv6\x01\x09\0\x04\0\x0a\
ip-address\x03\0\x0a\x01r\x02\x04port{\x07address\x07\x04\0\x13ipv4-socket-addre\
ss\x03\0\x0c\x01r\x04\x04port{\x09flow-infoy\x07address\x09\x08scope-idy\x04\0\x13\
ipv6-socket-address\x03\0\x0e\x01q\x02\x04ipv4\x01\x0d\0\x04ipv6\x01\x0f\0\x04\0\
\x11ip-socket-address\x03\0\x10\x04\0\x0atcp-socket\x03\x01\x04\0\x0audp-socket\x03\
\x01\x01i\x12\x01j\x01\x14\x01\x03\x01@\x01\x0eaddress-family\x05\0\x15\x04\0\x19\
[static]tcp-socket.create\x01\x16\x01h\x12\x01j\0\x01\x03\x01@\x02\x04self\x17\x0d\
local-address\x11\0\x18\x04\0\x17[method]tcp-socket.bind\x01\x19\x01C\x02\x04sel\
f\x17\x0eremote-address\x11\0\x18\x04\0\x1a[method]tcp-socket.connect\x01\x1a\x01\
f\x01\x14\x01j\x01\x1b\x01\x03\x01@\x01\x04self\x17\0\x1c\x04\0\x19[method]tcp-s\
ocket.listen\x01\x1d\x01f\x01}\x01C\x02\x04self\x17\x04data\x1e\0\x18\x04\0\x17[\
method]tcp-socket.send\x01\x1f\x01e\x01\x18\x01o\x02\x1e\x20\x01@\x01\x04self\x17\
\0!\x04\0\x1a[method]tcp-socket.receive\x01\"\x01j\x01\x11\x01\x03\x01@\x01\x04s\
elf\x17\0#\x04\0$[method]tcp-socket.get-local-address\x01$\x04\0%[method]tcp-soc\
ket.get-remote-address\x01$\x01@\x01\x04self\x17\0\x7f\x04\0#[method]tcp-socket.\
get-is-listening\x01%\x01@\x01\x04self\x17\0\x05\x04\0%[method]tcp-socket.get-ad\
dress-family\x01&\x01@\x02\x04self\x17\x05valuew\0\x18\x04\0*[method]tcp-socket.\
set-listen-backlog-size\x01'\x01j\x01\x7f\x01\x03\x01@\x01\x04self\x17\0(\x04\0)\
[method]tcp-socket.get-keep-alive-enabled\x01)\x01@\x02\x04self\x17\x05value\x7f\
\0\x18\x04\0)[method]tcp-socket.set-keep-alive-enabled\x01*\x01j\x01\x01\x01\x03\
\x01@\x01\x04self\x17\0+\x04\0+[method]tcp-socket.get-keep-alive-idle-time\x01,\x01\
@\x02\x04self\x17\x05value\x01\0\x18\x04\0+[method]tcp-socket.set-keep-alive-idl\
e-time\x01-\x04\0*[method]tcp-socket.get-keep-alive-interval\x01,\x04\0*[method]\
tcp-socket.set-keep-alive-interval\x01-\x01j\x01y\x01\x03\x01@\x01\x04self\x17\0\
.\x04\0'[method]tcp-socket.get-keep-alive-count\x01/\x01@\x02\x04self\x17\x05val\
uey\0\x18\x04\0'[method]tcp-socket.set-keep-alive-count\x010\x01j\x01}\x01\x03\x01\
@\x01\x04self\x17\01\x04\0\x20[method]tcp-socket.get-hop-limit\x012\x01@\x02\x04\
self\x17\x05value}\0\x18\x04\0\x20[method]tcp-socket.set-hop-limit\x013\x01j\x01\
w\x01\x03\x01@\x01\x04self\x17\04\x04\0*[method]tcp-socket.get-receive-buffer-si\
ze\x015\x04\0*[method]tcp-socket.set-receive-buffer-size\x01'\x04\0'[method]tcp-\
socket.get-send-buffer-size\x015\x04\0'[method]tcp-socket.set-send-buffer-size\x01\
'\x01i\x13\x01j\x016\x01\x03\x01@\x01\x0eaddress-family\x05\07\x04\0\x19[static]\
udp-socket.create\x018\x01h\x13\x01@\x02\x04self9\x0dlocal-address\x11\0\x18\x04\
\0\x17[method]udp-socket.bind\x01:\x01@\x02\x04self9\x0eremote-address\x11\0\x18\
\x04\0\x1a[method]udp-socket.connect\x01;\x01@\x01\x04self9\0\x18\x04\0\x1d[meth\
od]udp-socket.disconnect\x01<\x01p}\x01k\x11\x01C\x03\x04self9\x04data=\x0eremot\
e-address>\0\x18\x04\0\x17[method]udp-socket.send\x01?\x01o\x02=\x11\x01j\x01\xc0\
\0\x01\x03\x01C\x01\x04self9\0\xc1\0\x04\0\x1a[method]udp-socket.receive\x01B\x01\
@\x01\x04self9\0#\x04\0$[method]udp-socket.get-local-address\x01C\x04\0%[method]\
udp-socket.get-remote-address\x01C\x01@\x01\x04self9\0\x05\x04\0%[method]udp-soc\
ket.get-address-family\x01D\x01@\x01\x04self9\01\x04\0([method]udp-socket.get-un\
icast-hop-limit\x01E\x01@\x02\x04self9\x05value}\0\x18\x04\0([method]udp-socket.\
set-unicast-hop-limit\x01F\x01@\x01\x04self9\04\x04\0*[method]udp-socket.get-rec\
eive-buffer-size\x01G\x01@\x02\x04self9\x05valuew\0\x18\x04\0*[method]udp-socket\
.set-receive-buffer-size\x01H\x04\0'[method]udp-socket.get-send-buffer-size\x01G\
\x04\0'[method]udp-socket.set-send-buffer-size\x01H\x03\0&wasi:sockets/types@0.3\
.0-rc-2026-01-06\x05#\x02\x03\0\x15\x0aip-address\x01B\x08\x02\x03\x02\x01$\x04\0\
\x0aip-address\x03\0\0\x01m\x06\x07unknown\x0daccess-denied\x10invalid-argument\x11\
name-unresolvable\x1atemporary-resolver-failure\x1apermanent-resolver-failure\x04\
\0\x0aerror-code\x03\0\x02\x01p\x01\x01j\x01\x04\x01\x03\x01C\x01\x04names\0\x05\
\x04\0\x11resolve-addresses\x01\x06\x03\0/wasi:sockets/ip-name-lookup@0.3.0-rc-2\
026-01-06\x05%\x01B\x05\x01p}\x01@\x01\x03lenw\0\0\x04\0\x10get-random-bytes\x01\
\x01\x01@\0\0w\x04\0\x0eget-random-u64\x01\x02\x03\0&wasi:random/random@0.3.0-rc\
-2026-01-06\x05&\x01B\x05\x01p}\x01@\x01\x03lenw\0\0\x04\0\x19get-insecure-rando\
m-bytes\x01\x01\x01@\0\0w\x04\0\x17get-insecure-random-u64\x01\x02\x03\0(wasi:ra\
ndom/insecure@0.3.0-rc-2026-01-06\x05'\x01B\x03\x01o\x02ww\x01@\0\0\0\x04\0\x11g\
et-insecure-seed\x01\x01\x03\0-wasi:random/insecure-seed@0.3.0-rc-2026-01-06\x05\
(\x01B\x0d\x02\x03\x02\x01\x0a\x04\0\x09device-id\x03\0\0\x02\x03\x02\x01\x07\x04\
\0\x0centity-index\x03\0\x02\x02\x03\x02\x01\x08\x04\0\x09component\x03\0\x04\x01\
j\0\x01s\x01C\x03\x09device-id\x01\x0centity-index\x03\x09component\x05\0\x06\x04\
\0\x0dput-component\x01\x07\x01C\x01\x09device-id\x01\0\x06\x04\0\x0ddelete-devi\
ce\x01\x08\x01C\x02\x04names\x06paramss\0\x06\x04\0\x06custom\x01\x09\x04\0$iglo\
o:lib/core-to-extension-sp@0.1.0\x05)\x01B\x03\x01j\0\0\x01C\0\0\0\x04\0\x03run\x01\
\x01\x04\0\x20wasi:cli/run@0.3.0-rc-2026-01-06\x05*\x04\0\x1cigloo:lib/extension\
-sp@0.1.0\x04\0\x0b\x12\x01\0\x0cextension-sp\x03\0\0\0G\x09producers\x01\x0cpro\
cessed-by\x02\x0dwit-component\x070.244.0\x10wit-bindgen-rust\x060.52.0";

#[inline(never)]
#[doc(hidden)]
pub fn __link_custom_section_describing_imports() {
  wit_bindgen::rt::maybe_link_cabi_realloc();
}

