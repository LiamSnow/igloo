// Generated by `wit-bindgen` 0.52.0. DO NOT EDIT!
// Options used:
//   * additional derives ["PartialEq", "serde::Serialize", "serde::Deserialize"]
//   * with "igloo:lib/id@0.1.0" = "crate::generated::shared::igloo::lib::id"
//   * with "igloo:lib/compound@0.1.0" = "crate::generated::shared::igloo::lib::compound"
//   * with "igloo:lib/component@0.1.0" = "crate::generated::shared::igloo::lib::component"
//   * generate_unused_types
//   * async: all
#[allow(unfulfilled_lint_expectations, unused_imports)]
use crate::generated::shared::igloo::lib::id as __with_name0;
#[allow(unfulfilled_lint_expectations, unused_imports)]
use crate::generated::shared::igloo::lib::compound as __with_name1;
#[allow(unfulfilled_lint_expectations, unused_imports)]
use crate::generated::shared::igloo::lib::component as __with_name2;
#[allow(dead_code, clippy::all)]
pub mod igloo {
  pub mod lib {

    #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
    pub mod core_to_extension_sp {
      #[used]
      #[doc(hidden)]
      static __FORCE_SECTION_REF: fn() =
      super::super::super::__link_custom_section_describing_imports;
      
      use super::super::super::_rt;
      pub type DeviceId = super::super::super::__with_name0::DeviceId;
      pub type EntityIndex = super::super::super::__with_name0::EntityIndex;
      pub type Component = super::super::super::__with_name2::Component;
      #[allow(unused_unsafe, clippy::all)]
      /// Igloo core request to put a component on the given device and entity.
      /// The change will not be applied to the device tree until the extension
      /// confirms by sending a `put-component` back
      /// (usually after response from the physical hardware device)
      ///
      /// The extension _should_ hint to the core whether the operation will
      /// succeed by returning either `Ok` or `Err`
      #[allow(async_fn_in_trait)]
      pub async fn put_component(device_id: DeviceId,entity_index: EntityIndex,component: Component,) -> Result<(),_rt::String>{
        unsafe {

          #[derive(Copy, Clone)]
          struct ParamsLower(
          *mut u8, 
          );
          unsafe impl Send for ParamsLower {}
          

          use wit_bindgen::rt::async_support::Subtask as _Subtask;
          struct _MySubtask<'a> { _unused: core::marker::PhantomData<&'a ()> }
          #[allow(unused_parens)]
          unsafe impl<'a> _Subtask for _MySubtask<'a> {
            
            type Params = (DeviceId, EntityIndex, Component, );
            type Results = Result<(),_rt::String>;
            type ParamsLower = ParamsLower;
            fn abi_layout(&mut self) -> ::core::alloc::Layout {
              unsafe {
                ::core::alloc::Layout::from_size_align_unchecked((56+2*::core::mem::size_of::<*const u8>()), 8)
              }
            }
            
            fn results_offset(&mut self) -> usize { 48 }

            unsafe fn call_import(&mut self, _params: Self::ParamsLower, _results: *mut u8) -> u32 {
              
              #[cfg(target_arch = "wasm32")]
              #[link(wasm_import_module = "igloo:lib/core-to-extension-sp@0.1.0")]
              unsafe extern "C" {
                #[link_name = "[async-lower]put-component"]
                fn call(_: *mut u8, _: *mut u8, ) -> i32;
              }

              #[cfg(not(target_arch = "wasm32"))]
              unsafe extern "C" fn call(_: *mut u8, _: *mut u8, ) -> i32 { unreachable!() }
              
              unsafe { call(_params.0,_results) as u32 }
            }
            
            unsafe fn params_dealloc_lists(&mut self, _params: Self::ParamsLower) {
              unsafe { let l0 = i32::from(*_params.0.add(16).cast::<u8>());
              match l0 {
                0 => (),
                1 => (),
                2 => {
                  let l1 = *_params.0.add(24).cast::<*mut u8>();
                  let l2 = *_params.0.add(24+1*::core::mem::size_of::<*const u8>()).cast::<usize>();
                  _rt::cabi_dealloc(l1, l2, 1);
                },
                3 => (),
                4 => (),
                5 => (),
                6 => (),
                7 => {
                  let l3 = *_params.0.add(24).cast::<*mut u8>();
                  let l4 = *_params.0.add(24+1*::core::mem::size_of::<*const u8>()).cast::<usize>();
                  let base5 = l3;
                  let len5 = l4;
                  _rt::cabi_dealloc(base5, len5 * 8, 8);
                },
                8 => {
                  let l6 = *_params.0.add(24).cast::<*mut u8>();
                  let l7 = *_params.0.add(24+1*::core::mem::size_of::<*const u8>()).cast::<usize>();
                  let base8 = l6;
                  let len8 = l7;
                  _rt::cabi_dealloc(base8, len8 * 8, 8);
                },
                9 => {
                  let l9 = *_params.0.add(24).cast::<*mut u8>();
                  let l10 = *_params.0.add(24+1*::core::mem::size_of::<*const u8>()).cast::<usize>();
                  let base13 = l9;
                  let len13 = l10;
                  for i in 0..len13 {
                    let base = base13.add(i * (2*::core::mem::size_of::<*const u8>()));
                    {
                      let l11 = *base.add(0).cast::<*mut u8>();
                      let l12 = *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
                      _rt::cabi_dealloc(l11, l12, 1);
                    }
                  }
                  _rt::cabi_dealloc(base13, len13 * (2*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>());
                },
                10 => {
                  let l14 = *_params.0.add(24).cast::<*mut u8>();
                  let l15 = *_params.0.add(24+1*::core::mem::size_of::<*const u8>()).cast::<usize>();
                  let base16 = l14;
                  let len16 = l15;
                  _rt::cabi_dealloc(base16, len16 * 1, 1);
                },
                11 => {
                  let l17 = *_params.0.add(24).cast::<*mut u8>();
                  let l18 = *_params.0.add(24+1*::core::mem::size_of::<*const u8>()).cast::<usize>();
                  let base19 = l17;
                  let len19 = l18;
                  _rt::cabi_dealloc(base19, len19 * 24, 8);
                },
                12 => {
                  let l20 = *_params.0.add(24).cast::<*mut u8>();
                  let l21 = *_params.0.add(24+1*::core::mem::size_of::<*const u8>()).cast::<usize>();
                  let base22 = l20;
                  let len22 = l21;
                  _rt::cabi_dealloc(base22, len22 * 4, 2);
                },
                13 => {
                  let l23 = *_params.0.add(24).cast::<*mut u8>();
                  let l24 = *_params.0.add(24+1*::core::mem::size_of::<*const u8>()).cast::<usize>();
                  let base25 = l23;
                  let len25 = l24;
                  _rt::cabi_dealloc(base25, len25 * 3, 1);
                },
                14 => (),
                15 => (),
                16 => (),
                17 => (),
                18 => (),
                19 => (),
                20 => (),
                21 => (),
                22 => (),
                23 => (),
                24 => (),
                25 => (),
                26 => (),
                27 => (),
                28 => (),
                29 => (),
                30 => {
                  let l26 = *_params.0.add(24).cast::<*mut u8>();
                  let l27 = *_params.0.add(24+1*::core::mem::size_of::<*const u8>()).cast::<usize>();
                  _rt::cabi_dealloc(l26, l27, 1);
                },
                31 => (),
                32 => {
                  let l28 = *_params.0.add(24).cast::<*mut u8>();
                  let l29 = *_params.0.add(24+1*::core::mem::size_of::<*const u8>()).cast::<usize>();
                  _rt::cabi_dealloc(l28, l29, 1);
                },
                33 => (),
                34 => (),
                35 => (),
                36 => (),
                37 => (),
                38 => (),
                39 => (),
                40 => (),
                41 => (),
                42 => (),
                43 => (),
                44 => (),
                45 => (),
                46 => (),
                47 => (),
                48 => (),
                49 => (),
                50 => (),
                51 => (),
                52 => (),
                53 => (),
                54 => (),
                55 => (),
                56 => (),
                57 => (),
                58 => (),
                59 => (),
                60 => (),
                61 => (),
                62 => (),
                63 => (),
                64 => (),
                65 => (),
                66 => (),
                67 => (),
                68 => (),
                69 => (),
                70 => (),
                71 => (),
                72 => (),
                _ => (),
              }
            }
          }
          unsafe fn params_dealloc_lists_and_own(&mut self, _params: Self::ParamsLower) {
            unsafe { let l0 = i32::from(*_params.0.add(16).cast::<u8>());
            match l0 {
              0 => (),
              1 => (),
              2 => {
                let l1 = *_params.0.add(24).cast::<*mut u8>();
                let l2 = *_params.0.add(24+1*::core::mem::size_of::<*const u8>()).cast::<usize>();
                _rt::cabi_dealloc(l1, l2, 1);
              },
              3 => (),
              4 => (),
              5 => (),
              6 => (),
              7 => {
                let l3 = *_params.0.add(24).cast::<*mut u8>();
                let l4 = *_params.0.add(24+1*::core::mem::size_of::<*const u8>()).cast::<usize>();
                let base5 = l3;
                let len5 = l4;
                _rt::cabi_dealloc(base5, len5 * 8, 8);
              },
              8 => {
                let l6 = *_params.0.add(24).cast::<*mut u8>();
                let l7 = *_params.0.add(24+1*::core::mem::size_of::<*const u8>()).cast::<usize>();
                let base8 = l6;
                let len8 = l7;
                _rt::cabi_dealloc(base8, len8 * 8, 8);
              },
              9 => {
                let l9 = *_params.0.add(24).cast::<*mut u8>();
                let l10 = *_params.0.add(24+1*::core::mem::size_of::<*const u8>()).cast::<usize>();
                let base13 = l9;
                let len13 = l10;
                for i in 0..len13 {
                  let base = base13.add(i * (2*::core::mem::size_of::<*const u8>()));
                  {
                    let l11 = *base.add(0).cast::<*mut u8>();
                    let l12 = *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
                    _rt::cabi_dealloc(l11, l12, 1);
                  }
                }
                _rt::cabi_dealloc(base13, len13 * (2*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>());
              },
              10 => {
                let l14 = *_params.0.add(24).cast::<*mut u8>();
                let l15 = *_params.0.add(24+1*::core::mem::size_of::<*const u8>()).cast::<usize>();
                let base16 = l14;
                let len16 = l15;
                _rt::cabi_dealloc(base16, len16 * 1, 1);
              },
              11 => {
                let l17 = *_params.0.add(24).cast::<*mut u8>();
                let l18 = *_params.0.add(24+1*::core::mem::size_of::<*const u8>()).cast::<usize>();
                let base19 = l17;
                let len19 = l18;
                _rt::cabi_dealloc(base19, len19 * 24, 8);
              },
              12 => {
                let l20 = *_params.0.add(24).cast::<*mut u8>();
                let l21 = *_params.0.add(24+1*::core::mem::size_of::<*const u8>()).cast::<usize>();
                let base22 = l20;
                let len22 = l21;
                _rt::cabi_dealloc(base22, len22 * 4, 2);
              },
              13 => {
                let l23 = *_params.0.add(24).cast::<*mut u8>();
                let l24 = *_params.0.add(24+1*::core::mem::size_of::<*const u8>()).cast::<usize>();
                let base25 = l23;
                let len25 = l24;
                _rt::cabi_dealloc(base25, len25 * 3, 1);
              },
              14 => (),
              15 => (),
              16 => (),
              17 => (),
              18 => (),
              19 => (),
              20 => (),
              21 => (),
              22 => (),
              23 => (),
              24 => (),
              25 => (),
              26 => (),
              27 => (),
              28 => (),
              29 => (),
              30 => {
                let l26 = *_params.0.add(24).cast::<*mut u8>();
                let l27 = *_params.0.add(24+1*::core::mem::size_of::<*const u8>()).cast::<usize>();
                _rt::cabi_dealloc(l26, l27, 1);
              },
              31 => (),
              32 => {
                let l28 = *_params.0.add(24).cast::<*mut u8>();
                let l29 = *_params.0.add(24+1*::core::mem::size_of::<*const u8>()).cast::<usize>();
                _rt::cabi_dealloc(l28, l29, 1);
              },
              33 => (),
              34 => (),
              35 => (),
              36 => (),
              37 => (),
              38 => (),
              39 => (),
              40 => (),
              41 => (),
              42 => (),
              43 => (),
              44 => (),
              45 => (),
              46 => (),
              47 => (),
              48 => (),
              49 => (),
              50 => (),
              51 => (),
              52 => (),
              53 => (),
              54 => (),
              55 => (),
              56 => (),
              57 => (),
              58 => (),
              59 => (),
              60 => (),
              61 => (),
              62 => (),
              63 => (),
              64 => (),
              65 => (),
              66 => (),
              67 => (),
              68 => (),
              69 => (),
              70 => (),
              71 => (),
              72 => (),
              _ => (),
            }
          }
        }
        unsafe fn params_lower(&mut self, (_lower0, _lower1, _lower2,): Self::Params, _ptr: *mut u8) -> Self::ParamsLower {
          let _param_ptr = unsafe { _ptr.add(0) };
          unsafe { let super::super::super::__with_name0::DeviceId{ packed:packed0, } = _lower0;
          *_param_ptr.add(0).cast::<i64>() = _rt::as_i64(packed0);
        }
        let _param_ptr = unsafe { _ptr.add(8) };
        unsafe { let super::super::super::__with_name0::EntityIndex{ inner:inner0, } = _lower1;
        *_param_ptr.add(0).cast::<i64>() = _rt::as_i64(inner0);
      }
      let _param_ptr = unsafe { _ptr.add(16) };
      unsafe { use super::super::super::__with_name2::Component as V14;
      match _lower2 {
        V14::Integer(e) => {
          *_param_ptr.add(0).cast::<u8>() = (0i32) as u8;
          *_param_ptr.add(8).cast::<i64>() = _rt::as_i64(e);
        },
        V14::Float(e) => {
          *_param_ptr.add(0).cast::<u8>() = (1i32) as u8;
          *_param_ptr.add(8).cast::<f64>() = _rt::as_f64(e);
        },
        V14::String(e) => {
          *_param_ptr.add(0).cast::<u8>() = (2i32) as u8;
          let vec0 = (e.into_bytes()).into_boxed_slice();
          let ptr0 = vec0.as_ptr().cast::<u8>();
          let len0 = vec0.len();
          ::core::mem::forget(vec0);
          *_param_ptr.add(8+1*::core::mem::size_of::<*const u8>()).cast::<usize>() = len0;
          *_param_ptr.add(8).cast::<*mut u8>() = ptr0.cast_mut();
        },
        V14::Bool(e) => {
          *_param_ptr.add(0).cast::<u8>() = (3i32) as u8;
          *_param_ptr.add(8).cast::<u8>() = (match e { true => 1, false => 0 }) as u8;
        },
        V14::Color(e) => {
          *_param_ptr.add(0).cast::<u8>() = (4i32) as u8;
          let super::super::super::__with_name1::IglooColor{ r:r1, g:g1, b:b1, } = e;
          *_param_ptr.add(8).cast::<f64>() = _rt::as_f64(r1);
          *_param_ptr.add(16).cast::<f64>() = _rt::as_f64(g1);
          *_param_ptr.add(24).cast::<f64>() = _rt::as_f64(b1);
        },
        V14::Date(e) => {
          *_param_ptr.add(0).cast::<u8>() = (5i32) as u8;
          let super::super::super::__with_name1::IglooDate{ year:year2, month:month2, day:day2, } = e;
          *_param_ptr.add(8).cast::<u16>() = (_rt::as_i32(year2)) as u16;
          *_param_ptr.add(10).cast::<u8>() = (_rt::as_i32(month2)) as u8;
          *_param_ptr.add(11).cast::<u8>() = (_rt::as_i32(day2)) as u8;
        },
        V14::Time(e) => {
          *_param_ptr.add(0).cast::<u8>() = (6i32) as u8;
          let super::super::super::__with_name1::IglooTime{ hour:hour3, minute:minute3, second:second3, } = e;
          *_param_ptr.add(8).cast::<u8>() = (_rt::as_i32(hour3)) as u8;
          *_param_ptr.add(9).cast::<u8>() = (_rt::as_i32(minute3)) as u8;
          *_param_ptr.add(10).cast::<u8>() = (_rt::as_i32(second3)) as u8;
        },
        V14::IntegerList(e) => {
          *_param_ptr.add(0).cast::<u8>() = (7i32) as u8;
          let vec4 = <_ as Into<_rt::Vec<_>>>::into(e).into_boxed_slice();
          let ptr4 = vec4.as_ptr().cast::<u8>();
          let len4 = vec4.len();
          ::core::mem::forget(vec4);
          *_param_ptr.add(8+1*::core::mem::size_of::<*const u8>()).cast::<usize>() = len4;
          *_param_ptr.add(8).cast::<*mut u8>() = ptr4.cast_mut();
        },
        V14::FloatList(e) => {
          *_param_ptr.add(0).cast::<u8>() = (8i32) as u8;
          let vec5 = <_ as Into<_rt::Vec<_>>>::into(e).into_boxed_slice();
          let ptr5 = vec5.as_ptr().cast::<u8>();
          let len5 = vec5.len();
          ::core::mem::forget(vec5);
          *_param_ptr.add(8+1*::core::mem::size_of::<*const u8>()).cast::<usize>() = len5;
          *_param_ptr.add(8).cast::<*mut u8>() = ptr5.cast_mut();
        },
        V14::StringList(e) => {
          *_param_ptr.add(0).cast::<u8>() = (9i32) as u8;
          let vec7 = e;
          let len7 = vec7.len();
          let layout7 = _rt::alloc::Layout::from_size_align(vec7.len() * (2*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>()).unwrap();
          let (result7, _cleanup7) = wit_bindgen::rt::Cleanup::new(layout7);if let Some(cleanup) = _cleanup7 { cleanup.forget(); }
          for (i, e) in vec7.into_iter().enumerate() {
            let base = result7.add(i * (2*::core::mem::size_of::<*const u8>()));
            {
              let vec6 = (e.into_bytes()).into_boxed_slice();
              let ptr6 = vec6.as_ptr().cast::<u8>();
              let len6 = vec6.len();
              ::core::mem::forget(vec6);
              *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len6;
              *base.add(0).cast::<*mut u8>() = ptr6.cast_mut();
            }
          }
          *_param_ptr.add(8+1*::core::mem::size_of::<*const u8>()).cast::<usize>() = len7;
          *_param_ptr.add(8).cast::<*mut u8>() = result7;
        },
        V14::BooleanList(e) => {
          *_param_ptr.add(0).cast::<u8>() = (10i32) as u8;
          let vec8 = e;
          let len8 = vec8.len();
          let layout8 = _rt::alloc::Layout::from_size_align(vec8.len() * 1, 1).unwrap();
          let (result8, _cleanup8) = wit_bindgen::rt::Cleanup::new(layout8);if let Some(cleanup) = _cleanup8 { cleanup.forget(); }
          for (i, e) in vec8.into_iter().enumerate() {
            let base = result8.add(i * 1);
            {
              *base.add(0).cast::<u8>() = (match e { true => 1, false => 0 }) as u8;
            }
          }
          *_param_ptr.add(8+1*::core::mem::size_of::<*const u8>()).cast::<usize>() = len8;
          *_param_ptr.add(8).cast::<*mut u8>() = result8;
        },
        V14::ColorList(e) => {
          *_param_ptr.add(0).cast::<u8>() = (11i32) as u8;
          let vec9 = <_ as Into<_rt::Vec<_>>>::into(e).into_boxed_slice();
          let ptr9 = vec9.as_ptr().cast::<u8>();
          let len9 = vec9.len();
          ::core::mem::forget(vec9);
          *_param_ptr.add(8+1*::core::mem::size_of::<*const u8>()).cast::<usize>() = len9;
          *_param_ptr.add(8).cast::<*mut u8>() = ptr9.cast_mut();
        },
        V14::DateList(e) => {
          *_param_ptr.add(0).cast::<u8>() = (12i32) as u8;
          let vec10 = <_ as Into<_rt::Vec<_>>>::into(e).into_boxed_slice();
          let ptr10 = vec10.as_ptr().cast::<u8>();
          let len10 = vec10.len();
          ::core::mem::forget(vec10);
          *_param_ptr.add(8+1*::core::mem::size_of::<*const u8>()).cast::<usize>() = len10;
          *_param_ptr.add(8).cast::<*mut u8>() = ptr10.cast_mut();
        },
        V14::TimeList(e) => {
          *_param_ptr.add(0).cast::<u8>() = (13i32) as u8;
          let vec11 = <_ as Into<_rt::Vec<_>>>::into(e).into_boxed_slice();
          let ptr11 = vec11.as_ptr().cast::<u8>();
          let len11 = vec11.len();
          ::core::mem::forget(vec11);
          *_param_ptr.add(8+1*::core::mem::size_of::<*const u8>()).cast::<usize>() = len11;
          *_param_ptr.add(8).cast::<*mut u8>() = ptr11.cast_mut();
        },
        V14::Trigger=> {
          {
            *_param_ptr.add(0).cast::<u8>() = (14i32) as u8;
          }
        }
        V14::Timestamp(e) => {
          *_param_ptr.add(0).cast::<u8>() = (15i32) as u8;
          *_param_ptr.add(8).cast::<i64>() = _rt::as_i64(e);
        },
        V14::Duration(e) => {
          *_param_ptr.add(0).cast::<u8>() = (16i32) as u8;
          *_param_ptr.add(8).cast::<i64>() = _rt::as_i64(e);
        },
        V14::Weekday(e) => {
          *_param_ptr.add(0).cast::<u8>() = (17i32) as u8;
          *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
        },
        V14::Light=> {
          {
            *_param_ptr.add(0).cast::<u8>() = (18i32) as u8;
          }
        }
        V14::Switch(e) => {
          *_param_ptr.add(0).cast::<u8>() = (19i32) as u8;
          *_param_ptr.add(8).cast::<u8>() = (match e { true => 1, false => 0 }) as u8;
        },
        V14::Dimmer(e) => {
          *_param_ptr.add(0).cast::<u8>() = (20i32) as u8;
          *_param_ptr.add(8).cast::<f64>() = _rt::as_f64(e);
        },
        V14::Switch(e) => {
          *_param_ptr.add(0).cast::<u8>() = (21i32) as u8;
          *_param_ptr.add(8).cast::<u8>() = (match e { true => 1, false => 0 }) as u8;
        },
        V14::ColorMode(e) => {
          *_param_ptr.add(0).cast::<u8>() = (22i32) as u8;
          *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
        },
        V14::ColorTemperature(e) => {
          *_param_ptr.add(0).cast::<u8>() = (23i32) as u8;
          *_param_ptr.add(8).cast::<i64>() = _rt::as_i64(e);
        },
        V14::Volume(e) => {
          *_param_ptr.add(0).cast::<u8>() = (24i32) as u8;
          *_param_ptr.add(8).cast::<f64>() = _rt::as_f64(e);
        },
        V14::Muted(e) => {
          *_param_ptr.add(0).cast::<u8>() = (25i32) as u8;
          *_param_ptr.add(8).cast::<u8>() = (match e { true => 1, false => 0 }) as u8;
        },
        V14::Config=> {
          {
            *_param_ptr.add(0).cast::<u8>() = (26i32) as u8;
          }
        }
        V14::Diagnostic=> {
          {
            *_param_ptr.add(0).cast::<u8>() = (27i32) as u8;
          }
        }
        V14::Siren=> {
          {
            *_param_ptr.add(0).cast::<u8>() = (28i32) as u8;
          }
        }
        V14::Sensor=> {
          {
            *_param_ptr.add(0).cast::<u8>() = (29i32) as u8;
          }
        }
        V14::Icon(e) => {
          *_param_ptr.add(0).cast::<u8>() = (30i32) as u8;
          let vec12 = (e.into_bytes()).into_boxed_slice();
          let ptr12 = vec12.as_ptr().cast::<u8>();
          let len12 = vec12.len();
          ::core::mem::forget(vec12);
          *_param_ptr.add(8+1*::core::mem::size_of::<*const u8>()).cast::<usize>() = len12;
          *_param_ptr.add(8).cast::<*mut u8>() = ptr12.cast_mut();
        },
        V14::AccuracyDecimals(e) => {
          *_param_ptr.add(0).cast::<u8>() = (31i32) as u8;
          *_param_ptr.add(8).cast::<i64>() = _rt::as_i64(e);
        },
        V14::DeviceClass(e) => {
          *_param_ptr.add(0).cast::<u8>() = (32i32) as u8;
          let vec13 = (e.into_bytes()).into_boxed_slice();
          let ptr13 = vec13.as_ptr().cast::<u8>();
          let len13 = vec13.len();
          ::core::mem::forget(vec13);
          *_param_ptr.add(8+1*::core::mem::size_of::<*const u8>()).cast::<usize>() = len13;
          *_param_ptr.add(8).cast::<*mut u8>() = ptr13.cast_mut();
        },
        V14::SensorStateClass(e) => {
          *_param_ptr.add(0).cast::<u8>() = (33i32) as u8;
          *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
        },
        V14::UnitApparentPower(e) => {
          *_param_ptr.add(0).cast::<u8>() = (34i32) as u8;
          *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
        },
        V14::UnitPower(e) => {
          *_param_ptr.add(0).cast::<u8>() = (35i32) as u8;
          *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
        },
        V14::UnitReactivePower(e) => {
          *_param_ptr.add(0).cast::<u8>() = (36i32) as u8;
          *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
        },
        V14::UnitEnergy(e) => {
          *_param_ptr.add(0).cast::<u8>() = (37i32) as u8;
          *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
        },
        V14::UnitElectricCurrent(e) => {
          *_param_ptr.add(0).cast::<u8>() = (38i32) as u8;
          *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
        },
        V14::UnitElectricPotential(e) => {
          *_param_ptr.add(0).cast::<u8>() = (39i32) as u8;
          *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
        },
        V14::UnitDegree(e) => {
          *_param_ptr.add(0).cast::<u8>() = (40i32) as u8;
          *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
        },
        V14::UnitCurrency(e) => {
          *_param_ptr.add(0).cast::<u8>() = (41i32) as u8;
          *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
        },
        V14::UnitTemperature(e) => {
          *_param_ptr.add(0).cast::<u8>() = (42i32) as u8;
          *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
        },
        V14::UnitTime(e) => {
          *_param_ptr.add(0).cast::<u8>() = (43i32) as u8;
          *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
        },
        V14::UnitLength(e) => {
          *_param_ptr.add(0).cast::<u8>() = (44i32) as u8;
          *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
        },
        V14::UnitFrequency(e) => {
          *_param_ptr.add(0).cast::<u8>() = (45i32) as u8;
          *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
        },
        V14::UnitPressure(e) => {
          *_param_ptr.add(0).cast::<u8>() = (46i32) as u8;
          *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
        },
        V14::UnitSoundPressure(e) => {
          *_param_ptr.add(0).cast::<u8>() = (47i32) as u8;
          *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
        },
        V14::UnitVolume(e) => {
          *_param_ptr.add(0).cast::<u8>() = (48i32) as u8;
          *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
        },
        V14::UnitVolumeFlowRate(e) => {
          *_param_ptr.add(0).cast::<u8>() = (49i32) as u8;
          *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
        },
        V14::UnitArea(e) => {
          *_param_ptr.add(0).cast::<u8>() = (50i32) as u8;
          *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
        },
        V14::UnitMass(e) => {
          *_param_ptr.add(0).cast::<u8>() = (51i32) as u8;
          *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
        },
        V14::UnitConductivity(e) => {
          *_param_ptr.add(0).cast::<u8>() = (52i32) as u8;
          *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
        },
        V14::UnitLight(e) => {
          *_param_ptr.add(0).cast::<u8>() = (53i32) as u8;
          *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
        },
        V14::UnitUvIndex(e) => {
          *_param_ptr.add(0).cast::<u8>() = (54i32) as u8;
          *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
        },
        V14::UnitPercentage(e) => {
          *_param_ptr.add(0).cast::<u8>() = (55i32) as u8;
          *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
        },
        V14::UnitIrradiation(e) => {
          *_param_ptr.add(0).cast::<u8>() = (56i32) as u8;
          *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
        },
        V14::UnitConcentration(e) => {
          *_param_ptr.add(0).cast::<u8>() = (57i32) as u8;
          *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
        },
        V14::UnitSpeed(e) => {
          *_param_ptr.add(0).cast::<u8>() = (58i32) as u8;
          *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
        },
        V14::UnitData(e) => {
          *_param_ptr.add(0).cast::<u8>() = (59i32) as u8;
          *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
        },
        V14::UnitDataRate(e) => {
          *_param_ptr.add(0).cast::<u8>() = (60i32) as u8;
          *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
        },
        V14::FanOscillation(e) => {
          *_param_ptr.add(0).cast::<u8>() = (61i32) as u8;
          *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
        },
        V14::FanDirection(e) => {
          *_param_ptr.add(0).cast::<u8>() = (62i32) as u8;
          *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
        },
        V14::FanSpeed(e) => {
          *_param_ptr.add(0).cast::<u8>() = (63i32) as u8;
          *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
        },
        V14::ClimateMode(e) => {
          *_param_ptr.add(0).cast::<u8>() = (64i32) as u8;
          *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
        },
        V14::LockState(e) => {
          *_param_ptr.add(0).cast::<u8>() = (65i32) as u8;
          *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
        },
        V14::MediaState(e) => {
          *_param_ptr.add(0).cast::<u8>() = (66i32) as u8;
          *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
        },
        V14::Cover=> {
          {
            *_param_ptr.add(0).cast::<u8>() = (67i32) as u8;
          }
        }
        V14::CoverState(e) => {
          *_param_ptr.add(0).cast::<u8>() = (68i32) as u8;
          *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
        },
        V14::Position(e) => {
          *_param_ptr.add(0).cast::<u8>() = (69i32) as u8;
          *_param_ptr.add(8).cast::<f64>() = _rt::as_f64(e);
        },
        V14::Tilt(e) => {
          *_param_ptr.add(0).cast::<u8>() = (70i32) as u8;
          *_param_ptr.add(8).cast::<f64>() = _rt::as_f64(e);
        },
        V14::Valve=> {
          {
            *_param_ptr.add(0).cast::<u8>() = (71i32) as u8;
          }
        }
        V14::ValveState(e) => {
          *_param_ptr.add(0).cast::<u8>() = (72i32) as u8;
          *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
        },
        V14::AlarmState(e) => {
          *_param_ptr.add(0).cast::<u8>() = (73i32) as u8;
          *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
        },
      }
    }
    ParamsLower(_ptr,)
  }
  unsafe fn results_lift(&mut self, _ptr: *mut u8) -> Self::Results {
    unsafe { let l0 = i32::from(*_ptr.add(0).cast::<u8>());

    match l0 {
      0 => {
        let e = ();
        Ok(e)
      }
      1 => {
        let e = {
          let l1 = *_ptr.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
          let l2 = *_ptr.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>();
          let len3 = l2;
          let bytes3 = _rt::Vec::from_raw_parts(l1.cast(), len3, len3);

          _rt::string_lift(bytes3)
        };
        Err(e)
      }
      _ => _rt::invalid_enum_discriminant(),
    } }
  }
}
_MySubtask { _unused: core::marker::PhantomData }.call((device_id, entity_index, component,)).await
}
}
#[allow(unused_unsafe, clippy::all)]
/// Igloo has deleted device,
/// extension must cleanup its `Device` reference
#[allow(async_fn_in_trait)]
pub async fn delete_device(device_id: DeviceId,) -> Result<(),_rt::String>{
  unsafe {

    #[derive(Copy, Clone)]
    struct ParamsLower(
    i64, 
    );
    unsafe impl Send for ParamsLower {}
    

    use wit_bindgen::rt::async_support::Subtask as _Subtask;
    struct _MySubtask<'a> { _unused: core::marker::PhantomData<&'a ()> }
    #[allow(unused_parens)]
    unsafe impl<'a> _Subtask for _MySubtask<'a> {
      
      type Params = (DeviceId, );
      type Results = Result<(),_rt::String>;
      type ParamsLower = ParamsLower;
      fn abi_layout(&mut self) -> ::core::alloc::Layout {
        unsafe {
          ::core::alloc::Layout::from_size_align_unchecked((3*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>())
        }
      }
      
      fn results_offset(&mut self) -> usize { 0 }

      unsafe fn call_import(&mut self, _params: Self::ParamsLower, _results: *mut u8) -> u32 {
        
        #[cfg(target_arch = "wasm32")]
        #[link(wasm_import_module = "igloo:lib/core-to-extension-sp@0.1.0")]
        unsafe extern "C" {
          #[link_name = "[async-lower]delete-device"]
          fn call(_: i64, _: *mut u8, ) -> i32;
        }

        #[cfg(not(target_arch = "wasm32"))]
        unsafe extern "C" fn call(_: i64, _: *mut u8, ) -> i32 { unreachable!() }
        
        unsafe { call(_params.0,_results) as u32 }
      }
      
      unsafe fn params_dealloc_lists(&mut self, _params: Self::ParamsLower) {
        unsafe {  }
      }
      unsafe fn params_dealloc_lists_and_own(&mut self, _params: Self::ParamsLower) {
        unsafe {  }
      }
      unsafe fn params_lower(&mut self, (_lower0,): Self::Params, _ptr: *mut u8) -> Self::ParamsLower {
        unsafe { let super::super::super::__with_name0::DeviceId{ packed:packed0, } = _lower0;
        ParamsLower(_rt::as_i64(packed0),) }
      }
      unsafe fn results_lift(&mut self, _ptr: *mut u8) -> Self::Results {
        unsafe { let l0 = i32::from(*_ptr.add(0).cast::<u8>());

        match l0 {
          0 => {
            let e = ();
            Ok(e)
          }
          1 => {
            let e = {
              let l1 = *_ptr.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
              let l2 = *_ptr.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>();
              let len3 = l2;
              let bytes3 = _rt::Vec::from_raw_parts(l1.cast(), len3, len3);

              _rt::string_lift(bytes3)
            };
            Err(e)
          }
          _ => _rt::invalid_enum_discriminant(),
        } }
      }
    }
    _MySubtask { _unused: core::marker::PhantomData }.call((device_id,)).await
  }
}
#[allow(unused_unsafe, clippy::all)]
/// Custom function defined by extension
#[allow(async_fn_in_trait)]
pub async fn custom(name: _rt::String,params: _rt::String,) -> Result<(),_rt::String>{
  unsafe {

    #[derive(Copy, Clone)]
    struct ParamsLower(
    *mut u8, usize, *mut u8, usize, 
    );
    unsafe impl Send for ParamsLower {}
    

    use wit_bindgen::rt::async_support::Subtask as _Subtask;
    struct _MySubtask<'a> { _unused: core::marker::PhantomData<&'a ()> }
    #[allow(unused_parens)]
    unsafe impl<'a> _Subtask for _MySubtask<'a> {
      
      type Params = (_rt::String, _rt::String, );
      type Results = Result<(),_rt::String>;
      type ParamsLower = ParamsLower;
      fn abi_layout(&mut self) -> ::core::alloc::Layout {
        unsafe {
          ::core::alloc::Layout::from_size_align_unchecked((3*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>())
        }
      }
      
      fn results_offset(&mut self) -> usize { 0 }

      unsafe fn call_import(&mut self, _params: Self::ParamsLower, _results: *mut u8) -> u32 {
        
        #[cfg(target_arch = "wasm32")]
        #[link(wasm_import_module = "igloo:lib/core-to-extension-sp@0.1.0")]
        unsafe extern "C" {
          #[link_name = "[async-lower]custom"]
          fn call(_: *mut u8, _: usize, _: *mut u8, _: usize, _: *mut u8, ) -> i32;
        }

        #[cfg(not(target_arch = "wasm32"))]
        unsafe extern "C" fn call(_: *mut u8, _: usize, _: *mut u8, _: usize, _: *mut u8, ) -> i32 { unreachable!() }
        
        unsafe { call(_params.0,_params.1,_params.2,_params.3,_results) as u32 }
      }
      
      unsafe fn params_dealloc_lists(&mut self, _params: Self::ParamsLower) {
        unsafe { _rt::cabi_dealloc(_params.0, _params.1, 1);
        _rt::cabi_dealloc(_params.2, _params.3, 1);
      }
    }
    unsafe fn params_dealloc_lists_and_own(&mut self, _params: Self::ParamsLower) {
      unsafe { _rt::cabi_dealloc(_params.0, _params.1, 1);
      _rt::cabi_dealloc(_params.2, _params.3, 1);
    }
  }
  unsafe fn params_lower(&mut self, (_lower0, _lower1,): Self::Params, _ptr: *mut u8) -> Self::ParamsLower {
    unsafe { let vec0 = (_lower0.into_bytes()).into_boxed_slice();
    let ptr0 = vec0.as_ptr().cast::<u8>();
    let len0 = vec0.len();
    ::core::mem::forget(vec0);
    let vec1 = (_lower1.into_bytes()).into_boxed_slice();
    let ptr1 = vec1.as_ptr().cast::<u8>();
    let len1 = vec1.len();
    ::core::mem::forget(vec1);
    ParamsLower(ptr0.cast_mut(), len0, ptr1.cast_mut(), len1,) }
  }
  unsafe fn results_lift(&mut self, _ptr: *mut u8) -> Self::Results {
    unsafe { let l0 = i32::from(*_ptr.add(0).cast::<u8>());

    match l0 {
      0 => {
        let e = ();
        Ok(e)
      }
      1 => {
        let e = {
          let l1 = *_ptr.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
          let l2 = *_ptr.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>();
          let len3 = l2;
          let bytes3 = _rt::Vec::from_raw_parts(l1.cast(), len3, len3);

          _rt::string_lift(bytes3)
        };
        Err(e)
      }
      _ => _rt::invalid_enum_discriminant(),
    } }
  }
}
_MySubtask { _unused: core::marker::PhantomData }.call((name, params,)).await
}
}

}


#[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
pub mod core_to_extension_mp {
  #[used]
  #[doc(hidden)]
  static __FORCE_SECTION_REF: fn() =
  super::super::super::__link_custom_section_describing_imports;
  
  use super::super::super::_rt;
  pub type EntityIndex = super::super::super::__with_name0::EntityIndex;
  pub type Component = super::super::super::__with_name2::Component;
  #[allow(unused_unsafe, clippy::all)]
  /// Igloo core request to put a component on the given entity.
  /// The change will not be applied to the device tree until the extension
  /// confirms by sending a `put-component` back
  /// (usually after response from the physical hardware device)
  ///
  /// The extension _should_ hint to the core whether the operation will
  /// succeed by returning either `Ok` or `Err`
  #[allow(async_fn_in_trait)]
  pub async fn put_component(entity_index: EntityIndex,component: Component,) -> Result<(),_rt::String>{
    unsafe {

      #[derive(Copy, Clone)]
      struct ParamsLower(
      *mut u8, 
      );
      unsafe impl Send for ParamsLower {}
      

      use wit_bindgen::rt::async_support::Subtask as _Subtask;
      struct _MySubtask<'a> { _unused: core::marker::PhantomData<&'a ()> }
      #[allow(unused_parens)]
      unsafe impl<'a> _Subtask for _MySubtask<'a> {
        
        type Params = (EntityIndex, Component, );
        type Results = Result<(),_rt::String>;
        type ParamsLower = ParamsLower;
        fn abi_layout(&mut self) -> ::core::alloc::Layout {
          unsafe {
            ::core::alloc::Layout::from_size_align_unchecked((48+2*::core::mem::size_of::<*const u8>()), 8)
          }
        }
        
        fn results_offset(&mut self) -> usize { 40 }

        unsafe fn call_import(&mut self, _params: Self::ParamsLower, _results: *mut u8) -> u32 {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "igloo:lib/core-to-extension-mp@0.1.0")]
          unsafe extern "C" {
            #[link_name = "[async-lower]put-component"]
            fn call(_: *mut u8, _: *mut u8, ) -> i32;
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn call(_: *mut u8, _: *mut u8, ) -> i32 { unreachable!() }
          
          unsafe { call(_params.0,_results) as u32 }
        }
        
        unsafe fn params_dealloc_lists(&mut self, _params: Self::ParamsLower) {
          unsafe { let l0 = i32::from(*_params.0.add(8).cast::<u8>());
          match l0 {
            0 => (),
            1 => (),
            2 => {
              let l1 = *_params.0.add(16).cast::<*mut u8>();
              let l2 = *_params.0.add(16+1*::core::mem::size_of::<*const u8>()).cast::<usize>();
              _rt::cabi_dealloc(l1, l2, 1);
            },
            3 => (),
            4 => (),
            5 => (),
            6 => (),
            7 => {
              let l3 = *_params.0.add(16).cast::<*mut u8>();
              let l4 = *_params.0.add(16+1*::core::mem::size_of::<*const u8>()).cast::<usize>();
              let base5 = l3;
              let len5 = l4;
              _rt::cabi_dealloc(base5, len5 * 8, 8);
            },
            8 => {
              let l6 = *_params.0.add(16).cast::<*mut u8>();
              let l7 = *_params.0.add(16+1*::core::mem::size_of::<*const u8>()).cast::<usize>();
              let base8 = l6;
              let len8 = l7;
              _rt::cabi_dealloc(base8, len8 * 8, 8);
            },
            9 => {
              let l9 = *_params.0.add(16).cast::<*mut u8>();
              let l10 = *_params.0.add(16+1*::core::mem::size_of::<*const u8>()).cast::<usize>();
              let base13 = l9;
              let len13 = l10;
              for i in 0..len13 {
                let base = base13.add(i * (2*::core::mem::size_of::<*const u8>()));
                {
                  let l11 = *base.add(0).cast::<*mut u8>();
                  let l12 = *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
                  _rt::cabi_dealloc(l11, l12, 1);
                }
              }
              _rt::cabi_dealloc(base13, len13 * (2*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>());
            },
            10 => {
              let l14 = *_params.0.add(16).cast::<*mut u8>();
              let l15 = *_params.0.add(16+1*::core::mem::size_of::<*const u8>()).cast::<usize>();
              let base16 = l14;
              let len16 = l15;
              _rt::cabi_dealloc(base16, len16 * 1, 1);
            },
            11 => {
              let l17 = *_params.0.add(16).cast::<*mut u8>();
              let l18 = *_params.0.add(16+1*::core::mem::size_of::<*const u8>()).cast::<usize>();
              let base19 = l17;
              let len19 = l18;
              _rt::cabi_dealloc(base19, len19 * 24, 8);
            },
            12 => {
              let l20 = *_params.0.add(16).cast::<*mut u8>();
              let l21 = *_params.0.add(16+1*::core::mem::size_of::<*const u8>()).cast::<usize>();
              let base22 = l20;
              let len22 = l21;
              _rt::cabi_dealloc(base22, len22 * 4, 2);
            },
            13 => {
              let l23 = *_params.0.add(16).cast::<*mut u8>();
              let l24 = *_params.0.add(16+1*::core::mem::size_of::<*const u8>()).cast::<usize>();
              let base25 = l23;
              let len25 = l24;
              _rt::cabi_dealloc(base25, len25 * 3, 1);
            },
            14 => (),
            15 => (),
            16 => (),
            17 => (),
            18 => (),
            19 => (),
            20 => (),
            21 => (),
            22 => (),
            23 => (),
            24 => (),
            25 => (),
            26 => (),
            27 => (),
            28 => (),
            29 => (),
            30 => {
              let l26 = *_params.0.add(16).cast::<*mut u8>();
              let l27 = *_params.0.add(16+1*::core::mem::size_of::<*const u8>()).cast::<usize>();
              _rt::cabi_dealloc(l26, l27, 1);
            },
            31 => (),
            32 => {
              let l28 = *_params.0.add(16).cast::<*mut u8>();
              let l29 = *_params.0.add(16+1*::core::mem::size_of::<*const u8>()).cast::<usize>();
              _rt::cabi_dealloc(l28, l29, 1);
            },
            33 => (),
            34 => (),
            35 => (),
            36 => (),
            37 => (),
            38 => (),
            39 => (),
            40 => (),
            41 => (),
            42 => (),
            43 => (),
            44 => (),
            45 => (),
            46 => (),
            47 => (),
            48 => (),
            49 => (),
            50 => (),
            51 => (),
            52 => (),
            53 => (),
            54 => (),
            55 => (),
            56 => (),
            57 => (),
            58 => (),
            59 => (),
            60 => (),
            61 => (),
            62 => (),
            63 => (),
            64 => (),
            65 => (),
            66 => (),
            67 => (),
            68 => (),
            69 => (),
            70 => (),
            71 => (),
            72 => (),
            _ => (),
          }
        }
      }
      unsafe fn params_dealloc_lists_and_own(&mut self, _params: Self::ParamsLower) {
        unsafe { let l0 = i32::from(*_params.0.add(8).cast::<u8>());
        match l0 {
          0 => (),
          1 => (),
          2 => {
            let l1 = *_params.0.add(16).cast::<*mut u8>();
            let l2 = *_params.0.add(16+1*::core::mem::size_of::<*const u8>()).cast::<usize>();
            _rt::cabi_dealloc(l1, l2, 1);
          },
          3 => (),
          4 => (),
          5 => (),
          6 => (),
          7 => {
            let l3 = *_params.0.add(16).cast::<*mut u8>();
            let l4 = *_params.0.add(16+1*::core::mem::size_of::<*const u8>()).cast::<usize>();
            let base5 = l3;
            let len5 = l4;
            _rt::cabi_dealloc(base5, len5 * 8, 8);
          },
          8 => {
            let l6 = *_params.0.add(16).cast::<*mut u8>();
            let l7 = *_params.0.add(16+1*::core::mem::size_of::<*const u8>()).cast::<usize>();
            let base8 = l6;
            let len8 = l7;
            _rt::cabi_dealloc(base8, len8 * 8, 8);
          },
          9 => {
            let l9 = *_params.0.add(16).cast::<*mut u8>();
            let l10 = *_params.0.add(16+1*::core::mem::size_of::<*const u8>()).cast::<usize>();
            let base13 = l9;
            let len13 = l10;
            for i in 0..len13 {
              let base = base13.add(i * (2*::core::mem::size_of::<*const u8>()));
              {
                let l11 = *base.add(0).cast::<*mut u8>();
                let l12 = *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
                _rt::cabi_dealloc(l11, l12, 1);
              }
            }
            _rt::cabi_dealloc(base13, len13 * (2*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>());
          },
          10 => {
            let l14 = *_params.0.add(16).cast::<*mut u8>();
            let l15 = *_params.0.add(16+1*::core::mem::size_of::<*const u8>()).cast::<usize>();
            let base16 = l14;
            let len16 = l15;
            _rt::cabi_dealloc(base16, len16 * 1, 1);
          },
          11 => {
            let l17 = *_params.0.add(16).cast::<*mut u8>();
            let l18 = *_params.0.add(16+1*::core::mem::size_of::<*const u8>()).cast::<usize>();
            let base19 = l17;
            let len19 = l18;
            _rt::cabi_dealloc(base19, len19 * 24, 8);
          },
          12 => {
            let l20 = *_params.0.add(16).cast::<*mut u8>();
            let l21 = *_params.0.add(16+1*::core::mem::size_of::<*const u8>()).cast::<usize>();
            let base22 = l20;
            let len22 = l21;
            _rt::cabi_dealloc(base22, len22 * 4, 2);
          },
          13 => {
            let l23 = *_params.0.add(16).cast::<*mut u8>();
            let l24 = *_params.0.add(16+1*::core::mem::size_of::<*const u8>()).cast::<usize>();
            let base25 = l23;
            let len25 = l24;
            _rt::cabi_dealloc(base25, len25 * 3, 1);
          },
          14 => (),
          15 => (),
          16 => (),
          17 => (),
          18 => (),
          19 => (),
          20 => (),
          21 => (),
          22 => (),
          23 => (),
          24 => (),
          25 => (),
          26 => (),
          27 => (),
          28 => (),
          29 => (),
          30 => {
            let l26 = *_params.0.add(16).cast::<*mut u8>();
            let l27 = *_params.0.add(16+1*::core::mem::size_of::<*const u8>()).cast::<usize>();
            _rt::cabi_dealloc(l26, l27, 1);
          },
          31 => (),
          32 => {
            let l28 = *_params.0.add(16).cast::<*mut u8>();
            let l29 = *_params.0.add(16+1*::core::mem::size_of::<*const u8>()).cast::<usize>();
            _rt::cabi_dealloc(l28, l29, 1);
          },
          33 => (),
          34 => (),
          35 => (),
          36 => (),
          37 => (),
          38 => (),
          39 => (),
          40 => (),
          41 => (),
          42 => (),
          43 => (),
          44 => (),
          45 => (),
          46 => (),
          47 => (),
          48 => (),
          49 => (),
          50 => (),
          51 => (),
          52 => (),
          53 => (),
          54 => (),
          55 => (),
          56 => (),
          57 => (),
          58 => (),
          59 => (),
          60 => (),
          61 => (),
          62 => (),
          63 => (),
          64 => (),
          65 => (),
          66 => (),
          67 => (),
          68 => (),
          69 => (),
          70 => (),
          71 => (),
          72 => (),
          _ => (),
        }
      }
    }
    unsafe fn params_lower(&mut self, (_lower0, _lower1,): Self::Params, _ptr: *mut u8) -> Self::ParamsLower {
      let _param_ptr = unsafe { _ptr.add(0) };
      unsafe { let super::super::super::__with_name0::EntityIndex{ inner:inner0, } = _lower0;
      *_param_ptr.add(0).cast::<i64>() = _rt::as_i64(inner0);
    }
    let _param_ptr = unsafe { _ptr.add(8) };
    unsafe { use super::super::super::__with_name2::Component as V14;
    match _lower1 {
      V14::Integer(e) => {
        *_param_ptr.add(0).cast::<u8>() = (0i32) as u8;
        *_param_ptr.add(8).cast::<i64>() = _rt::as_i64(e);
      },
      V14::Float(e) => {
        *_param_ptr.add(0).cast::<u8>() = (1i32) as u8;
        *_param_ptr.add(8).cast::<f64>() = _rt::as_f64(e);
      },
      V14::String(e) => {
        *_param_ptr.add(0).cast::<u8>() = (2i32) as u8;
        let vec0 = (e.into_bytes()).into_boxed_slice();
        let ptr0 = vec0.as_ptr().cast::<u8>();
        let len0 = vec0.len();
        ::core::mem::forget(vec0);
        *_param_ptr.add(8+1*::core::mem::size_of::<*const u8>()).cast::<usize>() = len0;
        *_param_ptr.add(8).cast::<*mut u8>() = ptr0.cast_mut();
      },
      V14::Bool(e) => {
        *_param_ptr.add(0).cast::<u8>() = (3i32) as u8;
        *_param_ptr.add(8).cast::<u8>() = (match e { true => 1, false => 0 }) as u8;
      },
      V14::Color(e) => {
        *_param_ptr.add(0).cast::<u8>() = (4i32) as u8;
        let super::super::super::__with_name1::IglooColor{ r:r1, g:g1, b:b1, } = e;
        *_param_ptr.add(8).cast::<f64>() = _rt::as_f64(r1);
        *_param_ptr.add(16).cast::<f64>() = _rt::as_f64(g1);
        *_param_ptr.add(24).cast::<f64>() = _rt::as_f64(b1);
      },
      V14::Date(e) => {
        *_param_ptr.add(0).cast::<u8>() = (5i32) as u8;
        let super::super::super::__with_name1::IglooDate{ year:year2, month:month2, day:day2, } = e;
        *_param_ptr.add(8).cast::<u16>() = (_rt::as_i32(year2)) as u16;
        *_param_ptr.add(10).cast::<u8>() = (_rt::as_i32(month2)) as u8;
        *_param_ptr.add(11).cast::<u8>() = (_rt::as_i32(day2)) as u8;
      },
      V14::Time(e) => {
        *_param_ptr.add(0).cast::<u8>() = (6i32) as u8;
        let super::super::super::__with_name1::IglooTime{ hour:hour3, minute:minute3, second:second3, } = e;
        *_param_ptr.add(8).cast::<u8>() = (_rt::as_i32(hour3)) as u8;
        *_param_ptr.add(9).cast::<u8>() = (_rt::as_i32(minute3)) as u8;
        *_param_ptr.add(10).cast::<u8>() = (_rt::as_i32(second3)) as u8;
      },
      V14::IntegerList(e) => {
        *_param_ptr.add(0).cast::<u8>() = (7i32) as u8;
        let vec4 = <_ as Into<_rt::Vec<_>>>::into(e).into_boxed_slice();
        let ptr4 = vec4.as_ptr().cast::<u8>();
        let len4 = vec4.len();
        ::core::mem::forget(vec4);
        *_param_ptr.add(8+1*::core::mem::size_of::<*const u8>()).cast::<usize>() = len4;
        *_param_ptr.add(8).cast::<*mut u8>() = ptr4.cast_mut();
      },
      V14::FloatList(e) => {
        *_param_ptr.add(0).cast::<u8>() = (8i32) as u8;
        let vec5 = <_ as Into<_rt::Vec<_>>>::into(e).into_boxed_slice();
        let ptr5 = vec5.as_ptr().cast::<u8>();
        let len5 = vec5.len();
        ::core::mem::forget(vec5);
        *_param_ptr.add(8+1*::core::mem::size_of::<*const u8>()).cast::<usize>() = len5;
        *_param_ptr.add(8).cast::<*mut u8>() = ptr5.cast_mut();
      },
      V14::StringList(e) => {
        *_param_ptr.add(0).cast::<u8>() = (9i32) as u8;
        let vec7 = e;
        let len7 = vec7.len();
        let layout7 = _rt::alloc::Layout::from_size_align(vec7.len() * (2*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>()).unwrap();
        let (result7, _cleanup7) = wit_bindgen::rt::Cleanup::new(layout7);if let Some(cleanup) = _cleanup7 { cleanup.forget(); }
        for (i, e) in vec7.into_iter().enumerate() {
          let base = result7.add(i * (2*::core::mem::size_of::<*const u8>()));
          {
            let vec6 = (e.into_bytes()).into_boxed_slice();
            let ptr6 = vec6.as_ptr().cast::<u8>();
            let len6 = vec6.len();
            ::core::mem::forget(vec6);
            *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len6;
            *base.add(0).cast::<*mut u8>() = ptr6.cast_mut();
          }
        }
        *_param_ptr.add(8+1*::core::mem::size_of::<*const u8>()).cast::<usize>() = len7;
        *_param_ptr.add(8).cast::<*mut u8>() = result7;
      },
      V14::BooleanList(e) => {
        *_param_ptr.add(0).cast::<u8>() = (10i32) as u8;
        let vec8 = e;
        let len8 = vec8.len();
        let layout8 = _rt::alloc::Layout::from_size_align(vec8.len() * 1, 1).unwrap();
        let (result8, _cleanup8) = wit_bindgen::rt::Cleanup::new(layout8);if let Some(cleanup) = _cleanup8 { cleanup.forget(); }
        for (i, e) in vec8.into_iter().enumerate() {
          let base = result8.add(i * 1);
          {
            *base.add(0).cast::<u8>() = (match e { true => 1, false => 0 }) as u8;
          }
        }
        *_param_ptr.add(8+1*::core::mem::size_of::<*const u8>()).cast::<usize>() = len8;
        *_param_ptr.add(8).cast::<*mut u8>() = result8;
      },
      V14::ColorList(e) => {
        *_param_ptr.add(0).cast::<u8>() = (11i32) as u8;
        let vec9 = <_ as Into<_rt::Vec<_>>>::into(e).into_boxed_slice();
        let ptr9 = vec9.as_ptr().cast::<u8>();
        let len9 = vec9.len();
        ::core::mem::forget(vec9);
        *_param_ptr.add(8+1*::core::mem::size_of::<*const u8>()).cast::<usize>() = len9;
        *_param_ptr.add(8).cast::<*mut u8>() = ptr9.cast_mut();
      },
      V14::DateList(e) => {
        *_param_ptr.add(0).cast::<u8>() = (12i32) as u8;
        let vec10 = <_ as Into<_rt::Vec<_>>>::into(e).into_boxed_slice();
        let ptr10 = vec10.as_ptr().cast::<u8>();
        let len10 = vec10.len();
        ::core::mem::forget(vec10);
        *_param_ptr.add(8+1*::core::mem::size_of::<*const u8>()).cast::<usize>() = len10;
        *_param_ptr.add(8).cast::<*mut u8>() = ptr10.cast_mut();
      },
      V14::TimeList(e) => {
        *_param_ptr.add(0).cast::<u8>() = (13i32) as u8;
        let vec11 = <_ as Into<_rt::Vec<_>>>::into(e).into_boxed_slice();
        let ptr11 = vec11.as_ptr().cast::<u8>();
        let len11 = vec11.len();
        ::core::mem::forget(vec11);
        *_param_ptr.add(8+1*::core::mem::size_of::<*const u8>()).cast::<usize>() = len11;
        *_param_ptr.add(8).cast::<*mut u8>() = ptr11.cast_mut();
      },
      V14::Trigger=> {
        {
          *_param_ptr.add(0).cast::<u8>() = (14i32) as u8;
        }
      }
      V14::Timestamp(e) => {
        *_param_ptr.add(0).cast::<u8>() = (15i32) as u8;
        *_param_ptr.add(8).cast::<i64>() = _rt::as_i64(e);
      },
      V14::Duration(e) => {
        *_param_ptr.add(0).cast::<u8>() = (16i32) as u8;
        *_param_ptr.add(8).cast::<i64>() = _rt::as_i64(e);
      },
      V14::Weekday(e) => {
        *_param_ptr.add(0).cast::<u8>() = (17i32) as u8;
        *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
      },
      V14::Light=> {
        {
          *_param_ptr.add(0).cast::<u8>() = (18i32) as u8;
        }
      }
      V14::Switch(e) => {
        *_param_ptr.add(0).cast::<u8>() = (19i32) as u8;
        *_param_ptr.add(8).cast::<u8>() = (match e { true => 1, false => 0 }) as u8;
      },
      V14::Dimmer(e) => {
        *_param_ptr.add(0).cast::<u8>() = (20i32) as u8;
        *_param_ptr.add(8).cast::<f64>() = _rt::as_f64(e);
      },
      V14::Switch(e) => {
        *_param_ptr.add(0).cast::<u8>() = (21i32) as u8;
        *_param_ptr.add(8).cast::<u8>() = (match e { true => 1, false => 0 }) as u8;
      },
      V14::ColorMode(e) => {
        *_param_ptr.add(0).cast::<u8>() = (22i32) as u8;
        *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
      },
      V14::ColorTemperature(e) => {
        *_param_ptr.add(0).cast::<u8>() = (23i32) as u8;
        *_param_ptr.add(8).cast::<i64>() = _rt::as_i64(e);
      },
      V14::Volume(e) => {
        *_param_ptr.add(0).cast::<u8>() = (24i32) as u8;
        *_param_ptr.add(8).cast::<f64>() = _rt::as_f64(e);
      },
      V14::Muted(e) => {
        *_param_ptr.add(0).cast::<u8>() = (25i32) as u8;
        *_param_ptr.add(8).cast::<u8>() = (match e { true => 1, false => 0 }) as u8;
      },
      V14::Config=> {
        {
          *_param_ptr.add(0).cast::<u8>() = (26i32) as u8;
        }
      }
      V14::Diagnostic=> {
        {
          *_param_ptr.add(0).cast::<u8>() = (27i32) as u8;
        }
      }
      V14::Siren=> {
        {
          *_param_ptr.add(0).cast::<u8>() = (28i32) as u8;
        }
      }
      V14::Sensor=> {
        {
          *_param_ptr.add(0).cast::<u8>() = (29i32) as u8;
        }
      }
      V14::Icon(e) => {
        *_param_ptr.add(0).cast::<u8>() = (30i32) as u8;
        let vec12 = (e.into_bytes()).into_boxed_slice();
        let ptr12 = vec12.as_ptr().cast::<u8>();
        let len12 = vec12.len();
        ::core::mem::forget(vec12);
        *_param_ptr.add(8+1*::core::mem::size_of::<*const u8>()).cast::<usize>() = len12;
        *_param_ptr.add(8).cast::<*mut u8>() = ptr12.cast_mut();
      },
      V14::AccuracyDecimals(e) => {
        *_param_ptr.add(0).cast::<u8>() = (31i32) as u8;
        *_param_ptr.add(8).cast::<i64>() = _rt::as_i64(e);
      },
      V14::DeviceClass(e) => {
        *_param_ptr.add(0).cast::<u8>() = (32i32) as u8;
        let vec13 = (e.into_bytes()).into_boxed_slice();
        let ptr13 = vec13.as_ptr().cast::<u8>();
        let len13 = vec13.len();
        ::core::mem::forget(vec13);
        *_param_ptr.add(8+1*::core::mem::size_of::<*const u8>()).cast::<usize>() = len13;
        *_param_ptr.add(8).cast::<*mut u8>() = ptr13.cast_mut();
      },
      V14::SensorStateClass(e) => {
        *_param_ptr.add(0).cast::<u8>() = (33i32) as u8;
        *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
      },
      V14::UnitApparentPower(e) => {
        *_param_ptr.add(0).cast::<u8>() = (34i32) as u8;
        *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
      },
      V14::UnitPower(e) => {
        *_param_ptr.add(0).cast::<u8>() = (35i32) as u8;
        *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
      },
      V14::UnitReactivePower(e) => {
        *_param_ptr.add(0).cast::<u8>() = (36i32) as u8;
        *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
      },
      V14::UnitEnergy(e) => {
        *_param_ptr.add(0).cast::<u8>() = (37i32) as u8;
        *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
      },
      V14::UnitElectricCurrent(e) => {
        *_param_ptr.add(0).cast::<u8>() = (38i32) as u8;
        *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
      },
      V14::UnitElectricPotential(e) => {
        *_param_ptr.add(0).cast::<u8>() = (39i32) as u8;
        *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
      },
      V14::UnitDegree(e) => {
        *_param_ptr.add(0).cast::<u8>() = (40i32) as u8;
        *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
      },
      V14::UnitCurrency(e) => {
        *_param_ptr.add(0).cast::<u8>() = (41i32) as u8;
        *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
      },
      V14::UnitTemperature(e) => {
        *_param_ptr.add(0).cast::<u8>() = (42i32) as u8;
        *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
      },
      V14::UnitTime(e) => {
        *_param_ptr.add(0).cast::<u8>() = (43i32) as u8;
        *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
      },
      V14::UnitLength(e) => {
        *_param_ptr.add(0).cast::<u8>() = (44i32) as u8;
        *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
      },
      V14::UnitFrequency(e) => {
        *_param_ptr.add(0).cast::<u8>() = (45i32) as u8;
        *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
      },
      V14::UnitPressure(e) => {
        *_param_ptr.add(0).cast::<u8>() = (46i32) as u8;
        *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
      },
      V14::UnitSoundPressure(e) => {
        *_param_ptr.add(0).cast::<u8>() = (47i32) as u8;
        *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
      },
      V14::UnitVolume(e) => {
        *_param_ptr.add(0).cast::<u8>() = (48i32) as u8;
        *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
      },
      V14::UnitVolumeFlowRate(e) => {
        *_param_ptr.add(0).cast::<u8>() = (49i32) as u8;
        *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
      },
      V14::UnitArea(e) => {
        *_param_ptr.add(0).cast::<u8>() = (50i32) as u8;
        *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
      },
      V14::UnitMass(e) => {
        *_param_ptr.add(0).cast::<u8>() = (51i32) as u8;
        *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
      },
      V14::UnitConductivity(e) => {
        *_param_ptr.add(0).cast::<u8>() = (52i32) as u8;
        *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
      },
      V14::UnitLight(e) => {
        *_param_ptr.add(0).cast::<u8>() = (53i32) as u8;
        *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
      },
      V14::UnitUvIndex(e) => {
        *_param_ptr.add(0).cast::<u8>() = (54i32) as u8;
        *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
      },
      V14::UnitPercentage(e) => {
        *_param_ptr.add(0).cast::<u8>() = (55i32) as u8;
        *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
      },
      V14::UnitIrradiation(e) => {
        *_param_ptr.add(0).cast::<u8>() = (56i32) as u8;
        *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
      },
      V14::UnitConcentration(e) => {
        *_param_ptr.add(0).cast::<u8>() = (57i32) as u8;
        *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
      },
      V14::UnitSpeed(e) => {
        *_param_ptr.add(0).cast::<u8>() = (58i32) as u8;
        *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
      },
      V14::UnitData(e) => {
        *_param_ptr.add(0).cast::<u8>() = (59i32) as u8;
        *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
      },
      V14::UnitDataRate(e) => {
        *_param_ptr.add(0).cast::<u8>() = (60i32) as u8;
        *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
      },
      V14::FanOscillation(e) => {
        *_param_ptr.add(0).cast::<u8>() = (61i32) as u8;
        *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
      },
      V14::FanDirection(e) => {
        *_param_ptr.add(0).cast::<u8>() = (62i32) as u8;
        *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
      },
      V14::FanSpeed(e) => {
        *_param_ptr.add(0).cast::<u8>() = (63i32) as u8;
        *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
      },
      V14::ClimateMode(e) => {
        *_param_ptr.add(0).cast::<u8>() = (64i32) as u8;
        *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
      },
      V14::LockState(e) => {
        *_param_ptr.add(0).cast::<u8>() = (65i32) as u8;
        *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
      },
      V14::MediaState(e) => {
        *_param_ptr.add(0).cast::<u8>() = (66i32) as u8;
        *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
      },
      V14::Cover=> {
        {
          *_param_ptr.add(0).cast::<u8>() = (67i32) as u8;
        }
      }
      V14::CoverState(e) => {
        *_param_ptr.add(0).cast::<u8>() = (68i32) as u8;
        *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
      },
      V14::Position(e) => {
        *_param_ptr.add(0).cast::<u8>() = (69i32) as u8;
        *_param_ptr.add(8).cast::<f64>() = _rt::as_f64(e);
      },
      V14::Tilt(e) => {
        *_param_ptr.add(0).cast::<u8>() = (70i32) as u8;
        *_param_ptr.add(8).cast::<f64>() = _rt::as_f64(e);
      },
      V14::Valve=> {
        {
          *_param_ptr.add(0).cast::<u8>() = (71i32) as u8;
        }
      }
      V14::ValveState(e) => {
        *_param_ptr.add(0).cast::<u8>() = (72i32) as u8;
        *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
      },
      V14::AlarmState(e) => {
        *_param_ptr.add(0).cast::<u8>() = (73i32) as u8;
        *_param_ptr.add(8).cast::<u8>() = (e.clone() as i32) as u8;
      },
    }
  }
  ParamsLower(_ptr,)
}
unsafe fn results_lift(&mut self, _ptr: *mut u8) -> Self::Results {
  unsafe { let l0 = i32::from(*_ptr.add(0).cast::<u8>());

  match l0 {
    0 => {
      let e = ();
      Ok(e)
    }
    1 => {
      let e = {
        let l1 = *_ptr.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
        let l2 = *_ptr.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>();
        let len3 = l2;
        let bytes3 = _rt::Vec::from_raw_parts(l1.cast(), len3, len3);

        _rt::string_lift(bytes3)
      };
      Err(e)
    }
    _ => _rt::invalid_enum_discriminant(),
  } }
}
}
_MySubtask { _unused: core::marker::PhantomData }.call((entity_index, component,)).await
}
}
#[allow(unused_unsafe, clippy::all)]
/// Custom function defined by extension
#[allow(async_fn_in_trait)]
pub async fn custom(name: _rt::String,params: _rt::String,) -> Result<(),_rt::String>{
  unsafe {

    #[derive(Copy, Clone)]
    struct ParamsLower(
    *mut u8, usize, *mut u8, usize, 
    );
    unsafe impl Send for ParamsLower {}
    

    use wit_bindgen::rt::async_support::Subtask as _Subtask;
    struct _MySubtask<'a> { _unused: core::marker::PhantomData<&'a ()> }
    #[allow(unused_parens)]
    unsafe impl<'a> _Subtask for _MySubtask<'a> {
      
      type Params = (_rt::String, _rt::String, );
      type Results = Result<(),_rt::String>;
      type ParamsLower = ParamsLower;
      fn abi_layout(&mut self) -> ::core::alloc::Layout {
        unsafe {
          ::core::alloc::Layout::from_size_align_unchecked((3*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>())
        }
      }
      
      fn results_offset(&mut self) -> usize { 0 }

      unsafe fn call_import(&mut self, _params: Self::ParamsLower, _results: *mut u8) -> u32 {
        
        #[cfg(target_arch = "wasm32")]
        #[link(wasm_import_module = "igloo:lib/core-to-extension-mp@0.1.0")]
        unsafe extern "C" {
          #[link_name = "[async-lower]custom"]
          fn call(_: *mut u8, _: usize, _: *mut u8, _: usize, _: *mut u8, ) -> i32;
        }

        #[cfg(not(target_arch = "wasm32"))]
        unsafe extern "C" fn call(_: *mut u8, _: usize, _: *mut u8, _: usize, _: *mut u8, ) -> i32 { unreachable!() }
        
        unsafe { call(_params.0,_params.1,_params.2,_params.3,_results) as u32 }
      }
      
      unsafe fn params_dealloc_lists(&mut self, _params: Self::ParamsLower) {
        unsafe { _rt::cabi_dealloc(_params.0, _params.1, 1);
        _rt::cabi_dealloc(_params.2, _params.3, 1);
      }
    }
    unsafe fn params_dealloc_lists_and_own(&mut self, _params: Self::ParamsLower) {
      unsafe { _rt::cabi_dealloc(_params.0, _params.1, 1);
      _rt::cabi_dealloc(_params.2, _params.3, 1);
    }
  }
  unsafe fn params_lower(&mut self, (_lower0, _lower1,): Self::Params, _ptr: *mut u8) -> Self::ParamsLower {
    unsafe { let vec0 = (_lower0.into_bytes()).into_boxed_slice();
    let ptr0 = vec0.as_ptr().cast::<u8>();
    let len0 = vec0.len();
    ::core::mem::forget(vec0);
    let vec1 = (_lower1.into_bytes()).into_boxed_slice();
    let ptr1 = vec1.as_ptr().cast::<u8>();
    let len1 = vec1.len();
    ::core::mem::forget(vec1);
    ParamsLower(ptr0.cast_mut(), len0, ptr1.cast_mut(), len1,) }
  }
  unsafe fn results_lift(&mut self, _ptr: *mut u8) -> Self::Results {
    unsafe { let l0 = i32::from(*_ptr.add(0).cast::<u8>());

    match l0 {
      0 => {
        let e = ();
        Ok(e)
      }
      1 => {
        let e = {
          let l1 = *_ptr.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
          let l2 = *_ptr.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>();
          let len3 = l2;
          let bytes3 = _rt::Vec::from_raw_parts(l1.cast(), len3, len3);

          _rt::string_lift(bytes3)
        };
        Err(e)
      }
      _ => _rt::invalid_enum_discriminant(),
    } }
  }
}
_MySubtask { _unused: core::marker::PhantomData }.call((name, params,)).await
}
}

}

}
}
mod _rt {
  #![allow(dead_code, unused_imports, clippy::all)]
  pub use alloc_crate::string::String;
  pub unsafe fn cabi_dealloc(ptr: *mut u8, size: usize, align: usize) {
    if size == 0 {
      return;
    }
    unsafe {
      let layout = alloc::Layout::from_size_align_unchecked(size, align);
      alloc::dealloc(ptr, layout);
    }
  }
  
  pub fn as_i64<T: AsI64>(t: T) -> i64 {
    t.as_i64()
  }

  pub trait AsI64 {
    fn as_i64(self) -> i64;
  }

  impl<'a, T: Copy + AsI64> AsI64 for &'a T {
    fn as_i64(self) -> i64 {
      (*self).as_i64()
    }
  }
  
  impl AsI64 for i64 {
    #[inline]
    fn as_i64(self) -> i64 {
      self as i64
    }
  }
  
  impl AsI64 for u64 {
    #[inline]
    fn as_i64(self) -> i64 {
      self as i64
    }
  }
  
  pub fn as_f64<T: AsF64>(t: T) -> f64 {
    t.as_f64()
  }

  pub trait AsF64 {
    fn as_f64(self) -> f64;
  }

  impl<'a, T: Copy + AsF64> AsF64 for &'a T {
    fn as_f64(self) -> f64 {
      (*self).as_f64()
    }
  }
  
  impl AsF64 for f64 {
    #[inline]
    fn as_f64(self) -> f64 {
      self as f64
    }
  }
  
  pub fn as_i32<T: AsI32>(t: T) -> i32 {
    t.as_i32()
  }

  pub trait AsI32 {
    fn as_i32(self) -> i32;
  }

  impl<'a, T: Copy + AsI32> AsI32 for &'a T {
    fn as_i32(self) -> i32 {
      (*self).as_i32()
    }
  }
  
  impl AsI32 for i32 {
    #[inline]
    fn as_i32(self) -> i32 {
      self as i32
    }
  }
  
  impl AsI32 for u32 {
    #[inline]
    fn as_i32(self) -> i32 {
      self as i32
    }
  }
  
  impl AsI32 for i16 {
    #[inline]
    fn as_i32(self) -> i32 {
      self as i32
    }
  }
  
  impl AsI32 for u16 {
    #[inline]
    fn as_i32(self) -> i32 {
      self as i32
    }
  }
  
  impl AsI32 for i8 {
    #[inline]
    fn as_i32(self) -> i32 {
      self as i32
    }
  }
  
  impl AsI32 for u8 {
    #[inline]
    fn as_i32(self) -> i32 {
      self as i32
    }
  }
  
  impl AsI32 for char {
    #[inline]
    fn as_i32(self) -> i32 {
      self as i32
    }
  }
  
  impl AsI32 for usize {
    #[inline]
    fn as_i32(self) -> i32 {
      self as i32
    }
  }
  pub use alloc_crate::vec::Vec;
  pub use alloc_crate::alloc;
  pub unsafe fn string_lift(bytes: Vec<u8>) -> String {
    if cfg!(debug_assertions) {
      String::from_utf8(bytes).unwrap()
    } else {
      unsafe { String::from_utf8_unchecked(bytes) }
    }
  }
  pub unsafe fn invalid_enum_discriminant<T>() -> T {
    if cfg!(debug_assertions) {
      panic!("invalid enum discriminant")
    } else {
      unsafe { core::hint::unreachable_unchecked() }
    }
  }
  extern crate alloc as alloc_crate;
}

#[cfg(target_arch = "wasm32")]
#[unsafe(link_section = "component-type:wit-bindgen:0.52.0:igloo:lib@0.1.0:core:encoded world")]
#[doc(hidden)]
#[allow(clippy::octal_escapes)]
pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 5062] = *b"\
\0asm\x0d\0\x01\0\0\x19\x16wit-component-encoding\x04\0\x07\xcb&\x01A\x02\x01A\x10\
\x01B\x0c\x01r\x01\x06packedw\x04\0\x09device-id\x03\0\0\x01r\x01\x06packedw\x04\
\0\x08group-id\x03\0\x02\x01r\x01\x05inners\x04\0\x0cextension-id\x03\0\x04\x01r\
\x01\x05innerw\x04\0\x0fextension-index\x03\0\x06\x01r\x01\x05inners\x04\0\x09en\
tity-id\x03\0\x08\x01r\x01\x05innerw\x04\0\x0centity-index\x03\0\x0a\x03\0\x12ig\
loo:lib/id@0.1.0\x05\0\x01B\x06\x01r\x03\x01ru\x01gu\x01bu\x04\0\x0bigloo-color\x03\
\0\0\x01r\x03\x04year{\x05month}\x03day}\x04\0\x0aigloo-date\x03\0\x02\x01r\x03\x04\
hour}\x06minute}\x06second}\x04\0\x0aigloo-time\x03\0\x04\x03\0\x18igloo:lib/com\
pound@0.1.0\x05\x01\x02\x03\0\x01\x0bigloo-color\x02\x03\0\x01\x0aigloo-date\x02\
\x03\0\x01\x0aigloo-time\x01B]\x02\x03\x02\x01\x02\x04\0\x0bigloo-color\x03\0\0\x02\
\x03\x02\x01\x03\x04\0\x0aigloo-date\x03\0\x02\x02\x03\x02\x01\x04\x04\0\x0aiglo\
o-time\x03\0\x04\x01m\x07\x06sunday\x06monday\x07tuesday\x09wednesday\x08thursda\
y\x06friday\x08saturday\x04\0\x07weekday\x03\0\x06\x01m\x02\x05r-g-b\x0btemperat\
ure\x04\0\x0acolor-mode\x03\0\x08\x01m\x03\x0bmeasurement\x10total-increasing\x05\
total\x04\0\x12sensor-state-class\x03\0\x0a\x01m\x01\x0cvolt-amperes\x04\0\x13un\
it-apparent-power\x03\0\x0c\x01m\x03\x05watts\x0akilo-watts\x0dbtus-per-hour\x04\
\0\x0aunit-power\x03\0\x0e\x01m\x01\x14volt-ampere-reactive\x04\0\x13unit-reacti\
ve-power\x03\0\x10\x01m\x03\x0awatt-hours\x0fkilo-watt-hours\x0fmega-watt-hours\x04\
\0\x0bunit-energy\x03\0\x12\x01m\x02\x0cmilliamperes\x07amperes\x04\0\x15unit-el\
ectric-current\x03\0\x14\x01m\x02\x0amillivolts\x05volts\x04\0\x17unit-electric-\
potential\x03\0\x16\x01m\x01\x07degrees\x04\0\x0bunit-degree\x03\0\x18\x01m\x03\x05\
euros\x07dollars\x05cents\x04\0\x0dunit-currency\x03\0\x1a\x01m\x03\x07celsius\x0a\
fahrenheit\x06kelvin\x04\0\x10unit-temperature\x03\0\x1c\x01m\x09\x0cmicrosecond\
s\x0cmilliseconds\x07seconds\x07minutes\x05hours\x04days\x05weeks\x06months\x05y\
ears\x04\0\x09unit-time\x03\0\x1e\x01m\x08\x0bmillimeters\x0bcentimeters\x06mete\
rs\x0akilometers\x06inches\x04feet\x04yard\x05miles\x04\0\x0bunit-length\x03\0\x20\
\x01m\x04\x05hertz\x09kilohertz\x09megahertz\x09gigahertz\x04\0\x0eunit-frequenc\
y\x03\0\"\x01m\x09\x06pascal\x0bhectopascal\x0akilopascal\x03bar\x08centibar\x08\
millibar\x12millimeter-mercury\x0cinch-mercury\x03psi\x04\0\x0dunit-pressure\x03\
\0$\x01m\x03\x07decibel\x12decibel-a-weighted\x12decibels-milliwatt\x04\0\x13uni\
t-sound-pressure\x03\0&\x01m\x06\x06liters\x0bmilliliters\x0ccubic-meters\x0acub\
ic-feet\x07gallons\x0bfluid-ounce\x04\0\x0bunit-volume\x03\0(\x01m\x02\x15cubic-\
meters-per-hour\x15cubic-feet-per-minute\x04\0\x15unit-volume-flow-rate\x03\0*\x01\
m\x01\x0dsquare-meters\x04\0\x09unit-area\x03\0,\x01m\x06\x05grams\x09kilograms\x0a\
milligrams\x0amicrograms\x06ounces\x06pounds\x04\0\x09unit-mass\x03\0.\x01m\x01\x1b\
microsiemens-per-centimeter\x04\0\x11unit-conductivity\x03\00\x01m\x01\x03lux\x04\
\0\x0aunit-light\x03\02\x01m\x01\x08uv-index\x04\0\x0dunit-uv-index\x03\04\x01m\x01\
\x0apercentage\x04\0\x0funit-percentage\x03\06\x01m\x02\x16watts-per-square-mete\
r\x19btus-per-hour-square-foot\x04\0\x10unit-irradiation\x03\08\x01m\x06\x1amicr\
ograms-per-cubic-meter\x1amilligrams-per-cubic-meter\x19micrograms-per-cubic-foo\
t\x15parts-per-cubic-meter\x11parts-per-million\x11parts-per-billion\x04\0\x12un\
it-concentration\x03\0:\x01m\x09\x13millimeters-per-day\x14millimeters-per-hour\x0f\
feet-per-second\x0einches-per-day\x11meters-per-second\x0finches-per-hour\x13kil\
ometers-per-hour\x05knots\x0emiles-per-hour\x04\0\x0aunit-speed\x03\0<\x01m\x15\x04\
bits\x08kilobits\x08megabits\x08gigabits\x05bytes\x09kilobytes\x09megabytes\x09g\
igabytes\x09terabytes\x09petabytes\x08exabytes\x0azettabytes\x0ayottabytes\x09ki\
bibytes\x09mebibytes\x09gibibytes\x09tebibytes\x09pebibytes\x09exbibytes\x09zebi\
bytes\x09yobibytes\x04\0\x09unit-data\x03\0>\x01m\x0b\x0fbits-per-second\x13kilo\
bits-per-second\x13megabits-per-second\x13gigabits-per-second\x10bytes-per-secon\
d\x14kilobytes-per-second\x14megabytes-per-second\x14gigabytes-per-second\x14kib\
ibytes-per-second\x14mebibytes-per-second\x14gibibytes-per-second\x04\0\x0eunit-\
data-rate\x03\0@\x01m\x05\x03off\x02on\x08vertical\x0ahorizontal\x04both\x04\0\x0f\
fan-oscillation\x03\0B\x01m\x02\x07forward\x07reverse\x04\0\x0dfan-direction\x03\
\0D\x01m\x0a\x02on\x03off\x04auto\x03low\x06medium\x04high\x06middle\x05focus\x07\
diffuse\x05quiet\x04\0\x09fan-speed\x03\0F\x01m\x08\x03off\x04auto\x04heat\x04co\
ol\x09heat-cool\x08fan-only\x03dry\x03eco\x04\0\x0cclimate-mode\x03\0H\x01m\x06\x07\
unknown\x06locked\x08unlocked\x06jammed\x07locking\x09unlocking\x04\0\x0alock-st\
ate\x03\0J\x01m\x04\x07unknown\x04idle\x07playing\x06paused\x04\0\x0bmedia-state\
\x03\0L\x01m\x06\x04idle\x07opening\x07closing\x07stopped\x04open\x06closed\x04\0\
\x0bcover-state\x03\0N\x01m\x03\x04idle\x07opening\x07closing\x04\0\x0bvalve-sta\
te\x03\0P\x01m\x0a\x08disarmed\x0aarmed-home\x0aarmed-away\x0barmed-night\x0earm\
ed-vacation\x0darmed-unknown\x07pending\x09triggered\x06arming\x09disarming\x04\0\
\x0balarm-state\x03\0R\x01px\x01pu\x01ps\x01p\x7f\x01p\x01\x01p\x03\x01p\x05\x01\
qJ\x07integer\x01x\0\x05float\x01u\0\x06string\x01s\0\x04bool\x01\x7f\0\x05color\
\x01\x01\0\x04date\x01\x03\0\x04time\x01\x05\0\x0cinteger-list\x01\xd4\0\0\x0afl\
oat-list\x01\xd5\0\0\x0bstring-list\x01\xd6\0\0\x0cboolean-list\x01\xd7\0\0\x0ac\
olor-list\x01\xd8\0\0\x09date-list\x01\xd9\0\0\x09time-list\x01\xda\0\0\x07trigg\
er\0\0\x09timestamp\x01x\0\x08duration\x01x\0\x07weekday\x01\x07\0\x05light\0\0\x06\
switch\x01\x7f\0\x06dimmer\x01u\0\x06switch\x01\x7f\0\x0acolor-mode\x01\x09\0\x11\
color-temperature\x01x\0\x06volume\x01u\0\x05muted\x01\x7f\0\x06config\0\0\x0adi\
agnostic\0\0\x05siren\0\0\x06sensor\0\0\x04icon\x01s\0\x11accuracy-decimals\x01x\
\0\x0cdevice-class\x01s\0\x12sensor-state-class\x01\x0b\0\x13unit-apparent-power\
\x01\x0d\0\x0aunit-power\x01\x0f\0\x13unit-reactive-power\x01\x11\0\x0bunit-ener\
gy\x01\x13\0\x15unit-electric-current\x01\x15\0\x17unit-electric-potential\x01\x17\
\0\x0bunit-degree\x01\x19\0\x0dunit-currency\x01\x1b\0\x10unit-temperature\x01\x1d\
\0\x09unit-time\x01\x1f\0\x0bunit-length\x01!\0\x0eunit-frequency\x01#\0\x0dunit\
-pressure\x01%\0\x13unit-sound-pressure\x01'\0\x0bunit-volume\x01)\0\x15unit-vol\
ume-flow-rate\x01+\0\x09unit-area\x01-\0\x09unit-mass\x01/\0\x11unit-conductivit\
y\x011\0\x0aunit-light\x013\0\x0dunit-uv-index\x015\0\x0funit-percentage\x017\0\x10\
unit-irradiation\x019\0\x12unit-concentration\x01;\0\x0aunit-speed\x01=\0\x09uni\
t-data\x01?\0\x0eunit-data-rate\x01\xc1\0\0\x0ffan-oscillation\x01\xc3\0\0\x0dfa\
n-direction\x01\xc5\0\0\x09fan-speed\x01\xc7\0\0\x0cclimate-mode\x01\xc9\0\0\x0a\
lock-state\x01\xcb\0\0\x0bmedia-state\x01\xcd\0\0\x05cover\0\0\x0bcover-state\x01\
\xcf\0\0\x08position\x01u\0\x04tilt\x01u\0\x05valve\0\0\x0bvalve-state\x01\xd1\0\
\0\x0balarm-state\x01\xd3\0\0\x04\0\x09component\x03\0[\x03\0\x19igloo:lib/compo\
nent@0.1.0\x05\x05\x02\x03\0\0\x09device-id\x02\x03\0\0\x0centity-index\x02\x03\0\
\x02\x09component\x01B\x0d\x02\x03\x02\x01\x06\x04\0\x09device-id\x03\0\0\x02\x03\
\x02\x01\x07\x04\0\x0centity-index\x03\0\x02\x02\x03\x02\x01\x08\x04\0\x09compon\
ent\x03\0\x04\x01j\0\x01s\x01C\x03\x09device-id\x01\x0centity-index\x03\x09compo\
nent\x05\0\x06\x04\0\x0dput-component\x01\x07\x01C\x01\x09device-id\x01\0\x06\x04\
\0\x0ddelete-device\x01\x08\x01C\x02\x04names\x06paramss\0\x06\x04\0\x06custom\x01\
\x09\x03\0$igloo:lib/core-to-extension-sp@0.1.0\x05\x09\x01B\x09\x02\x03\x02\x01\
\x07\x04\0\x0centity-index\x03\0\0\x02\x03\x02\x01\x08\x04\0\x09component\x03\0\x02\
\x01j\0\x01s\x01C\x02\x0centity-index\x01\x09component\x03\0\x04\x04\0\x0dput-co\
mponent\x01\x05\x01C\x02\x04names\x06paramss\0\x04\x04\0\x06custom\x01\x06\x03\0\
$igloo:lib/core-to-extension-mp@0.1.0\x05\x0a\x04\0\x14igloo:lib/core@0.1.0\x04\0\
\x0b\x0a\x01\0\x04core\x03\0\0\0G\x09producers\x01\x0cprocessed-by\x02\x0dwit-co\
mponent\x070.244.0\x10wit-bindgen-rust\x060.52.0";

#[inline(never)]
#[doc(hidden)]
pub fn __link_custom_section_describing_imports() {
  wit_bindgen::rt::maybe_link_cabi_realloc();
}

