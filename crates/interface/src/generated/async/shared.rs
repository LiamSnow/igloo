// Generated by `wit-bindgen` 0.52.0. DO NOT EDIT!
// Options used:
//   * additional derives ["PartialEq", "serde::Serialize", "serde::Deserialize"]
//   * generate_unused_types
//   * async: all
#[allow(dead_code, clippy::all)]
pub mod igloo {
  pub mod lib {

    #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
    pub mod id {
      #[used]
      #[doc(hidden)]
      static __FORCE_SECTION_REF: fn() =
      super::super::super::__link_custom_section_describing_imports;
      
      use super::super::super::_rt;
      /// Persistent
      #[repr(C)]
      #[derive(Clone, Copy, PartialEq, serde::Deserialize, serde::Serialize)]
      pub struct DeviceId {
        pub packed: u64,
      }
      impl ::core::fmt::Debug for DeviceId {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("DeviceId").field("packed", &self.packed).finish()
        }
      }
      /// Persistent
      #[repr(C)]
      #[derive(Clone, Copy, PartialEq, serde::Deserialize, serde::Serialize)]
      pub struct GroupId {
        pub packed: u64,
      }
      impl ::core::fmt::Debug for GroupId {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("GroupId").field("packed", &self.packed).finish()
        }
      }
      /// Persistent
      #[derive(Clone, PartialEq, serde::Deserialize, serde::Serialize)]
      pub struct ExtensionId {
        pub inner: _rt::String,
      }
      impl ::core::fmt::Debug for ExtensionId {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("ExtensionId").field("inner", &self.inner).finish()
        }
      }
      /// Ephemeral
      #[repr(C)]
      #[derive(Clone, Copy, PartialEq, serde::Deserialize, serde::Serialize)]
      pub struct ExtensionIndex {
        pub inner: u64,
      }
      impl ::core::fmt::Debug for ExtensionIndex {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("ExtensionIndex").field("inner", &self.inner).finish()
        }
      }
      /// Persistent
      #[derive(Clone, PartialEq, serde::Deserialize, serde::Serialize)]
      pub struct EntityId {
        pub inner: _rt::String,
      }
      impl ::core::fmt::Debug for EntityId {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("EntityId").field("inner", &self.inner).finish()
        }
      }
      /// Ephemeral
      #[repr(C)]
      #[derive(Clone, Copy, PartialEq, serde::Deserialize, serde::Serialize)]
      pub struct EntityIndex {
        pub inner: u64,
      }
      impl ::core::fmt::Debug for EntityIndex {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("EntityIndex").field("inner", &self.inner).finish()
        }
      }

    }


    #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
    pub mod compound {
      #[used]
      #[doc(hidden)]
      static __FORCE_SECTION_REF: fn() =
      super::super::super::__link_custom_section_describing_imports;
      
      #[repr(C)]
      #[derive(Clone, Copy, PartialEq, serde::Deserialize, serde::Serialize)]
      pub struct IglooColor {
        /// 0.0 to 1.0
        pub r: f64,
        /// 0.0 to 1.0
        pub g: f64,
        /// 0.0 to 1.0
        pub b: f64,
      }
      impl ::core::fmt::Debug for IglooColor {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("IglooColor").field("r", &self.r).field("g", &self.g).field("b", &self.b).finish()
        }
      }
      #[repr(C)]
      #[derive(Clone, Copy, PartialEq, serde::Deserialize, serde::Serialize)]
      pub struct IglooDate {
        pub year: u16,
        pub month: u8,
        pub day: u8,
      }
      impl ::core::fmt::Debug for IglooDate {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("IglooDate").field("year", &self.year).field("month", &self.month).field("day", &self.day).finish()
        }
      }
      #[repr(C)]
      #[derive(Clone, Copy, PartialEq, serde::Deserialize, serde::Serialize)]
      pub struct IglooTime {
        pub hour: u8,
        pub minute: u8,
        pub second: u8,
      }
      impl ::core::fmt::Debug for IglooTime {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("IglooTime").field("hour", &self.hour).field("minute", &self.minute).field("second", &self.second).finish()
        }
      }

    }

    /// DO NOT MODIFY This file is generated by xtask
    #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
    pub mod component {
      #[used]
      #[doc(hidden)]
      static __FORCE_SECTION_REF: fn() =
      super::super::super::__link_custom_section_describing_imports;
      
      use super::super::super::_rt;
      pub type IglooColor = super::super::super::igloo::lib::compound::IglooColor;
      pub type IglooDate = super::super::super::igloo::lib::compound::IglooDate;
      pub type IglooTime = super::super::super::igloo::lib::compound::IglooTime;
      #[repr(u8)]
      #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd, serde::Deserialize, serde::Serialize)]
      pub enum Weekday {
        Sunday,
        Monday,
        Tuesday,
        Wednesday,
        Thursday,
        Friday,
        Saturday,
      }
      impl ::core::fmt::Debug for Weekday {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            Weekday::Sunday => {
              f.debug_tuple("Weekday::Sunday").finish()
            }
            Weekday::Monday => {
              f.debug_tuple("Weekday::Monday").finish()
            }
            Weekday::Tuesday => {
              f.debug_tuple("Weekday::Tuesday").finish()
            }
            Weekday::Wednesday => {
              f.debug_tuple("Weekday::Wednesday").finish()
            }
            Weekday::Thursday => {
              f.debug_tuple("Weekday::Thursday").finish()
            }
            Weekday::Friday => {
              f.debug_tuple("Weekday::Friday").finish()
            }
            Weekday::Saturday => {
              f.debug_tuple("Weekday::Saturday").finish()
            }
          }
        }
      }

      impl Weekday{
        #[doc(hidden)]
        pub unsafe fn _lift(val: u8) -> Weekday{
          if !cfg!(debug_assertions) {
            return unsafe { ::core::mem::transmute(val) };
          }

          match val {
            0 => Weekday::Sunday,
            1 => Weekday::Monday,
            2 => Weekday::Tuesday,
            3 => Weekday::Wednesday,
            4 => Weekday::Thursday,
            5 => Weekday::Friday,
            6 => Weekday::Saturday,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }

      #[repr(u8)]
      #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd, serde::Deserialize, serde::Serialize)]
      pub enum ColorMode {
        RGB,
        Temperature,
      }
      impl ::core::fmt::Debug for ColorMode {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            ColorMode::RGB => {
              f.debug_tuple("ColorMode::RGB").finish()
            }
            ColorMode::Temperature => {
              f.debug_tuple("ColorMode::Temperature").finish()
            }
          }
        }
      }

      impl ColorMode{
        #[doc(hidden)]
        pub unsafe fn _lift(val: u8) -> ColorMode{
          if !cfg!(debug_assertions) {
            return unsafe { ::core::mem::transmute(val) };
          }

          match val {
            0 => ColorMode::RGB,
            1 => ColorMode::Temperature,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }

      #[repr(u8)]
      #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd, serde::Deserialize, serde::Serialize)]
      pub enum SensorStateClass {
        Measurement,
        TotalIncreasing,
        Total,
      }
      impl ::core::fmt::Debug for SensorStateClass {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            SensorStateClass::Measurement => {
              f.debug_tuple("SensorStateClass::Measurement").finish()
            }
            SensorStateClass::TotalIncreasing => {
              f.debug_tuple("SensorStateClass::TotalIncreasing").finish()
            }
            SensorStateClass::Total => {
              f.debug_tuple("SensorStateClass::Total").finish()
            }
          }
        }
      }

      impl SensorStateClass{
        #[doc(hidden)]
        pub unsafe fn _lift(val: u8) -> SensorStateClass{
          if !cfg!(debug_assertions) {
            return unsafe { ::core::mem::transmute(val) };
          }

          match val {
            0 => SensorStateClass::Measurement,
            1 => SensorStateClass::TotalIncreasing,
            2 => SensorStateClass::Total,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }

      #[repr(u8)]
      #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd, serde::Deserialize, serde::Serialize)]
      pub enum UnitApparentPower {
        /// VA
        VoltAmperes,
      }
      impl ::core::fmt::Debug for UnitApparentPower {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            UnitApparentPower::VoltAmperes => {
              f.debug_tuple("UnitApparentPower::VoltAmperes").finish()
            }
          }
        }
      }

      impl UnitApparentPower{
        #[doc(hidden)]
        pub unsafe fn _lift(val: u8) -> UnitApparentPower{
          if !cfg!(debug_assertions) {
            return unsafe { ::core::mem::transmute(val) };
          }

          match val {
            0 => UnitApparentPower::VoltAmperes,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }

      #[repr(u8)]
      #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd, serde::Deserialize, serde::Serialize)]
      pub enum UnitPower {
        /// W, watt, watts
        Watts,
        /// kW, kw, kilowatt, kilowatts
        KiloWatts,
        /// BTU/h
        BtusPerHour,
      }
      impl ::core::fmt::Debug for UnitPower {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            UnitPower::Watts => {
              f.debug_tuple("UnitPower::Watts").finish()
            }
            UnitPower::KiloWatts => {
              f.debug_tuple("UnitPower::KiloWatts").finish()
            }
            UnitPower::BtusPerHour => {
              f.debug_tuple("UnitPower::BtusPerHour").finish()
            }
          }
        }
      }

      impl UnitPower{
        #[doc(hidden)]
        pub unsafe fn _lift(val: u8) -> UnitPower{
          if !cfg!(debug_assertions) {
            return unsafe { ::core::mem::transmute(val) };
          }

          match val {
            0 => UnitPower::Watts,
            1 => UnitPower::KiloWatts,
            2 => UnitPower::BtusPerHour,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }

      #[repr(u8)]
      #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd, serde::Deserialize, serde::Serialize)]
      pub enum UnitReactivePower {
        /// var
        VoltAmpereReactive,
      }
      impl ::core::fmt::Debug for UnitReactivePower {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            UnitReactivePower::VoltAmpereReactive => {
              f.debug_tuple("UnitReactivePower::VoltAmpereReactive").finish()
            }
          }
        }
      }

      impl UnitReactivePower{
        #[doc(hidden)]
        pub unsafe fn _lift(val: u8) -> UnitReactivePower{
          if !cfg!(debug_assertions) {
            return unsafe { ::core::mem::transmute(val) };
          }

          match val {
            0 => UnitReactivePower::VoltAmpereReactive,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }

      #[repr(u8)]
      #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd, serde::Deserialize, serde::Serialize)]
      pub enum UnitEnergy {
        /// Wh
        WattHours,
        /// kWh
        KiloWattHours,
        /// MWh
        MegaWattHours,
      }
      impl ::core::fmt::Debug for UnitEnergy {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            UnitEnergy::WattHours => {
              f.debug_tuple("UnitEnergy::WattHours").finish()
            }
            UnitEnergy::KiloWattHours => {
              f.debug_tuple("UnitEnergy::KiloWattHours").finish()
            }
            UnitEnergy::MegaWattHours => {
              f.debug_tuple("UnitEnergy::MegaWattHours").finish()
            }
          }
        }
      }

      impl UnitEnergy{
        #[doc(hidden)]
        pub unsafe fn _lift(val: u8) -> UnitEnergy{
          if !cfg!(debug_assertions) {
            return unsafe { ::core::mem::transmute(val) };
          }

          match val {
            0 => UnitEnergy::WattHours,
            1 => UnitEnergy::KiloWattHours,
            2 => UnitEnergy::MegaWattHours,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }

      #[repr(u8)]
      #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd, serde::Deserialize, serde::Serialize)]
      pub enum UnitElectricCurrent {
        /// mA, milliampere, milliamperes, milliamps, milliamp
        Milliamperes,
        /// A, amps, amp, ampere, amperes
        Amperes,
      }
      impl ::core::fmt::Debug for UnitElectricCurrent {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            UnitElectricCurrent::Milliamperes => {
              f.debug_tuple("UnitElectricCurrent::Milliamperes").finish()
            }
            UnitElectricCurrent::Amperes => {
              f.debug_tuple("UnitElectricCurrent::Amperes").finish()
            }
          }
        }
      }

      impl UnitElectricCurrent{
        #[doc(hidden)]
        pub unsafe fn _lift(val: u8) -> UnitElectricCurrent{
          if !cfg!(debug_assertions) {
            return unsafe { ::core::mem::transmute(val) };
          }

          match val {
            0 => UnitElectricCurrent::Milliamperes,
            1 => UnitElectricCurrent::Amperes,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }

      #[repr(u8)]
      #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd, serde::Deserialize, serde::Serialize)]
      pub enum UnitElectricPotential {
        /// mV, millivolts
        Millivolts,
        /// V, volt, volts
        Volts,
      }
      impl ::core::fmt::Debug for UnitElectricPotential {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            UnitElectricPotential::Millivolts => {
              f.debug_tuple("UnitElectricPotential::Millivolts").finish()
            }
            UnitElectricPotential::Volts => {
              f.debug_tuple("UnitElectricPotential::Volts").finish()
            }
          }
        }
      }

      impl UnitElectricPotential{
        #[doc(hidden)]
        pub unsafe fn _lift(val: u8) -> UnitElectricPotential{
          if !cfg!(debug_assertions) {
            return unsafe { ::core::mem::transmute(val) };
          }

          match val {
            0 => UnitElectricPotential::Millivolts,
            1 => UnitElectricPotential::Volts,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }

      #[repr(u8)]
      #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd, serde::Deserialize, serde::Serialize)]
      pub enum UnitDegree {
        /// °, degree, degrees
        Degrees,
      }
      impl ::core::fmt::Debug for UnitDegree {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            UnitDegree::Degrees => {
              f.debug_tuple("UnitDegree::Degrees").finish()
            }
          }
        }
      }

      impl UnitDegree{
        #[doc(hidden)]
        pub unsafe fn _lift(val: u8) -> UnitDegree{
          if !cfg!(debug_assertions) {
            return unsafe { ::core::mem::transmute(val) };
          }

          match val {
            0 => UnitDegree::Degrees,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }

      #[repr(u8)]
      #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd, serde::Deserialize, serde::Serialize)]
      pub enum UnitCurrency {
        /// €, euro, euros
        Euros,
        /// $, dollar, dollars
        Dollars,
        /// ¢, cent, cents
        Cents,
      }
      impl ::core::fmt::Debug for UnitCurrency {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            UnitCurrency::Euros => {
              f.debug_tuple("UnitCurrency::Euros").finish()
            }
            UnitCurrency::Dollars => {
              f.debug_tuple("UnitCurrency::Dollars").finish()
            }
            UnitCurrency::Cents => {
              f.debug_tuple("UnitCurrency::Cents").finish()
            }
          }
        }
      }

      impl UnitCurrency{
        #[doc(hidden)]
        pub unsafe fn _lift(val: u8) -> UnitCurrency{
          if !cfg!(debug_assertions) {
            return unsafe { ::core::mem::transmute(val) };
          }

          match val {
            0 => UnitCurrency::Euros,
            1 => UnitCurrency::Dollars,
            2 => UnitCurrency::Cents,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }

      #[repr(u8)]
      #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd, serde::Deserialize, serde::Serialize)]
      pub enum UnitTemperature {
        /// °C, celcius
        Celsius,
        /// °F, fahrenheit
        Fahrenheit,
        /// K, kelvin
        Kelvin,
      }
      impl ::core::fmt::Debug for UnitTemperature {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            UnitTemperature::Celsius => {
              f.debug_tuple("UnitTemperature::Celsius").finish()
            }
            UnitTemperature::Fahrenheit => {
              f.debug_tuple("UnitTemperature::Fahrenheit").finish()
            }
            UnitTemperature::Kelvin => {
              f.debug_tuple("UnitTemperature::Kelvin").finish()
            }
          }
        }
      }

      impl UnitTemperature{
        #[doc(hidden)]
        pub unsafe fn _lift(val: u8) -> UnitTemperature{
          if !cfg!(debug_assertions) {
            return unsafe { ::core::mem::transmute(val) };
          }

          match val {
            0 => UnitTemperature::Celsius,
            1 => UnitTemperature::Fahrenheit,
            2 => UnitTemperature::Kelvin,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }

      #[repr(u8)]
      #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd, serde::Deserialize, serde::Serialize)]
      pub enum UnitTime {
        /// μs, us, microseconds
        Microseconds,
        /// ms, milliseconds
        Milliseconds,
        /// s, seconds
        Seconds,
        /// min, mins, minute, minutes
        Minutes,
        /// h, hour, hours
        Hours,
        /// d, day, days
        Days,
        /// w, wk, wks, week, weeks
        Weeks,
        /// month, months
        Months,
        /// y, year, years
        Years,
      }
      impl ::core::fmt::Debug for UnitTime {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            UnitTime::Microseconds => {
              f.debug_tuple("UnitTime::Microseconds").finish()
            }
            UnitTime::Milliseconds => {
              f.debug_tuple("UnitTime::Milliseconds").finish()
            }
            UnitTime::Seconds => {
              f.debug_tuple("UnitTime::Seconds").finish()
            }
            UnitTime::Minutes => {
              f.debug_tuple("UnitTime::Minutes").finish()
            }
            UnitTime::Hours => {
              f.debug_tuple("UnitTime::Hours").finish()
            }
            UnitTime::Days => {
              f.debug_tuple("UnitTime::Days").finish()
            }
            UnitTime::Weeks => {
              f.debug_tuple("UnitTime::Weeks").finish()
            }
            UnitTime::Months => {
              f.debug_tuple("UnitTime::Months").finish()
            }
            UnitTime::Years => {
              f.debug_tuple("UnitTime::Years").finish()
            }
          }
        }
      }

      impl UnitTime{
        #[doc(hidden)]
        pub unsafe fn _lift(val: u8) -> UnitTime{
          if !cfg!(debug_assertions) {
            return unsafe { ::core::mem::transmute(val) };
          }

          match val {
            0 => UnitTime::Microseconds,
            1 => UnitTime::Milliseconds,
            2 => UnitTime::Seconds,
            3 => UnitTime::Minutes,
            4 => UnitTime::Hours,
            5 => UnitTime::Days,
            6 => UnitTime::Weeks,
            7 => UnitTime::Months,
            8 => UnitTime::Years,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }

      #[repr(u8)]
      #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd, serde::Deserialize, serde::Serialize)]
      pub enum UnitLength {
        /// mm
        Millimeters,
        /// cm
        Centimeters,
        /// m
        Meters,
        /// km
        Kilometers,
        /// in
        Inches,
        /// ft
        Feet,
        /// yd
        Yard,
        /// mi
        Miles,
      }
      impl ::core::fmt::Debug for UnitLength {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            UnitLength::Millimeters => {
              f.debug_tuple("UnitLength::Millimeters").finish()
            }
            UnitLength::Centimeters => {
              f.debug_tuple("UnitLength::Centimeters").finish()
            }
            UnitLength::Meters => {
              f.debug_tuple("UnitLength::Meters").finish()
            }
            UnitLength::Kilometers => {
              f.debug_tuple("UnitLength::Kilometers").finish()
            }
            UnitLength::Inches => {
              f.debug_tuple("UnitLength::Inches").finish()
            }
            UnitLength::Feet => {
              f.debug_tuple("UnitLength::Feet").finish()
            }
            UnitLength::Yard => {
              f.debug_tuple("UnitLength::Yard").finish()
            }
            UnitLength::Miles => {
              f.debug_tuple("UnitLength::Miles").finish()
            }
          }
        }
      }

      impl UnitLength{
        #[doc(hidden)]
        pub unsafe fn _lift(val: u8) -> UnitLength{
          if !cfg!(debug_assertions) {
            return unsafe { ::core::mem::transmute(val) };
          }

          match val {
            0 => UnitLength::Millimeters,
            1 => UnitLength::Centimeters,
            2 => UnitLength::Meters,
            3 => UnitLength::Kilometers,
            4 => UnitLength::Inches,
            5 => UnitLength::Feet,
            6 => UnitLength::Yard,
            7 => UnitLength::Miles,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }

      #[repr(u8)]
      #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd, serde::Deserialize, serde::Serialize)]
      pub enum UnitFrequency {
        /// Hz
        Hertz,
        /// kHz
        Kilohertz,
        /// MHz
        Megahertz,
        /// GHz
        Gigahertz,
      }
      impl ::core::fmt::Debug for UnitFrequency {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            UnitFrequency::Hertz => {
              f.debug_tuple("UnitFrequency::Hertz").finish()
            }
            UnitFrequency::Kilohertz => {
              f.debug_tuple("UnitFrequency::Kilohertz").finish()
            }
            UnitFrequency::Megahertz => {
              f.debug_tuple("UnitFrequency::Megahertz").finish()
            }
            UnitFrequency::Gigahertz => {
              f.debug_tuple("UnitFrequency::Gigahertz").finish()
            }
          }
        }
      }

      impl UnitFrequency{
        #[doc(hidden)]
        pub unsafe fn _lift(val: u8) -> UnitFrequency{
          if !cfg!(debug_assertions) {
            return unsafe { ::core::mem::transmute(val) };
          }

          match val {
            0 => UnitFrequency::Hertz,
            1 => UnitFrequency::Kilohertz,
            2 => UnitFrequency::Megahertz,
            3 => UnitFrequency::Gigahertz,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }

      #[repr(u8)]
      #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd, serde::Deserialize, serde::Serialize)]
      pub enum UnitPressure {
        /// Pa
        Pascal,
        /// hPa
        Hectopascal,
        /// kPa
        Kilopascal,
        /// bar
        Bar,
        /// cbar
        Centibar,
        /// mbar
        Millibar,
        /// mmHg
        MillimeterMercury,
        /// inHg
        InchMercury,
        /// psi
        Psi,
      }
      impl ::core::fmt::Debug for UnitPressure {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            UnitPressure::Pascal => {
              f.debug_tuple("UnitPressure::Pascal").finish()
            }
            UnitPressure::Hectopascal => {
              f.debug_tuple("UnitPressure::Hectopascal").finish()
            }
            UnitPressure::Kilopascal => {
              f.debug_tuple("UnitPressure::Kilopascal").finish()
            }
            UnitPressure::Bar => {
              f.debug_tuple("UnitPressure::Bar").finish()
            }
            UnitPressure::Centibar => {
              f.debug_tuple("UnitPressure::Centibar").finish()
            }
            UnitPressure::Millibar => {
              f.debug_tuple("UnitPressure::Millibar").finish()
            }
            UnitPressure::MillimeterMercury => {
              f.debug_tuple("UnitPressure::MillimeterMercury").finish()
            }
            UnitPressure::InchMercury => {
              f.debug_tuple("UnitPressure::InchMercury").finish()
            }
            UnitPressure::Psi => {
              f.debug_tuple("UnitPressure::Psi").finish()
            }
          }
        }
      }

      impl UnitPressure{
        #[doc(hidden)]
        pub unsafe fn _lift(val: u8) -> UnitPressure{
          if !cfg!(debug_assertions) {
            return unsafe { ::core::mem::transmute(val) };
          }

          match val {
            0 => UnitPressure::Pascal,
            1 => UnitPressure::Hectopascal,
            2 => UnitPressure::Kilopascal,
            3 => UnitPressure::Bar,
            4 => UnitPressure::Centibar,
            5 => UnitPressure::Millibar,
            6 => UnitPressure::MillimeterMercury,
            7 => UnitPressure::InchMercury,
            8 => UnitPressure::Psi,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }

      #[repr(u8)]
      #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd, serde::Deserialize, serde::Serialize)]
      pub enum UnitSoundPressure {
        /// dB, decibel, decibels
        Decibel,
        /// dBa
        DecibelAWeighted,
        /// dBm
        DecibelsMilliwatt,
      }
      impl ::core::fmt::Debug for UnitSoundPressure {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            UnitSoundPressure::Decibel => {
              f.debug_tuple("UnitSoundPressure::Decibel").finish()
            }
            UnitSoundPressure::DecibelAWeighted => {
              f.debug_tuple("UnitSoundPressure::DecibelAWeighted").finish()
            }
            UnitSoundPressure::DecibelsMilliwatt => {
              f.debug_tuple("UnitSoundPressure::DecibelsMilliwatt").finish()
            }
          }
        }
      }

      impl UnitSoundPressure{
        #[doc(hidden)]
        pub unsafe fn _lift(val: u8) -> UnitSoundPressure{
          if !cfg!(debug_assertions) {
            return unsafe { ::core::mem::transmute(val) };
          }

          match val {
            0 => UnitSoundPressure::Decibel,
            1 => UnitSoundPressure::DecibelAWeighted,
            2 => UnitSoundPressure::DecibelsMilliwatt,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }

      #[repr(u8)]
      #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd, serde::Deserialize, serde::Serialize)]
      pub enum UnitVolume {
        /// L
        Liters,
        /// mL
        Milliliters,
        /// m³
        CubicMeters,
        /// ft³
        CubicFeet,
        /// gal
        Gallons,
        /// fl. oz.
        FluidOunce,
      }
      impl ::core::fmt::Debug for UnitVolume {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            UnitVolume::Liters => {
              f.debug_tuple("UnitVolume::Liters").finish()
            }
            UnitVolume::Milliliters => {
              f.debug_tuple("UnitVolume::Milliliters").finish()
            }
            UnitVolume::CubicMeters => {
              f.debug_tuple("UnitVolume::CubicMeters").finish()
            }
            UnitVolume::CubicFeet => {
              f.debug_tuple("UnitVolume::CubicFeet").finish()
            }
            UnitVolume::Gallons => {
              f.debug_tuple("UnitVolume::Gallons").finish()
            }
            UnitVolume::FluidOunce => {
              f.debug_tuple("UnitVolume::FluidOunce").finish()
            }
          }
        }
      }

      impl UnitVolume{
        #[doc(hidden)]
        pub unsafe fn _lift(val: u8) -> UnitVolume{
          if !cfg!(debug_assertions) {
            return unsafe { ::core::mem::transmute(val) };
          }

          match val {
            0 => UnitVolume::Liters,
            1 => UnitVolume::Milliliters,
            2 => UnitVolume::CubicMeters,
            3 => UnitVolume::CubicFeet,
            4 => UnitVolume::Gallons,
            5 => UnitVolume::FluidOunce,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }

      #[repr(u8)]
      #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd, serde::Deserialize, serde::Serialize)]
      pub enum UnitVolumeFlowRate {
        /// m³/h
        CubicMetersPerHour,
        /// ft³/m
        CubicFeetPerMinute,
      }
      impl ::core::fmt::Debug for UnitVolumeFlowRate {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            UnitVolumeFlowRate::CubicMetersPerHour => {
              f.debug_tuple("UnitVolumeFlowRate::CubicMetersPerHour").finish()
            }
            UnitVolumeFlowRate::CubicFeetPerMinute => {
              f.debug_tuple("UnitVolumeFlowRate::CubicFeetPerMinute").finish()
            }
          }
        }
      }

      impl UnitVolumeFlowRate{
        #[doc(hidden)]
        pub unsafe fn _lift(val: u8) -> UnitVolumeFlowRate{
          if !cfg!(debug_assertions) {
            return unsafe { ::core::mem::transmute(val) };
          }

          match val {
            0 => UnitVolumeFlowRate::CubicMetersPerHour,
            1 => UnitVolumeFlowRate::CubicFeetPerMinute,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }

      #[repr(u8)]
      #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd, serde::Deserialize, serde::Serialize)]
      pub enum UnitArea {
        /// m²
        SquareMeters,
      }
      impl ::core::fmt::Debug for UnitArea {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            UnitArea::SquareMeters => {
              f.debug_tuple("UnitArea::SquareMeters").finish()
            }
          }
        }
      }

      impl UnitArea{
        #[doc(hidden)]
        pub unsafe fn _lift(val: u8) -> UnitArea{
          if !cfg!(debug_assertions) {
            return unsafe { ::core::mem::transmute(val) };
          }

          match val {
            0 => UnitArea::SquareMeters,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }

      #[repr(u8)]
      #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd, serde::Deserialize, serde::Serialize)]
      pub enum UnitMass {
        /// g
        Grams,
        /// kg
        Kilograms,
        /// mg
        Milligrams,
        /// µg
        Micrograms,
        /// oz
        Ounces,
        /// lb
        Pounds,
      }
      impl ::core::fmt::Debug for UnitMass {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            UnitMass::Grams => {
              f.debug_tuple("UnitMass::Grams").finish()
            }
            UnitMass::Kilograms => {
              f.debug_tuple("UnitMass::Kilograms").finish()
            }
            UnitMass::Milligrams => {
              f.debug_tuple("UnitMass::Milligrams").finish()
            }
            UnitMass::Micrograms => {
              f.debug_tuple("UnitMass::Micrograms").finish()
            }
            UnitMass::Ounces => {
              f.debug_tuple("UnitMass::Ounces").finish()
            }
            UnitMass::Pounds => {
              f.debug_tuple("UnitMass::Pounds").finish()
            }
          }
        }
      }

      impl UnitMass{
        #[doc(hidden)]
        pub unsafe fn _lift(val: u8) -> UnitMass{
          if !cfg!(debug_assertions) {
            return unsafe { ::core::mem::transmute(val) };
          }

          match val {
            0 => UnitMass::Grams,
            1 => UnitMass::Kilograms,
            2 => UnitMass::Milligrams,
            3 => UnitMass::Micrograms,
            4 => UnitMass::Ounces,
            5 => UnitMass::Pounds,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }

      #[repr(u8)]
      #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd, serde::Deserialize, serde::Serialize)]
      pub enum UnitConductivity {
        /// µS/cm
        MicrosiemensPerCentimeter,
      }
      impl ::core::fmt::Debug for UnitConductivity {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            UnitConductivity::MicrosiemensPerCentimeter => {
              f.debug_tuple("UnitConductivity::MicrosiemensPerCentimeter").finish()
            }
          }
        }
      }

      impl UnitConductivity{
        #[doc(hidden)]
        pub unsafe fn _lift(val: u8) -> UnitConductivity{
          if !cfg!(debug_assertions) {
            return unsafe { ::core::mem::transmute(val) };
          }

          match val {
            0 => UnitConductivity::MicrosiemensPerCentimeter,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }

      #[repr(u8)]
      #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd, serde::Deserialize, serde::Serialize)]
      pub enum UnitLight {
        /// lx
        Lux,
      }
      impl ::core::fmt::Debug for UnitLight {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            UnitLight::Lux => {
              f.debug_tuple("UnitLight::Lux").finish()
            }
          }
        }
      }

      impl UnitLight{
        #[doc(hidden)]
        pub unsafe fn _lift(val: u8) -> UnitLight{
          if !cfg!(debug_assertions) {
            return unsafe { ::core::mem::transmute(val) };
          }

          match val {
            0 => UnitLight::Lux,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }

      #[repr(u8)]
      #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd, serde::Deserialize, serde::Serialize)]
      pub enum UnitUvIndex {
        /// UV index
        UvIndex,
      }
      impl ::core::fmt::Debug for UnitUvIndex {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            UnitUvIndex::UvIndex => {
              f.debug_tuple("UnitUvIndex::UvIndex").finish()
            }
          }
        }
      }

      impl UnitUvIndex{
        #[doc(hidden)]
        pub unsafe fn _lift(val: u8) -> UnitUvIndex{
          if !cfg!(debug_assertions) {
            return unsafe { ::core::mem::transmute(val) };
          }

          match val {
            0 => UnitUvIndex::UvIndex,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }

      #[repr(u8)]
      #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd, serde::Deserialize, serde::Serialize)]
      pub enum UnitPercentage {
        /// %
        Percentage,
      }
      impl ::core::fmt::Debug for UnitPercentage {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            UnitPercentage::Percentage => {
              f.debug_tuple("UnitPercentage::Percentage").finish()
            }
          }
        }
      }

      impl UnitPercentage{
        #[doc(hidden)]
        pub unsafe fn _lift(val: u8) -> UnitPercentage{
          if !cfg!(debug_assertions) {
            return unsafe { ::core::mem::transmute(val) };
          }

          match val {
            0 => UnitPercentage::Percentage,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }

      #[repr(u8)]
      #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd, serde::Deserialize, serde::Serialize)]
      pub enum UnitIrradiation {
        /// W/m²
        WattsPerSquareMeter,
        /// BTU/(h×ft²)
        BtusPerHourSquareFoot,
      }
      impl ::core::fmt::Debug for UnitIrradiation {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            UnitIrradiation::WattsPerSquareMeter => {
              f.debug_tuple("UnitIrradiation::WattsPerSquareMeter").finish()
            }
            UnitIrradiation::BtusPerHourSquareFoot => {
              f.debug_tuple("UnitIrradiation::BtusPerHourSquareFoot").finish()
            }
          }
        }
      }

      impl UnitIrradiation{
        #[doc(hidden)]
        pub unsafe fn _lift(val: u8) -> UnitIrradiation{
          if !cfg!(debug_assertions) {
            return unsafe { ::core::mem::transmute(val) };
          }

          match val {
            0 => UnitIrradiation::WattsPerSquareMeter,
            1 => UnitIrradiation::BtusPerHourSquareFoot,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }

      #[repr(u8)]
      #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd, serde::Deserialize, serde::Serialize)]
      pub enum UnitConcentration {
        /// µg/m³
        MicrogramsPerCubicMeter,
        /// mg/m³
        MilligramsPerCubicMeter,
        /// μg/ft³
        MicrogramsPerCubicFoot,
        /// p/m³
        PartsPerCubicMeter,
        /// ppm
        PartsPerMillion,
        /// ppb
        PartsPerBillion,
      }
      impl ::core::fmt::Debug for UnitConcentration {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            UnitConcentration::MicrogramsPerCubicMeter => {
              f.debug_tuple("UnitConcentration::MicrogramsPerCubicMeter").finish()
            }
            UnitConcentration::MilligramsPerCubicMeter => {
              f.debug_tuple("UnitConcentration::MilligramsPerCubicMeter").finish()
            }
            UnitConcentration::MicrogramsPerCubicFoot => {
              f.debug_tuple("UnitConcentration::MicrogramsPerCubicFoot").finish()
            }
            UnitConcentration::PartsPerCubicMeter => {
              f.debug_tuple("UnitConcentration::PartsPerCubicMeter").finish()
            }
            UnitConcentration::PartsPerMillion => {
              f.debug_tuple("UnitConcentration::PartsPerMillion").finish()
            }
            UnitConcentration::PartsPerBillion => {
              f.debug_tuple("UnitConcentration::PartsPerBillion").finish()
            }
          }
        }
      }

      impl UnitConcentration{
        #[doc(hidden)]
        pub unsafe fn _lift(val: u8) -> UnitConcentration{
          if !cfg!(debug_assertions) {
            return unsafe { ::core::mem::transmute(val) };
          }

          match val {
            0 => UnitConcentration::MicrogramsPerCubicMeter,
            1 => UnitConcentration::MilligramsPerCubicMeter,
            2 => UnitConcentration::MicrogramsPerCubicFoot,
            3 => UnitConcentration::PartsPerCubicMeter,
            4 => UnitConcentration::PartsPerMillion,
            5 => UnitConcentration::PartsPerBillion,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }

      #[repr(u8)]
      #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd, serde::Deserialize, serde::Serialize)]
      pub enum UnitSpeed {
        /// mm/d
        MillimetersPerDay,
        /// mm/h
        MillimetersPerHour,
        /// ft/s
        FeetPerSecond,
        /// in/d
        InchesPerDay,
        /// m/s
        MetersPerSecond,
        /// in/h
        InchesPerHour,
        /// km/h
        KilometersPerHour,
        /// kn
        Knots,
        /// mph
        MilesPerHour,
      }
      impl ::core::fmt::Debug for UnitSpeed {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            UnitSpeed::MillimetersPerDay => {
              f.debug_tuple("UnitSpeed::MillimetersPerDay").finish()
            }
            UnitSpeed::MillimetersPerHour => {
              f.debug_tuple("UnitSpeed::MillimetersPerHour").finish()
            }
            UnitSpeed::FeetPerSecond => {
              f.debug_tuple("UnitSpeed::FeetPerSecond").finish()
            }
            UnitSpeed::InchesPerDay => {
              f.debug_tuple("UnitSpeed::InchesPerDay").finish()
            }
            UnitSpeed::MetersPerSecond => {
              f.debug_tuple("UnitSpeed::MetersPerSecond").finish()
            }
            UnitSpeed::InchesPerHour => {
              f.debug_tuple("UnitSpeed::InchesPerHour").finish()
            }
            UnitSpeed::KilometersPerHour => {
              f.debug_tuple("UnitSpeed::KilometersPerHour").finish()
            }
            UnitSpeed::Knots => {
              f.debug_tuple("UnitSpeed::Knots").finish()
            }
            UnitSpeed::MilesPerHour => {
              f.debug_tuple("UnitSpeed::MilesPerHour").finish()
            }
          }
        }
      }

      impl UnitSpeed{
        #[doc(hidden)]
        pub unsafe fn _lift(val: u8) -> UnitSpeed{
          if !cfg!(debug_assertions) {
            return unsafe { ::core::mem::transmute(val) };
          }

          match val {
            0 => UnitSpeed::MillimetersPerDay,
            1 => UnitSpeed::MillimetersPerHour,
            2 => UnitSpeed::FeetPerSecond,
            3 => UnitSpeed::InchesPerDay,
            4 => UnitSpeed::MetersPerSecond,
            5 => UnitSpeed::InchesPerHour,
            6 => UnitSpeed::KilometersPerHour,
            7 => UnitSpeed::Knots,
            8 => UnitSpeed::MilesPerHour,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }

      #[repr(u8)]
      #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd, serde::Deserialize, serde::Serialize)]
      pub enum UnitData {
        /// bit
        Bits,
        /// kbit
        Kilobits,
        /// Mbit
        Megabits,
        /// Gbit
        Gigabits,
        /// B
        Bytes,
        /// kB
        Kilobytes,
        /// MB
        Megabytes,
        /// GB
        Gigabytes,
        /// TB
        Terabytes,
        /// PB
        Petabytes,
        /// EB
        Exabytes,
        /// ZB
        Zettabytes,
        /// YB
        Yottabytes,
        /// KiB
        Kibibytes,
        /// MiB
        Mebibytes,
        /// GiB
        Gibibytes,
        /// TiB
        Tebibytes,
        /// PiB
        Pebibytes,
        /// EiB
        Exbibytes,
        /// ZiB
        Zebibytes,
        /// YiB
        Yobibytes,
      }
      impl ::core::fmt::Debug for UnitData {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            UnitData::Bits => {
              f.debug_tuple("UnitData::Bits").finish()
            }
            UnitData::Kilobits => {
              f.debug_tuple("UnitData::Kilobits").finish()
            }
            UnitData::Megabits => {
              f.debug_tuple("UnitData::Megabits").finish()
            }
            UnitData::Gigabits => {
              f.debug_tuple("UnitData::Gigabits").finish()
            }
            UnitData::Bytes => {
              f.debug_tuple("UnitData::Bytes").finish()
            }
            UnitData::Kilobytes => {
              f.debug_tuple("UnitData::Kilobytes").finish()
            }
            UnitData::Megabytes => {
              f.debug_tuple("UnitData::Megabytes").finish()
            }
            UnitData::Gigabytes => {
              f.debug_tuple("UnitData::Gigabytes").finish()
            }
            UnitData::Terabytes => {
              f.debug_tuple("UnitData::Terabytes").finish()
            }
            UnitData::Petabytes => {
              f.debug_tuple("UnitData::Petabytes").finish()
            }
            UnitData::Exabytes => {
              f.debug_tuple("UnitData::Exabytes").finish()
            }
            UnitData::Zettabytes => {
              f.debug_tuple("UnitData::Zettabytes").finish()
            }
            UnitData::Yottabytes => {
              f.debug_tuple("UnitData::Yottabytes").finish()
            }
            UnitData::Kibibytes => {
              f.debug_tuple("UnitData::Kibibytes").finish()
            }
            UnitData::Mebibytes => {
              f.debug_tuple("UnitData::Mebibytes").finish()
            }
            UnitData::Gibibytes => {
              f.debug_tuple("UnitData::Gibibytes").finish()
            }
            UnitData::Tebibytes => {
              f.debug_tuple("UnitData::Tebibytes").finish()
            }
            UnitData::Pebibytes => {
              f.debug_tuple("UnitData::Pebibytes").finish()
            }
            UnitData::Exbibytes => {
              f.debug_tuple("UnitData::Exbibytes").finish()
            }
            UnitData::Zebibytes => {
              f.debug_tuple("UnitData::Zebibytes").finish()
            }
            UnitData::Yobibytes => {
              f.debug_tuple("UnitData::Yobibytes").finish()
            }
          }
        }
      }

      impl UnitData{
        #[doc(hidden)]
        pub unsafe fn _lift(val: u8) -> UnitData{
          if !cfg!(debug_assertions) {
            return unsafe { ::core::mem::transmute(val) };
          }

          match val {
            0 => UnitData::Bits,
            1 => UnitData::Kilobits,
            2 => UnitData::Megabits,
            3 => UnitData::Gigabits,
            4 => UnitData::Bytes,
            5 => UnitData::Kilobytes,
            6 => UnitData::Megabytes,
            7 => UnitData::Gigabytes,
            8 => UnitData::Terabytes,
            9 => UnitData::Petabytes,
            10 => UnitData::Exabytes,
            11 => UnitData::Zettabytes,
            12 => UnitData::Yottabytes,
            13 => UnitData::Kibibytes,
            14 => UnitData::Mebibytes,
            15 => UnitData::Gibibytes,
            16 => UnitData::Tebibytes,
            17 => UnitData::Pebibytes,
            18 => UnitData::Exbibytes,
            19 => UnitData::Zebibytes,
            20 => UnitData::Yobibytes,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }

      #[repr(u8)]
      #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd, serde::Deserialize, serde::Serialize)]
      pub enum UnitDataRate {
        /// bit/s
        BitsPerSecond,
        /// kbit/s
        KilobitsPerSecond,
        /// Mbit/s
        MegabitsPerSecond,
        /// Gbit/s
        GigabitsPerSecond,
        /// B/s
        BytesPerSecond,
        /// kB/s
        KilobytesPerSecond,
        /// MB/s
        MegabytesPerSecond,
        /// GB/s
        GigabytesPerSecond,
        /// KiB/s
        KibibytesPerSecond,
        /// MiB/s
        MebibytesPerSecond,
        /// GiB/s
        GibibytesPerSecond,
      }
      impl ::core::fmt::Debug for UnitDataRate {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            UnitDataRate::BitsPerSecond => {
              f.debug_tuple("UnitDataRate::BitsPerSecond").finish()
            }
            UnitDataRate::KilobitsPerSecond => {
              f.debug_tuple("UnitDataRate::KilobitsPerSecond").finish()
            }
            UnitDataRate::MegabitsPerSecond => {
              f.debug_tuple("UnitDataRate::MegabitsPerSecond").finish()
            }
            UnitDataRate::GigabitsPerSecond => {
              f.debug_tuple("UnitDataRate::GigabitsPerSecond").finish()
            }
            UnitDataRate::BytesPerSecond => {
              f.debug_tuple("UnitDataRate::BytesPerSecond").finish()
            }
            UnitDataRate::KilobytesPerSecond => {
              f.debug_tuple("UnitDataRate::KilobytesPerSecond").finish()
            }
            UnitDataRate::MegabytesPerSecond => {
              f.debug_tuple("UnitDataRate::MegabytesPerSecond").finish()
            }
            UnitDataRate::GigabytesPerSecond => {
              f.debug_tuple("UnitDataRate::GigabytesPerSecond").finish()
            }
            UnitDataRate::KibibytesPerSecond => {
              f.debug_tuple("UnitDataRate::KibibytesPerSecond").finish()
            }
            UnitDataRate::MebibytesPerSecond => {
              f.debug_tuple("UnitDataRate::MebibytesPerSecond").finish()
            }
            UnitDataRate::GibibytesPerSecond => {
              f.debug_tuple("UnitDataRate::GibibytesPerSecond").finish()
            }
          }
        }
      }

      impl UnitDataRate{
        #[doc(hidden)]
        pub unsafe fn _lift(val: u8) -> UnitDataRate{
          if !cfg!(debug_assertions) {
            return unsafe { ::core::mem::transmute(val) };
          }

          match val {
            0 => UnitDataRate::BitsPerSecond,
            1 => UnitDataRate::KilobitsPerSecond,
            2 => UnitDataRate::MegabitsPerSecond,
            3 => UnitDataRate::GigabitsPerSecond,
            4 => UnitDataRate::BytesPerSecond,
            5 => UnitDataRate::KilobytesPerSecond,
            6 => UnitDataRate::MegabytesPerSecond,
            7 => UnitDataRate::GigabytesPerSecond,
            8 => UnitDataRate::KibibytesPerSecond,
            9 => UnitDataRate::MebibytesPerSecond,
            10 => UnitDataRate::GibibytesPerSecond,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }

      #[repr(u8)]
      #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd, serde::Deserialize, serde::Serialize)]
      pub enum FanOscillation {
        Off,
        On,
        Vertical,
        Horizontal,
        Both,
      }
      impl ::core::fmt::Debug for FanOscillation {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            FanOscillation::Off => {
              f.debug_tuple("FanOscillation::Off").finish()
            }
            FanOscillation::On => {
              f.debug_tuple("FanOscillation::On").finish()
            }
            FanOscillation::Vertical => {
              f.debug_tuple("FanOscillation::Vertical").finish()
            }
            FanOscillation::Horizontal => {
              f.debug_tuple("FanOscillation::Horizontal").finish()
            }
            FanOscillation::Both => {
              f.debug_tuple("FanOscillation::Both").finish()
            }
          }
        }
      }

      impl FanOscillation{
        #[doc(hidden)]
        pub unsafe fn _lift(val: u8) -> FanOscillation{
          if !cfg!(debug_assertions) {
            return unsafe { ::core::mem::transmute(val) };
          }

          match val {
            0 => FanOscillation::Off,
            1 => FanOscillation::On,
            2 => FanOscillation::Vertical,
            3 => FanOscillation::Horizontal,
            4 => FanOscillation::Both,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }

      #[repr(u8)]
      #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd, serde::Deserialize, serde::Serialize)]
      pub enum FanDirection {
        Forward,
        Reverse,
      }
      impl ::core::fmt::Debug for FanDirection {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            FanDirection::Forward => {
              f.debug_tuple("FanDirection::Forward").finish()
            }
            FanDirection::Reverse => {
              f.debug_tuple("FanDirection::Reverse").finish()
            }
          }
        }
      }

      impl FanDirection{
        #[doc(hidden)]
        pub unsafe fn _lift(val: u8) -> FanDirection{
          if !cfg!(debug_assertions) {
            return unsafe { ::core::mem::transmute(val) };
          }

          match val {
            0 => FanDirection::Forward,
            1 => FanDirection::Reverse,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }

      #[repr(u8)]
      #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd, serde::Deserialize, serde::Serialize)]
      pub enum FanSpeed {
        On,
        Off,
        Auto,
        Low,
        Medium,
        High,
        Middle,
        Focus,
        Diffuse,
        Quiet,
      }
      impl ::core::fmt::Debug for FanSpeed {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            FanSpeed::On => {
              f.debug_tuple("FanSpeed::On").finish()
            }
            FanSpeed::Off => {
              f.debug_tuple("FanSpeed::Off").finish()
            }
            FanSpeed::Auto => {
              f.debug_tuple("FanSpeed::Auto").finish()
            }
            FanSpeed::Low => {
              f.debug_tuple("FanSpeed::Low").finish()
            }
            FanSpeed::Medium => {
              f.debug_tuple("FanSpeed::Medium").finish()
            }
            FanSpeed::High => {
              f.debug_tuple("FanSpeed::High").finish()
            }
            FanSpeed::Middle => {
              f.debug_tuple("FanSpeed::Middle").finish()
            }
            FanSpeed::Focus => {
              f.debug_tuple("FanSpeed::Focus").finish()
            }
            FanSpeed::Diffuse => {
              f.debug_tuple("FanSpeed::Diffuse").finish()
            }
            FanSpeed::Quiet => {
              f.debug_tuple("FanSpeed::Quiet").finish()
            }
          }
        }
      }

      impl FanSpeed{
        #[doc(hidden)]
        pub unsafe fn _lift(val: u8) -> FanSpeed{
          if !cfg!(debug_assertions) {
            return unsafe { ::core::mem::transmute(val) };
          }

          match val {
            0 => FanSpeed::On,
            1 => FanSpeed::Off,
            2 => FanSpeed::Auto,
            3 => FanSpeed::Low,
            4 => FanSpeed::Medium,
            5 => FanSpeed::High,
            6 => FanSpeed::Middle,
            7 => FanSpeed::Focus,
            8 => FanSpeed::Diffuse,
            9 => FanSpeed::Quiet,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }

      #[repr(u8)]
      #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd, serde::Deserialize, serde::Serialize)]
      pub enum ClimateMode {
        Off,
        Auto,
        Heat,
        Cool,
        HeatCool,
        FanOnly,
        Dry,
        Eco,
      }
      impl ::core::fmt::Debug for ClimateMode {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            ClimateMode::Off => {
              f.debug_tuple("ClimateMode::Off").finish()
            }
            ClimateMode::Auto => {
              f.debug_tuple("ClimateMode::Auto").finish()
            }
            ClimateMode::Heat => {
              f.debug_tuple("ClimateMode::Heat").finish()
            }
            ClimateMode::Cool => {
              f.debug_tuple("ClimateMode::Cool").finish()
            }
            ClimateMode::HeatCool => {
              f.debug_tuple("ClimateMode::HeatCool").finish()
            }
            ClimateMode::FanOnly => {
              f.debug_tuple("ClimateMode::FanOnly").finish()
            }
            ClimateMode::Dry => {
              f.debug_tuple("ClimateMode::Dry").finish()
            }
            ClimateMode::Eco => {
              f.debug_tuple("ClimateMode::Eco").finish()
            }
          }
        }
      }

      impl ClimateMode{
        #[doc(hidden)]
        pub unsafe fn _lift(val: u8) -> ClimateMode{
          if !cfg!(debug_assertions) {
            return unsafe { ::core::mem::transmute(val) };
          }

          match val {
            0 => ClimateMode::Off,
            1 => ClimateMode::Auto,
            2 => ClimateMode::Heat,
            3 => ClimateMode::Cool,
            4 => ClimateMode::HeatCool,
            5 => ClimateMode::FanOnly,
            6 => ClimateMode::Dry,
            7 => ClimateMode::Eco,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }

      #[repr(u8)]
      #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd, serde::Deserialize, serde::Serialize)]
      pub enum LockState {
        Unknown,
        Locked,
        Unlocked,
        Jammed,
        Locking,
        Unlocking,
      }
      impl ::core::fmt::Debug for LockState {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            LockState::Unknown => {
              f.debug_tuple("LockState::Unknown").finish()
            }
            LockState::Locked => {
              f.debug_tuple("LockState::Locked").finish()
            }
            LockState::Unlocked => {
              f.debug_tuple("LockState::Unlocked").finish()
            }
            LockState::Jammed => {
              f.debug_tuple("LockState::Jammed").finish()
            }
            LockState::Locking => {
              f.debug_tuple("LockState::Locking").finish()
            }
            LockState::Unlocking => {
              f.debug_tuple("LockState::Unlocking").finish()
            }
          }
        }
      }

      impl LockState{
        #[doc(hidden)]
        pub unsafe fn _lift(val: u8) -> LockState{
          if !cfg!(debug_assertions) {
            return unsafe { ::core::mem::transmute(val) };
          }

          match val {
            0 => LockState::Unknown,
            1 => LockState::Locked,
            2 => LockState::Unlocked,
            3 => LockState::Jammed,
            4 => LockState::Locking,
            5 => LockState::Unlocking,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }

      #[repr(u8)]
      #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd, serde::Deserialize, serde::Serialize)]
      pub enum MediaState {
        Unknown,
        Idle,
        Playing,
        Paused,
      }
      impl ::core::fmt::Debug for MediaState {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            MediaState::Unknown => {
              f.debug_tuple("MediaState::Unknown").finish()
            }
            MediaState::Idle => {
              f.debug_tuple("MediaState::Idle").finish()
            }
            MediaState::Playing => {
              f.debug_tuple("MediaState::Playing").finish()
            }
            MediaState::Paused => {
              f.debug_tuple("MediaState::Paused").finish()
            }
          }
        }
      }

      impl MediaState{
        #[doc(hidden)]
        pub unsafe fn _lift(val: u8) -> MediaState{
          if !cfg!(debug_assertions) {
            return unsafe { ::core::mem::transmute(val) };
          }

          match val {
            0 => MediaState::Unknown,
            1 => MediaState::Idle,
            2 => MediaState::Playing,
            3 => MediaState::Paused,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }

      #[repr(u8)]
      #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd, serde::Deserialize, serde::Serialize)]
      pub enum CoverState {
        Idle,
        Opening,
        Closing,
        Stopped,
        Open,
        Closed,
      }
      impl ::core::fmt::Debug for CoverState {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            CoverState::Idle => {
              f.debug_tuple("CoverState::Idle").finish()
            }
            CoverState::Opening => {
              f.debug_tuple("CoverState::Opening").finish()
            }
            CoverState::Closing => {
              f.debug_tuple("CoverState::Closing").finish()
            }
            CoverState::Stopped => {
              f.debug_tuple("CoverState::Stopped").finish()
            }
            CoverState::Open => {
              f.debug_tuple("CoverState::Open").finish()
            }
            CoverState::Closed => {
              f.debug_tuple("CoverState::Closed").finish()
            }
          }
        }
      }

      impl CoverState{
        #[doc(hidden)]
        pub unsafe fn _lift(val: u8) -> CoverState{
          if !cfg!(debug_assertions) {
            return unsafe { ::core::mem::transmute(val) };
          }

          match val {
            0 => CoverState::Idle,
            1 => CoverState::Opening,
            2 => CoverState::Closing,
            3 => CoverState::Stopped,
            4 => CoverState::Open,
            5 => CoverState::Closed,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }

      #[repr(u8)]
      #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd, serde::Deserialize, serde::Serialize)]
      pub enum ValveState {
        Idle,
        Opening,
        Closing,
      }
      impl ::core::fmt::Debug for ValveState {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            ValveState::Idle => {
              f.debug_tuple("ValveState::Idle").finish()
            }
            ValveState::Opening => {
              f.debug_tuple("ValveState::Opening").finish()
            }
            ValveState::Closing => {
              f.debug_tuple("ValveState::Closing").finish()
            }
          }
        }
      }

      impl ValveState{
        #[doc(hidden)]
        pub unsafe fn _lift(val: u8) -> ValveState{
          if !cfg!(debug_assertions) {
            return unsafe { ::core::mem::transmute(val) };
          }

          match val {
            0 => ValveState::Idle,
            1 => ValveState::Opening,
            2 => ValveState::Closing,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }

      #[repr(u8)]
      #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd, serde::Deserialize, serde::Serialize)]
      pub enum AlarmState {
        Disarmed,
        ArmedHome,
        ArmedAway,
        ArmedNight,
        ArmedVacation,
        ArmedUnknown,
        Pending,
        Triggered,
        Arming,
        Disarming,
      }
      impl ::core::fmt::Debug for AlarmState {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            AlarmState::Disarmed => {
              f.debug_tuple("AlarmState::Disarmed").finish()
            }
            AlarmState::ArmedHome => {
              f.debug_tuple("AlarmState::ArmedHome").finish()
            }
            AlarmState::ArmedAway => {
              f.debug_tuple("AlarmState::ArmedAway").finish()
            }
            AlarmState::ArmedNight => {
              f.debug_tuple("AlarmState::ArmedNight").finish()
            }
            AlarmState::ArmedVacation => {
              f.debug_tuple("AlarmState::ArmedVacation").finish()
            }
            AlarmState::ArmedUnknown => {
              f.debug_tuple("AlarmState::ArmedUnknown").finish()
            }
            AlarmState::Pending => {
              f.debug_tuple("AlarmState::Pending").finish()
            }
            AlarmState::Triggered => {
              f.debug_tuple("AlarmState::Triggered").finish()
            }
            AlarmState::Arming => {
              f.debug_tuple("AlarmState::Arming").finish()
            }
            AlarmState::Disarming => {
              f.debug_tuple("AlarmState::Disarming").finish()
            }
          }
        }
      }

      impl AlarmState{
        #[doc(hidden)]
        pub unsafe fn _lift(val: u8) -> AlarmState{
          if !cfg!(debug_assertions) {
            return unsafe { ::core::mem::transmute(val) };
          }

          match val {
            0 => AlarmState::Disarmed,
            1 => AlarmState::ArmedHome,
            2 => AlarmState::ArmedAway,
            3 => AlarmState::ArmedNight,
            4 => AlarmState::ArmedVacation,
            5 => AlarmState::ArmedUnknown,
            6 => AlarmState::Pending,
            7 => AlarmState::Triggered,
            8 => AlarmState::Arming,
            9 => AlarmState::Disarming,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }

      #[derive(Clone, PartialEq, serde::Deserialize, serde::Serialize)]
      pub enum Component {
        Integer(i64),
        Float(f64),
        String(_rt::String),
        Bool(bool),
        Color(IglooColor),
        Date(IglooDate),
        Time(IglooTime),
        IntegerList(_rt::Vec::<i64>),
        FloatList(_rt::Vec::<f64>),
        StringList(_rt::Vec::<_rt::String>),
        BooleanList(_rt::Vec::<bool>),
        ColorList(_rt::Vec::<IglooColor>),
        DateList(_rt::Vec::<IglooDate>),
        TimeList(_rt::Vec::<IglooTime>),
        Trigger,
        /// unix epoch
        Timestamp(i64),
        /// seconds
        Duration(i64),
        Weekday(Weekday),
        Light,
        Switch(bool),
        /// 0.0 to 1.0
        Dimmer(f64),
        Switch(bool),
        ColorMode(ColorMode),
        /// degrees kelvin
        ColorTemperature(i64),
        /// 0.0 to 1.0
        Volume(f64),
        Muted(bool),
        /// mark entity as config
        Config,
        /// mark entity as diagnostic
        Diagnostic,
        /// mark entity as siren
        Siren,
        /// mark entity as sensor
        Sensor,
        /// Metadata
        /// TODO a bunch of these are super specific to ESPHome
        /// and might not make sense in Igloo
        Icon(_rt::String),
        AccuracyDecimals(i64),
        /// Currently just for ESPHome
        DeviceClass(_rt::String),
        SensorStateClass(SensorStateClass),
        UnitApparentPower(UnitApparentPower),
        UnitPower(UnitPower),
        UnitReactivePower(UnitReactivePower),
        UnitEnergy(UnitEnergy),
        UnitElectricCurrent(UnitElectricCurrent),
        UnitElectricPotential(UnitElectricPotential),
        UnitDegree(UnitDegree),
        UnitCurrency(UnitCurrency),
        UnitTemperature(UnitTemperature),
        UnitTime(UnitTime),
        UnitLength(UnitLength),
        UnitFrequency(UnitFrequency),
        UnitPressure(UnitPressure),
        UnitSoundPressure(UnitSoundPressure),
        UnitVolume(UnitVolume),
        UnitVolumeFlowRate(UnitVolumeFlowRate),
        UnitArea(UnitArea),
        UnitMass(UnitMass),
        UnitConductivity(UnitConductivity),
        UnitLight(UnitLight),
        UnitUvIndex(UnitUvIndex),
        UnitPercentage(UnitPercentage),
        UnitIrradiation(UnitIrradiation),
        UnitConcentration(UnitConcentration),
        UnitSpeed(UnitSpeed),
        UnitData(UnitData),
        UnitDataRate(UnitDataRate),
        FanOscillation(FanOscillation),
        FanDirection(FanDirection),
        FanSpeed(FanSpeed),
        ClimateMode(ClimateMode),
        LockState(LockState),
        MediaState(MediaState),
        Cover,
        CoverState(CoverState),
        Position(f64),
        Tilt(f64),
        Valve,
        ValveState(ValveState),
        AlarmState(AlarmState),
      }
      impl ::core::fmt::Debug for Component {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            Component::Integer(e) => {
              f.debug_tuple("Component::Integer").field(e).finish()
            }
            Component::Float(e) => {
              f.debug_tuple("Component::Float").field(e).finish()
            }
            Component::String(e) => {
              f.debug_tuple("Component::String").field(e).finish()
            }
            Component::Bool(e) => {
              f.debug_tuple("Component::Bool").field(e).finish()
            }
            Component::Color(e) => {
              f.debug_tuple("Component::Color").field(e).finish()
            }
            Component::Date(e) => {
              f.debug_tuple("Component::Date").field(e).finish()
            }
            Component::Time(e) => {
              f.debug_tuple("Component::Time").field(e).finish()
            }
            Component::IntegerList(e) => {
              f.debug_tuple("Component::IntegerList").field(e).finish()
            }
            Component::FloatList(e) => {
              f.debug_tuple("Component::FloatList").field(e).finish()
            }
            Component::StringList(e) => {
              f.debug_tuple("Component::StringList").field(e).finish()
            }
            Component::BooleanList(e) => {
              f.debug_tuple("Component::BooleanList").field(e).finish()
            }
            Component::ColorList(e) => {
              f.debug_tuple("Component::ColorList").field(e).finish()
            }
            Component::DateList(e) => {
              f.debug_tuple("Component::DateList").field(e).finish()
            }
            Component::TimeList(e) => {
              f.debug_tuple("Component::TimeList").field(e).finish()
            }
            Component::Trigger => {
              f.debug_tuple("Component::Trigger").finish()
            }
            Component::Timestamp(e) => {
              f.debug_tuple("Component::Timestamp").field(e).finish()
            }
            Component::Duration(e) => {
              f.debug_tuple("Component::Duration").field(e).finish()
            }
            Component::Weekday(e) => {
              f.debug_tuple("Component::Weekday").field(e).finish()
            }
            Component::Light => {
              f.debug_tuple("Component::Light").finish()
            }
            Component::Switch(e) => {
              f.debug_tuple("Component::Switch").field(e).finish()
            }
            Component::Dimmer(e) => {
              f.debug_tuple("Component::Dimmer").field(e).finish()
            }
            Component::Switch(e) => {
              f.debug_tuple("Component::Switch").field(e).finish()
            }
            Component::ColorMode(e) => {
              f.debug_tuple("Component::ColorMode").field(e).finish()
            }
            Component::ColorTemperature(e) => {
              f.debug_tuple("Component::ColorTemperature").field(e).finish()
            }
            Component::Volume(e) => {
              f.debug_tuple("Component::Volume").field(e).finish()
            }
            Component::Muted(e) => {
              f.debug_tuple("Component::Muted").field(e).finish()
            }
            Component::Config => {
              f.debug_tuple("Component::Config").finish()
            }
            Component::Diagnostic => {
              f.debug_tuple("Component::Diagnostic").finish()
            }
            Component::Siren => {
              f.debug_tuple("Component::Siren").finish()
            }
            Component::Sensor => {
              f.debug_tuple("Component::Sensor").finish()
            }
            Component::Icon(e) => {
              f.debug_tuple("Component::Icon").field(e).finish()
            }
            Component::AccuracyDecimals(e) => {
              f.debug_tuple("Component::AccuracyDecimals").field(e).finish()
            }
            Component::DeviceClass(e) => {
              f.debug_tuple("Component::DeviceClass").field(e).finish()
            }
            Component::SensorStateClass(e) => {
              f.debug_tuple("Component::SensorStateClass").field(e).finish()
            }
            Component::UnitApparentPower(e) => {
              f.debug_tuple("Component::UnitApparentPower").field(e).finish()
            }
            Component::UnitPower(e) => {
              f.debug_tuple("Component::UnitPower").field(e).finish()
            }
            Component::UnitReactivePower(e) => {
              f.debug_tuple("Component::UnitReactivePower").field(e).finish()
            }
            Component::UnitEnergy(e) => {
              f.debug_tuple("Component::UnitEnergy").field(e).finish()
            }
            Component::UnitElectricCurrent(e) => {
              f.debug_tuple("Component::UnitElectricCurrent").field(e).finish()
            }
            Component::UnitElectricPotential(e) => {
              f.debug_tuple("Component::UnitElectricPotential").field(e).finish()
            }
            Component::UnitDegree(e) => {
              f.debug_tuple("Component::UnitDegree").field(e).finish()
            }
            Component::UnitCurrency(e) => {
              f.debug_tuple("Component::UnitCurrency").field(e).finish()
            }
            Component::UnitTemperature(e) => {
              f.debug_tuple("Component::UnitTemperature").field(e).finish()
            }
            Component::UnitTime(e) => {
              f.debug_tuple("Component::UnitTime").field(e).finish()
            }
            Component::UnitLength(e) => {
              f.debug_tuple("Component::UnitLength").field(e).finish()
            }
            Component::UnitFrequency(e) => {
              f.debug_tuple("Component::UnitFrequency").field(e).finish()
            }
            Component::UnitPressure(e) => {
              f.debug_tuple("Component::UnitPressure").field(e).finish()
            }
            Component::UnitSoundPressure(e) => {
              f.debug_tuple("Component::UnitSoundPressure").field(e).finish()
            }
            Component::UnitVolume(e) => {
              f.debug_tuple("Component::UnitVolume").field(e).finish()
            }
            Component::UnitVolumeFlowRate(e) => {
              f.debug_tuple("Component::UnitVolumeFlowRate").field(e).finish()
            }
            Component::UnitArea(e) => {
              f.debug_tuple("Component::UnitArea").field(e).finish()
            }
            Component::UnitMass(e) => {
              f.debug_tuple("Component::UnitMass").field(e).finish()
            }
            Component::UnitConductivity(e) => {
              f.debug_tuple("Component::UnitConductivity").field(e).finish()
            }
            Component::UnitLight(e) => {
              f.debug_tuple("Component::UnitLight").field(e).finish()
            }
            Component::UnitUvIndex(e) => {
              f.debug_tuple("Component::UnitUvIndex").field(e).finish()
            }
            Component::UnitPercentage(e) => {
              f.debug_tuple("Component::UnitPercentage").field(e).finish()
            }
            Component::UnitIrradiation(e) => {
              f.debug_tuple("Component::UnitIrradiation").field(e).finish()
            }
            Component::UnitConcentration(e) => {
              f.debug_tuple("Component::UnitConcentration").field(e).finish()
            }
            Component::UnitSpeed(e) => {
              f.debug_tuple("Component::UnitSpeed").field(e).finish()
            }
            Component::UnitData(e) => {
              f.debug_tuple("Component::UnitData").field(e).finish()
            }
            Component::UnitDataRate(e) => {
              f.debug_tuple("Component::UnitDataRate").field(e).finish()
            }
            Component::FanOscillation(e) => {
              f.debug_tuple("Component::FanOscillation").field(e).finish()
            }
            Component::FanDirection(e) => {
              f.debug_tuple("Component::FanDirection").field(e).finish()
            }
            Component::FanSpeed(e) => {
              f.debug_tuple("Component::FanSpeed").field(e).finish()
            }
            Component::ClimateMode(e) => {
              f.debug_tuple("Component::ClimateMode").field(e).finish()
            }
            Component::LockState(e) => {
              f.debug_tuple("Component::LockState").field(e).finish()
            }
            Component::MediaState(e) => {
              f.debug_tuple("Component::MediaState").field(e).finish()
            }
            Component::Cover => {
              f.debug_tuple("Component::Cover").finish()
            }
            Component::CoverState(e) => {
              f.debug_tuple("Component::CoverState").field(e).finish()
            }
            Component::Position(e) => {
              f.debug_tuple("Component::Position").field(e).finish()
            }
            Component::Tilt(e) => {
              f.debug_tuple("Component::Tilt").field(e).finish()
            }
            Component::Valve => {
              f.debug_tuple("Component::Valve").finish()
            }
            Component::ValveState(e) => {
              f.debug_tuple("Component::ValveState").field(e).finish()
            }
            Component::AlarmState(e) => {
              f.debug_tuple("Component::AlarmState").field(e).finish()
            }
          }
        }
      }

    }

  }
}
mod _rt {
  #![allow(dead_code, unused_imports, clippy::all)]
  pub use alloc_crate::string::String;
  pub use alloc_crate::vec::Vec;
  extern crate alloc as alloc_crate;
}

#[cfg(target_arch = "wasm32")]
#[unsafe(link_section = "component-type:wit-bindgen:0.52.0:igloo:lib@0.1.0:shared:encoded world")]
#[doc(hidden)]
#[allow(clippy::octal_escapes)]
pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 4616] = *b"\
\0asm\x0d\0\x01\0\0\x19\x16wit-component-encoding\x04\0\x07\x8b#\x01A\x02\x01A\x09\
\x01B\x0c\x01r\x01\x06packedw\x04\0\x09device-id\x03\0\0\x01r\x01\x06packedw\x04\
\0\x08group-id\x03\0\x02\x01r\x01\x05inners\x04\0\x0cextension-id\x03\0\x04\x01r\
\x01\x05innerw\x04\0\x0fextension-index\x03\0\x06\x01r\x01\x05inners\x04\0\x09en\
tity-id\x03\0\x08\x01r\x01\x05innerw\x04\0\x0centity-index\x03\0\x0a\x03\0\x12ig\
loo:lib/id@0.1.0\x05\0\x01B\x06\x01r\x03\x01ru\x01gu\x01bu\x04\0\x0bigloo-color\x03\
\0\0\x01r\x03\x04year{\x05month}\x03day}\x04\0\x0aigloo-date\x03\0\x02\x01r\x03\x04\
hour}\x06minute}\x06second}\x04\0\x0aigloo-time\x03\0\x04\x03\0\x18igloo:lib/com\
pound@0.1.0\x05\x01\x02\x03\0\x01\x0bigloo-color\x02\x03\0\x01\x0aigloo-date\x02\
\x03\0\x01\x0aigloo-time\x01B]\x02\x03\x02\x01\x02\x04\0\x0bigloo-color\x03\0\0\x02\
\x03\x02\x01\x03\x04\0\x0aigloo-date\x03\0\x02\x02\x03\x02\x01\x04\x04\0\x0aiglo\
o-time\x03\0\x04\x01m\x07\x06sunday\x06monday\x07tuesday\x09wednesday\x08thursda\
y\x06friday\x08saturday\x04\0\x07weekday\x03\0\x06\x01m\x02\x05r-g-b\x0btemperat\
ure\x04\0\x0acolor-mode\x03\0\x08\x01m\x03\x0bmeasurement\x10total-increasing\x05\
total\x04\0\x12sensor-state-class\x03\0\x0a\x01m\x01\x0cvolt-amperes\x04\0\x13un\
it-apparent-power\x03\0\x0c\x01m\x03\x05watts\x0akilo-watts\x0dbtus-per-hour\x04\
\0\x0aunit-power\x03\0\x0e\x01m\x01\x14volt-ampere-reactive\x04\0\x13unit-reacti\
ve-power\x03\0\x10\x01m\x03\x0awatt-hours\x0fkilo-watt-hours\x0fmega-watt-hours\x04\
\0\x0bunit-energy\x03\0\x12\x01m\x02\x0cmilliamperes\x07amperes\x04\0\x15unit-el\
ectric-current\x03\0\x14\x01m\x02\x0amillivolts\x05volts\x04\0\x17unit-electric-\
potential\x03\0\x16\x01m\x01\x07degrees\x04\0\x0bunit-degree\x03\0\x18\x01m\x03\x05\
euros\x07dollars\x05cents\x04\0\x0dunit-currency\x03\0\x1a\x01m\x03\x07celsius\x0a\
fahrenheit\x06kelvin\x04\0\x10unit-temperature\x03\0\x1c\x01m\x09\x0cmicrosecond\
s\x0cmilliseconds\x07seconds\x07minutes\x05hours\x04days\x05weeks\x06months\x05y\
ears\x04\0\x09unit-time\x03\0\x1e\x01m\x08\x0bmillimeters\x0bcentimeters\x06mete\
rs\x0akilometers\x06inches\x04feet\x04yard\x05miles\x04\0\x0bunit-length\x03\0\x20\
\x01m\x04\x05hertz\x09kilohertz\x09megahertz\x09gigahertz\x04\0\x0eunit-frequenc\
y\x03\0\"\x01m\x09\x06pascal\x0bhectopascal\x0akilopascal\x03bar\x08centibar\x08\
millibar\x12millimeter-mercury\x0cinch-mercury\x03psi\x04\0\x0dunit-pressure\x03\
\0$\x01m\x03\x07decibel\x12decibel-a-weighted\x12decibels-milliwatt\x04\0\x13uni\
t-sound-pressure\x03\0&\x01m\x06\x06liters\x0bmilliliters\x0ccubic-meters\x0acub\
ic-feet\x07gallons\x0bfluid-ounce\x04\0\x0bunit-volume\x03\0(\x01m\x02\x15cubic-\
meters-per-hour\x15cubic-feet-per-minute\x04\0\x15unit-volume-flow-rate\x03\0*\x01\
m\x01\x0dsquare-meters\x04\0\x09unit-area\x03\0,\x01m\x06\x05grams\x09kilograms\x0a\
milligrams\x0amicrograms\x06ounces\x06pounds\x04\0\x09unit-mass\x03\0.\x01m\x01\x1b\
microsiemens-per-centimeter\x04\0\x11unit-conductivity\x03\00\x01m\x01\x03lux\x04\
\0\x0aunit-light\x03\02\x01m\x01\x08uv-index\x04\0\x0dunit-uv-index\x03\04\x01m\x01\
\x0apercentage\x04\0\x0funit-percentage\x03\06\x01m\x02\x16watts-per-square-mete\
r\x19btus-per-hour-square-foot\x04\0\x10unit-irradiation\x03\08\x01m\x06\x1amicr\
ograms-per-cubic-meter\x1amilligrams-per-cubic-meter\x19micrograms-per-cubic-foo\
t\x15parts-per-cubic-meter\x11parts-per-million\x11parts-per-billion\x04\0\x12un\
it-concentration\x03\0:\x01m\x09\x13millimeters-per-day\x14millimeters-per-hour\x0f\
feet-per-second\x0einches-per-day\x11meters-per-second\x0finches-per-hour\x13kil\
ometers-per-hour\x05knots\x0emiles-per-hour\x04\0\x0aunit-speed\x03\0<\x01m\x15\x04\
bits\x08kilobits\x08megabits\x08gigabits\x05bytes\x09kilobytes\x09megabytes\x09g\
igabytes\x09terabytes\x09petabytes\x08exabytes\x0azettabytes\x0ayottabytes\x09ki\
bibytes\x09mebibytes\x09gibibytes\x09tebibytes\x09pebibytes\x09exbibytes\x09zebi\
bytes\x09yobibytes\x04\0\x09unit-data\x03\0>\x01m\x0b\x0fbits-per-second\x13kilo\
bits-per-second\x13megabits-per-second\x13gigabits-per-second\x10bytes-per-secon\
d\x14kilobytes-per-second\x14megabytes-per-second\x14gigabytes-per-second\x14kib\
ibytes-per-second\x14mebibytes-per-second\x14gibibytes-per-second\x04\0\x0eunit-\
data-rate\x03\0@\x01m\x05\x03off\x02on\x08vertical\x0ahorizontal\x04both\x04\0\x0f\
fan-oscillation\x03\0B\x01m\x02\x07forward\x07reverse\x04\0\x0dfan-direction\x03\
\0D\x01m\x0a\x02on\x03off\x04auto\x03low\x06medium\x04high\x06middle\x05focus\x07\
diffuse\x05quiet\x04\0\x09fan-speed\x03\0F\x01m\x08\x03off\x04auto\x04heat\x04co\
ol\x09heat-cool\x08fan-only\x03dry\x03eco\x04\0\x0cclimate-mode\x03\0H\x01m\x06\x07\
unknown\x06locked\x08unlocked\x06jammed\x07locking\x09unlocking\x04\0\x0alock-st\
ate\x03\0J\x01m\x04\x07unknown\x04idle\x07playing\x06paused\x04\0\x0bmedia-state\
\x03\0L\x01m\x06\x04idle\x07opening\x07closing\x07stopped\x04open\x06closed\x04\0\
\x0bcover-state\x03\0N\x01m\x03\x04idle\x07opening\x07closing\x04\0\x0bvalve-sta\
te\x03\0P\x01m\x0a\x08disarmed\x0aarmed-home\x0aarmed-away\x0barmed-night\x0earm\
ed-vacation\x0darmed-unknown\x07pending\x09triggered\x06arming\x09disarming\x04\0\
\x0balarm-state\x03\0R\x01px\x01pu\x01ps\x01p\x7f\x01p\x01\x01p\x03\x01p\x05\x01\
qJ\x07integer\x01x\0\x05float\x01u\0\x06string\x01s\0\x04bool\x01\x7f\0\x05color\
\x01\x01\0\x04date\x01\x03\0\x04time\x01\x05\0\x0cinteger-list\x01\xd4\0\0\x0afl\
oat-list\x01\xd5\0\0\x0bstring-list\x01\xd6\0\0\x0cboolean-list\x01\xd7\0\0\x0ac\
olor-list\x01\xd8\0\0\x09date-list\x01\xd9\0\0\x09time-list\x01\xda\0\0\x07trigg\
er\0\0\x09timestamp\x01x\0\x08duration\x01x\0\x07weekday\x01\x07\0\x05light\0\0\x06\
switch\x01\x7f\0\x06dimmer\x01u\0\x06switch\x01\x7f\0\x0acolor-mode\x01\x09\0\x11\
color-temperature\x01x\0\x06volume\x01u\0\x05muted\x01\x7f\0\x06config\0\0\x0adi\
agnostic\0\0\x05siren\0\0\x06sensor\0\0\x04icon\x01s\0\x11accuracy-decimals\x01x\
\0\x0cdevice-class\x01s\0\x12sensor-state-class\x01\x0b\0\x13unit-apparent-power\
\x01\x0d\0\x0aunit-power\x01\x0f\0\x13unit-reactive-power\x01\x11\0\x0bunit-ener\
gy\x01\x13\0\x15unit-electric-current\x01\x15\0\x17unit-electric-potential\x01\x17\
\0\x0bunit-degree\x01\x19\0\x0dunit-currency\x01\x1b\0\x10unit-temperature\x01\x1d\
\0\x09unit-time\x01\x1f\0\x0bunit-length\x01!\0\x0eunit-frequency\x01#\0\x0dunit\
-pressure\x01%\0\x13unit-sound-pressure\x01'\0\x0bunit-volume\x01)\0\x15unit-vol\
ume-flow-rate\x01+\0\x09unit-area\x01-\0\x09unit-mass\x01/\0\x11unit-conductivit\
y\x011\0\x0aunit-light\x013\0\x0dunit-uv-index\x015\0\x0funit-percentage\x017\0\x10\
unit-irradiation\x019\0\x12unit-concentration\x01;\0\x0aunit-speed\x01=\0\x09uni\
t-data\x01?\0\x0eunit-data-rate\x01\xc1\0\0\x0ffan-oscillation\x01\xc3\0\0\x0dfa\
n-direction\x01\xc5\0\0\x09fan-speed\x01\xc7\0\0\x0cclimate-mode\x01\xc9\0\0\x0a\
lock-state\x01\xcb\0\0\x0bmedia-state\x01\xcd\0\0\x05cover\0\0\x0bcover-state\x01\
\xcf\0\0\x08position\x01u\0\x04tilt\x01u\0\x05valve\0\0\x0bvalve-state\x01\xd1\0\
\0\x0balarm-state\x01\xd3\0\0\x04\0\x09component\x03\0[\x03\0\x19igloo:lib/compo\
nent@0.1.0\x05\x05\x04\0\x16igloo:lib/shared@0.1.0\x04\0\x0b\x0c\x01\0\x06shared\
\x03\0\0\0G\x09producers\x01\x0cprocessed-by\x02\x0dwit-component\x070.244.0\x10\
wit-bindgen-rust\x060.52.0";

#[inline(never)]
#[doc(hidden)]
pub fn __link_custom_section_describing_imports() {
  wit_bindgen::rt::maybe_link_cabi_realloc();
}

