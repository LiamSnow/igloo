use anyhow::{Context, Result};
use std::fs;
use std::path::Path;
use wit_bindgen_core::AsyncFilterSet;
use wit_bindgen_core::wit_parser::{PackageId, WorldId, WorldKey};
use wit_bindgen_core::{Files, WorldGenerator, wit_parser::Resolve};
use wit_bindgen_rust::{Opts, WithOption};

use crate::codegen::parser::{Component, IglooType, Variant};
use crate::codegen::utils::upper_camel_to_kebab;
use crate::codegen::{GATED_WORLDS, SHARED_WORLD, WIT_PACKAGE};

pub fn compile_wit(wit_dir: &Path, out_dir: &Path) -> Result<(Resolve, WorldId)> {
    let mut resolve = Resolve::default();
    let (pkg, _source_map) = resolve.push_path(&wit_dir).context("failed to load WIT")?;

    compile_rust(&out_dir, &mut resolve, &[pkg])?;

    let shared_wid = resolve
        .select_world(&[pkg], Some(SHARED_WORLD))
        .with_context(|| format!("failed to select world `{SHARED_WORLD}`"))?;

    Ok((resolve, shared_wid))
}

fn compile_rust(out_dir: &Path, resolve: &mut Resolve, pkgs: &[PackageId]) -> Result<()> {
    println!("Generating Rust bindings...");

    compile_rust_colored(&out_dir.join("sync"), resolve, pkgs, true)?;
    compile_rust_colored(&out_dir.join("async"), resolve, pkgs, false)?;

    println!("Done!");

    Ok(())
}

fn compile_rust_colored(
    out_dir: &Path,
    resolve: &mut Resolve,
    pkgs: &[PackageId],
    sync: bool,
) -> Result<()> {
    // gen shared (ungated) types
    let shared_wid = compile_world(resolve, pkgs, out_dir, SHARED_WORLD, &[], sync)?;

    // prevent other worlds from replacing this shared types
    let shared_with = compile_shared_with(resolve, shared_wid);

    // gen ipc worlds
    for world in GATED_WORLDS {
        compile_world(resolve, pkgs, out_dir, world, &shared_with, sync)?;
    }

    Ok(())
}

fn compile_shared_with(resolve: &Resolve, shared_wid: WorldId) -> Vec<(String, WithOption)> {
    let world = &resolve.worlds[shared_wid];
    let mut with = Vec::new();

    for (key, _item) in &world.imports {
        if let WorldKey::Interface(iface_id) = key {
            let Some(id_str) = resolve.id_of(*iface_id) else {
                continue;
            };
            let iface = &resolve.interfaces[*iface_id];
            let pkg = &resolve.packages[iface.package.unwrap()];
            let namespace = pkg.name.namespace.replace('-', "_");
            let pkg_name = pkg.name.name.replace('-', "_");
            let iface_name = iface.name.as_ref().unwrap().replace('-', "_");

            let rust_path =
                format!("crate::generated::shared::{namespace}::{pkg_name}::{iface_name}");

            with.push((id_str, WithOption::Path(rust_path)));
        }
    }

    with
}

fn compile_world(
    resolve: &mut Resolve,
    pkgs: &[PackageId],
    out_dir: &Path,
    world: &str,
    with: &[(String, WithOption)],
    sync: bool,
) -> Result<WorldId> {
    let world_id = resolve
        .select_world(pkgs, Some(world))
        .with_context(|| format!("failed to select world `{world}`"))?;

    let opts = Opts {
        additional_derive_attributes: vec![
            "PartialEq".into(),
            "serde::Serialize".into(),
            "serde::Deserialize".into(),
        ],
        generate_unused_types: true,
        generate_all: true,
        with: with.to_vec(),
        async_: AsyncFilterSet::all(!sync),
        ..Default::default()
    };

    let mut generator = Box::new(opts.build()) as Box<dyn WorldGenerator>;
    let mut files = Files::default();

    generator
        .generate(resolve, world_id, &mut files)
        .with_context(|| format!("failed to generate bindings for world `{world}`"))?;

    for (name, contents) in files.iter() {
        let dst = out_dir.join(name);
        if let Some(parent) = dst.parent() {
            fs::create_dir_all(parent)
                .with_context(|| format!("failed to create directory {parent:?}"))?;
        }
        fs::write(&dst, contents).with_context(|| format!("failed to write {dst:?}"))?;
    }

    Ok(world_id)
}

pub fn make_comps_wit_file(file_path: &Path, comps: &Vec<Component>) -> Result<()> {
    let mut res = format!(
        "package {WIT_PACKAGE};\n
// DO NOT MODIFY This file is generated by xtask

interface component {{
    use compound.{{igloo-color, igloo-date, igloo-time}};

    variant component {{
"
    );

    for comp in comps {
        let doc = comp.get_doc();
        write_doc(&mut res, doc, "        ");

        res.push_str("        ");
        use Component::*;
        match comp {
            Marker { name, .. } => {
                res.push_str(&to_wit_name(name));
            }
            Single { name, ty, .. } => {
                res.push_str(&to_wit_name(name));
                res.push('(');
                res.push_str(ty.to_wit());
                res.push(')');
            }
            Enum { name, .. } => {
                res.push_str(&to_wit_name(name));
                res.push('(');
                res.push_str(&to_wit_name(name));
                res.push(')');
            }
        }

        res.push_str(",\n");
    }

    res.push_str("    }\n");

    for comp in comps {
        let Component::Enum { name, doc, vars } = comp else {
            continue;
        };

        write_doc(&mut res, doc, "    ");

        res.push_str("    enum ");
        res.push_str(&to_wit_name(name));
        res.push_str(" {\n");

        for Variant { name, doc } in vars {
            write_doc(&mut res, doc, "        ");
            res.push_str("        ");
            res.push_str(&to_wit_name(name));
            res.push_str(",\n");
        }

        res.push_str("    }\n");
    }

    res.push_str("}\n");

    fs::write(file_path, res)?;

    Ok(())
}

pub fn to_wit_name(s: &str) -> String {
    let res = upper_camel_to_kebab(s);
    match res.as_str() {
        "string" => "%string".to_string(),
        "bool" => "%bool".to_string(),
        _ => res,
    }
}

fn write_doc(res: &mut String, doc: &str, fill: &'static str) {
    if doc.is_empty() {
        return;
    }

    for line in doc.lines() {
        res.push_str(fill);
        res.push_str("/// ");
        res.push_str(line);
        res.push('\n');
    }
}

impl IglooType {
    fn to_wit(&self) -> &'static str {
        use IglooType::*;
        match self {
            Int => "s64",
            Float => "f64",
            Bool => "bool",
            String => "string",
            Color => "igloo-color",
            Date => "igloo-date",
            Time => "igloo-time",
            IntList => "list<s64>",
            FloatList => "list<f64>",
            BoolList => "list<bool>",
            StringList => "list<string>",
            ColorList => "list<igloo-color>",
            DateList => "list<igloo-date>",
            TimeList => "list<igloo-time>",
        }
    }
}
