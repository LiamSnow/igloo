use either::Either;
use crate::parser::ast::*;
use crate::lexer::tokens::{Token, LexicalError, Number};
use bumpalo::Bump;
use lalrpop_util::{ErrorRecovery, ParseError};

grammar<'a, 'err>(
    source: &'a str,
    arena: &'a Bump,
    errors: &'err mut Vec<ErrorRecovery<usize, Token<'a>, LexicalError>>
);

pub Main: &'a [Statement<'a>] = {
    TopStatement* => arena.alloc_slice_clone(&<>)
}

// statements at top level
TopStatement: Statement<'a> = {
    Mod,
    Use,
    Const,
   
    FnDefn,
    StructDefn,
    EnumDefn,
    TypeDefn,

    DashboardDefn,
    ElementDefn,

    ErrorStatement,
}

// statements allowed in functions
FnStatement: Statement<'a> = {
    Use,
    Const,
    Var,
    FnCallStatement,
    If<FnStatement>,
    Loop<FnStatement>,
    ControlFlow,
    Return,

    ErrorSemiColonStatement,
}

// statements allowed in elements after `return XX`
ElementStatement: Statement<'a> = {
    Use,
    Const,
    Var,
    If<ElementStatement>,
    Loop<ElementStatement>,
    ControlFlow,
    ElementInst,

    ErrorStatement,
}

ErrorSemiColonStatement: Statement<'a> = {
    <!> ";" => {
        errors.push(<>);
        Statement::Error
    },
}

ErrorStatement: Statement<'a> = {
    <!> => {
        errors.push(<>);
        Statement::Error
    },
}

FnCallStatement: Statement<'a> = {
    <FnCall> ";" => Statement::FnCall { name: <>.0, params: <>.1 },
}

ControlFlow: Statement<'a> = {
    "break" ";" => Statement::Break,
    "continue" ";" => Statement::Continue,
}

Return: Statement<'a> = {
    "return" <AnyExpr> ";" => Statement::Return(Some(<>)),
    "return" ";" => Statement::Return(None),
}

Mod: Statement<'a> = {
    "mod" <name:Ident> <body:Block<TopStatement>> => {
        Statement::Module {
            name,
            body
        }
    }
}

Use: Statement<'a> = {
    "use" <p:NamespacePath> <r#as:("as" <Ident>)?> ";" => {
        Statement::Use { path: p, r#as }
    },
    "use" <p:NamespacePath> "as" "*" ";" => {
        Statement::Use { path: p, r#as: Some("*") }
    }
}

Const: Statement<'a> = {
    "const" <name:Ident> ":" <r#type:Type> "=" <value:AnyExpr> ";"
        => Statement::Const { name, r#type, value },
}

Var: Statement<'a> = {
    "let" <name:Ident> ":" <typ:Type> "=" <value:AnyExpr> ";"
        => Statement::Let { name, r#type: Some(typ), value },
    "let" <name:Ident> "=" <value:AnyExpr> ";"
        => Statement::Let { name, r#type: None, value },
    <var:VarAccess> "=" <value:AnyExpr> ";"
        => Statement::Assign { var, value },
    <var:VarAccess> <op:ModOp> <value:AnyExpr> ";"
        => Statement::CompoundAssign { var, op, value },
}

AnyExpr: Expr<'a> = {
    #[precedence(level="0")]
    Ternary,
    #[precedence(level="1")] #[assoc(side="left")]
    CurlyCompound => Expr::Compound(<>),
    #[precedence(level="2")] #[assoc(side="left")]
    NonCurlyExpr,
}

NonCurlyExpr: Expr<'a> = {
    #[precedence(level="0")]
    // TODO F-String
    Literal => Expr::Literal(<>),
    NonCurlyCompound => Expr::Compound(<>),
    VarAccess => Expr::Var(<>),
    FnCall => Expr::FnCall { name: <>.0, params: <>.1 },
    Query,
    "(" <AnyExpr> ")",
    ! => {
        errors.push(<>);
        Expr::Error
    },

    #[precedence(level="1")] #[assoc(side="right")]
    "!" <NonCurlyExpr> => Expr::LogicalNot(arena.alloc(<>)),
    "-" <NonCurlyExpr> => Expr::Neg(arena.alloc(<>)),

    #[precedence(level="2")] #[assoc(side="right")]
    <l:NonCurlyExpr> "**" <r:NonCurlyExpr> => Expr::Op(arena.alloc(l), Opcode::Pow, arena.alloc(r)),

    #[precedence(level="3")] #[assoc(side="left")]
    <l:NonCurlyExpr> "*" <r:NonCurlyExpr> => Expr::Op(arena.alloc(l), Opcode::Mul, arena.alloc(r)),
    <l:NonCurlyExpr> "/" <r:NonCurlyExpr> => Expr::Op(arena.alloc(l), Opcode::Div, arena.alloc(r)),
    <l:NonCurlyExpr> "%" <r:NonCurlyExpr> => Expr::Op(arena.alloc(l), Opcode::Mod, arena.alloc(r)),

    #[precedence(level="4")] #[assoc(side="left")]
    <l:NonCurlyExpr> "+" <r:NonCurlyExpr> => Expr::Op(arena.alloc(l), Opcode::Add, arena.alloc(r)),
    <l:NonCurlyExpr> "-" <r:NonCurlyExpr> => Expr::Op(arena.alloc(l), Opcode::Sub, arena.alloc(r)),

    #[precedence(level="5")] #[assoc(side="left")]
    <l:NonCurlyExpr> <op:ShiftOp> <r:NonCurlyExpr> => Expr::Op(arena.alloc(l), op, arena.alloc(r)),

    #[precedence(level="6")] #[assoc(side="left")]
    <l:NonCurlyExpr> <op:CompOp> <r:NonCurlyExpr> => Expr::Op(arena.alloc(l), op, arena.alloc(r)),

    #[precedence(level="7")] #[assoc(side="left")]
    <l:NonCurlyExpr> "&" <r:NonCurlyExpr> => Expr::Op(arena.alloc(l), Opcode::And, arena.alloc(r)),

    #[precedence(level="8")] #[assoc(side="left")]
    <l:NonCurlyExpr> "^" <r:NonCurlyExpr> => Expr::Op(arena.alloc(l), Opcode::Xor, arena.alloc(r)),

    #[precedence(level="9")] #[assoc(side="left")]
    <l:NonCurlyExpr> "|" <r:NonCurlyExpr> => Expr::Op(arena.alloc(l), Opcode::Or, arena.alloc(r)),

    #[precedence(level="10")] #[assoc(side="left")]
    <l:NonCurlyExpr> "&&" <r:NonCurlyExpr> => Expr::Op(arena.alloc(l), Opcode::AndAnd, arena.alloc(r)),

    #[precedence(level="11")] #[assoc(side="left")]
    <l:NonCurlyExpr> "||" <r:NonCurlyExpr> => Expr::Op(arena.alloc(l), Opcode::OrOr, arena.alloc(r)),

    #[precedence(level="12")] #[assoc(side="left")]
    <e:NonCurlyExpr> "as" <to:Type> => Expr::Cast { value: arena.alloc(e), to },
}

ShiftOp: Opcode = {
    "<<" => Opcode::Shl,
    ">>" => Opcode::Shr,
}

CompOp: Opcode = {
    "==" => Opcode::EqEq,
    "!=" => Opcode::Neq,
    "<" => Opcode::Lt,
    "<=" => Opcode::Le,
    ">" => Opcode::Gt,
    ">=" => Opcode::Ge,
}

ModOp: Opcode = {
    "+=" => Opcode::Add,
    "-=" => Opcode::Sub,
    "*=" => Opcode::Mul,
    "/=" => Opcode::Div,
    "%=" => Opcode::Mod,
    "**=" => Opcode::Pow,
    "^=" => Opcode::Xor,
    "&=" => Opcode::And,
    "|=" => Opcode::Or,
    "<<=" => Opcode::Shl,
    ">>=" => Opcode::Shr,
}

Literal: Literal<'a> = {
    Number => match <> {
        Number::Int(n) => Literal::Int(n),
        Number::Float(n) => Literal::Float(n),
    },
    Bool => Literal::Bool(<>),
    String => Literal::String(<>),
}

NonCurlyCompound: Compound<'a> = {
    List,
    Tuple,
}

CurlyCompound: Compound<'a> = {
    Struct,
}

Type: Type<'a> = {
    Ident => Type::User(<>),
    ListType,
    TupleType,

    "int" => Type::Int,
    "float" => Type::Float,
    "bool" => Type::Bool,
    "string" => Type::String,
}

ListType: Type<'a> = {
    <Type> "[" "]" => Type::List(arena.alloc(<>)),
}

TupleType: Type<'a> = {
    "(" <types:Comma2<Type>> ")" => {
        Type::Tuple(types)
    },
}

Query: Expr<'a> = {
    <query_type:QueryType> "<"
        <target:Ident>
        <params:("," <QueryParam>)*>
        <r#where:("," "where" "{" <AnyExpr> "}")?>
        ","?
    ">" => {
        Expr::Query {
            query_type,
            target,
            params: arena.alloc_slice_clone(&params),
            r#where: match r#where {
                Some(w) => Some(arena.alloc(w)),
                None => None
            }
        }
    }, 
}

QueryParam: QueryParam<'a> = {
    <name:Ident> ":" <value:Literal>
        => QueryParam { name, value: QueryParamValue::Literal(value) },
    <name:Ident> ":" <value:Ident>
        => QueryParam { name, value: QueryParamValue::Ident(value) },
}

QueryType: QueryType = {
    "Bind" => QueryType::Bind,
    "Observe" => QueryType::Observe,
    "FilterSet" => QueryType::FilterSet,
}

Ternary: Expr<'a> = {
    <cond:NonCurlyExpr> "?" <a:AnyExpr> ":" <b:AnyExpr> => Expr::Ternary {
        cond: arena.alloc(cond),
        a: arena.alloc(a),
        b: arena.alloc(b)
    },
}

FnCall: (VarAccess<'a>, &'a [Expr<'a>]) = {
    <name:VarAccess> "(" <params:Comma<AnyExpr>> ")" => {
        (name, params)
    }
}

Struct: Compound<'a> = {
    <name:NamespacePath> "{" <fields:Comma<FieldInst>> "}" => {
        Compound::Struct {
            name,
            fields
        }
    },
}

FieldInst: FieldInst<'a> = {
    <name:Ident> ":" <value:AnyExpr> => FieldInst { name, value: Some(value) },
    <name:Ident> => FieldInst { name, value: None }
}

Tuple: Compound<'a> = {
    "(" <items:Comma2<AnyExpr>> ")" => {
        Compound::Tuple(items)
    }
}

List: Compound<'a> = {
    "[" <items:Comma<AnyExpr>> "]" => {
        Compound::List(items)
    }
}




Range: Range<'a> = {
    <s:RangePart> ".." <e:RangePart> => Range {
        start: s,
        inclusive: false,
        end: e,
    },
    <s:RangePart> "..=" <e:RangePart> => Range {
        start: s,
        inclusive: true,
        end: e,
    },
}

RangePart: Expr<'a> = {
    <n:Number> =>? match n {
        Number::Int(i) => Ok(Expr::Literal(Literal::Int(i))),
        Number::Float(_) => Err(ParseError::User { error: LexicalError::InvalidToken }),
    },
    
    VarAccess => Expr::Var(<>),
    "(" <NonCurlyExpr> ")"
}


NamespacePath: NamespacePath<'a> = {
    <ns:(<Ident> "::")*> <tail:Ident> => {
        NamespacePath {
            ns: arena.alloc_slice_clone(&ns),
            tail
        }
    }
}

VarAccess: VarAccess<'a> = {
    <var:NamespacePath> <tail:CompoundPart*> => {
        VarAccess {
            var,
            tail: arena.alloc_slice_clone(&tail) 
        }
    },
}

CompoundPart: CompoundPart<'a> = {
   "[" <NonCurlyExpr> "]" => CompoundPart::Bracket(<>),

    "." <n:Number> =>? match n {
        Number::Int(i) => Ok(CompoundPart::Tuple(i)),
        Number::Float(_) => Err(ParseError::User { error: LexicalError::InvalidToken }),
    },    

    "." <Ident> => CompoundPart::Field(<>),
}

If<T>: Statement<'a> = {
    "if" <cond:NonCurlyExpr> <body:Block<T>> => {
        Statement::If {
            cond,
            body,
            r#else: None
        }
    },

    "if" <cond:NonCurlyExpr> <body:Block<T>> <next:Else<T>> => {
        Statement::If {
            cond,
            body,
            r#else: Some(arena.alloc(next))
        }
    }
}

Else<T>: Else<'a> = {
    "else" "if" <cond:NonCurlyExpr> <body:Block<T>> => {
        Else::If {
            cond,
            body,
            r#else: None
        }
    },

    "else" "if" <cond:NonCurlyExpr> <body:Block<T>> <r#else:Else<T>> => {
        Else::If {
            cond,
            body,
            r#else: Some(arena.alloc(r#else))
        }
    },

    "else" <body:Block<T>> => {
        Else::Else(body)
    }
}

DashboardDefn: Statement<'a> = {
    "dashboard" <name:String> <body:Block<ElementStatement>> => {
        Statement::DashboardDefn {
            name,
            body
        }
    }
}

ElementDefn: Statement<'a> = {
    "element" <name:Ident> <params:ParameterDefns> <body:Block<ElementStatement>> => {
        Statement::ElementDefn {
            name,
            params,
            body
        }
    },

    "element" <name:Ident> <body:Block<ElementStatement>> => {
        Statement::ElementDefn {
            name,
            params: &[],
            body
        }
    }
}

ElementInst: Statement<'a> = {
    <name:Ident> <body:Block<ElementStatement>> => {
        Statement::ElementInst { name, params: &[], body }  
    },

    <name:Ident> "(" <params:Comma<NamedParameterInst>> ")" => {
        Statement::ElementInst { name, params, body: &[] }  
    },

    <name:Ident> "(" <params:Comma<NamedParameterInst>> ")" <body:Block<ElementStatement>> => {
        Statement::ElementInst { name, params, body }  
    },
}

NamedParameterInst: NamedParameterInst<'a> = {
    <value:NonCurlyExpr>
        => NamedParameterInst { name: None, value },
    <name:Ident> ":" <value:NonCurlyExpr>
        => NamedParameterInst { name: Some(name), value }
}

FnDefn: Statement<'a> = {
    "fn" <name:Ident> <params:ParameterDefns> <return_type:("->" <Type>)?> <body:Block<FnStatement>>
    => {
        Statement::FnDefn {
            name,
            params,
            return_type,
            body
        }
    }
}

ParameterDefns: &'a [ParameterDefn<'a>] = {
    "(" <Comma<ParameterDefn>> ")" => <>
}

ParameterDefn: ParameterDefn<'a> = {
    <name:Ident> ":" <r#type:Type> => ParameterDefn { name, r#type }
}

StructDefn: Statement<'a> = {
    "struct" <name:Ident> "{" <fields:Comma<StructDefnField>> "}" => {
        Statement::StructDefn {
            name,
            fields
        }
    }
}

StructDefnField: FieldDefn<'a> = {
    <name:Ident> ":" <r#type:Type> => FieldDefn { name, r#type }
}

EnumDefn: Statement<'a> = {
    "enum" <name:Ident> "{" <variants:Comma<Ident>> "}" => {
        Statement::EnumDefn {
            name,
            variants
        }
    }
}

TypeDefn: Statement<'a> = {
    "type" <name:Ident> "=" <value:Type> ";" => {
        Statement::TypeDefn {
            name,
            value
        }
    }
}

Loop<T>: Statement<'a> = {
    "while" <cond:NonCurlyExpr> <body:Block<T>> => {
        Statement::While {
            cond,
            body
        }
    },
    "for" <var:Ident> "in" <iter:Range> <body:Block<T>> => {
        Statement::For {
            var,
            iter: Either::Left(iter),
            body
        }
    },
    "for" <var:Ident> "in" <iter:VarAccess> <body:Block<T>> => {
        Statement::For {
            var,
            iter: Either::Right(iter),
            body
        }
    }
}




// UTIL ---------------

Block<T>: &'a [T] = {
    "{" <statements:T*> "}" => {
        arena.alloc_slice_clone(&statements)
    }  
};

Comma<T>: &'a [T] = {
    <mut v:(<T> ",")*> <e:T?> => {
        if let Some(e) = e { v.push(e); }
        arena.alloc_slice_clone(&v)
    }
};

// >=2 items
Comma2<T>: &'a [T] = {
    <mut v:(<T> ",")+> <e:T> ","? => {
        v.push(e);
        arena.alloc_slice_clone(&v)
    }
};



// TOKENS ----------------------------

extern {
    type Location = usize;
    type Error = LexicalError;

    enum Token<'a> {
        Ident => Token::Ident(<&'a str>),
        Number => Token::Number(<Number>),
        Bool => Token::Bool(<bool>),
        String => Token::String(<&'a str>),

        "let" => Token::Let,
        "const" => Token::Const,
        "while" => Token::While,
        "for" => Token::For,
        "in" => Token::In,
        "if" => Token::If,
        "else" => Token::Else,
        "fn" => Token::Fn,
        "struct" => Token::Struct,
        "enum" => Token::Enum,
        "type" => Token::Type,
        "dashboard" => Token::Dashboard,
        "element" => Token::Element,
        "use" => Token::Use,
        "mod" => Token::Mod,
        "return" => Token::Return,
        "break" => Token::Break,
        "continue" => Token::Continue,

        "Bind" => Token::Bind,
        "Observe" => Token::Observe,
        "FilterSet" => Token::FilterSet,
        "where" => Token::Where,

        "=" => Token::Eq,

        "(" => Token::OpenParen,
        ")" => Token::CloseParen,
        "[" => Token::OpenBracket,
        "]" => Token::CloseBracket,
        "{" => Token::OpenBrace,
        "}" => Token::CloseBrace,

        "+" => Token::Plus,
        "-" => Token::Minus,
        "*" => Token::Star,
        "/" => Token::Slash,
        "%" => Token::Percent,
        "**" => Token::StarStar,
        "<<" => Token::Shl,
        ">>" => Token::Shr,

        "+=" => Token::PlusEq,
        "-=" => Token::MinusEq,
        "*=" => Token::StarEq,
        "/=" => Token::SlashEq,
        "%=" => Token::PercentEq,
        "**=" => Token::StarStarEq,
        "^=" => Token::CarotEq,
        "&=" => Token::AndEq,
        "|=" => Token::OrEq,
        "<<=" => Token::ShlEq,
        ">>=" => Token::ShrEq,

        "==" => Token::EqEq,
        "!=" => Token::Neq,
        "<" => Token::Lt,
        "<=" => Token::Le,
        ">" => Token::Gt,
        ">=" => Token::Ge,

        "&&" => Token::AndAnd,
        "||" => Token::OrOr,
        "^" => Token::Caret,
        "&" => Token::And,
        "|" => Token::Or,

        "as" => Token::As,

        "int" => Token::IntType,
        "float" => Token::FloatType,
        "bool" => Token::BoolType,
        "string" => Token::StringType,

        ";" => Token::SemiColon,
        "?" => Token::Question,
        "!" => Token::Bang,
        ":" => Token::Colon,
        "::" => Token::ColonColon,
        "," => Token::Comma,
        "." => Token::Period,
        "->" => Token::RArrow,
        "=>" => Token::FatArrow,
        ".." => Token::DotDot,
        "..=" => Token::DotDotEq,

        "mistake" => Token::MistakenKeyword(<&'a str>),
        "error" => Token::Error,
    }
}
