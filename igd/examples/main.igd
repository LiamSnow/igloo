use std::RGBCTLight;
use std::ThermostatCard;
use mushroom::Button;
use mushroom::SensorCard;

dashboard "Home Overview" {
    let indoor_temp = Observe<Real,
        in_any_group: [1:0, 10:2],
        aggregate: mean,
        where {
            Unit == "Fahrenheit"
        }
    >;
    
    let outdoor_temp = Observe<Real,
        in_group: 15:0,
        aggregate: mean,
        where {
            Unit == "Fahrenheit"
        }
    >;

    let living_filters = FilterSet<
        in_any_group: [1, 12, 509],  
        where {
            with(Light)
        }
    >;

    let all_lights_on = Observe<Switch,
        apply: living_filters,
        aggregate: any,
    >;

    let total_power = Observe<Real,
        where {
            with(Power) && Unit == "Watts"
        },
        aggregate: sum,
    >;

    let motion_detected = Observe<Switch,
        in_group: 129109,  
        where {
            with(Motion)
        },
        aggregate: any,
    >;

    VStack(spacing: 16, padding: 20) {
        HStack(spacing: 12) {
            Card(width: flex) {
                VStack(align: center) {
                    Text("Indoor", size: small, color: muted)
                    Text(f"{indoor_temp}°F", size: large, weight: bold)
                }
            }
            
            Card(width: flex) {
                VStack(align: center) {
                    Text("Outdoor", size: small, color: muted)
                    Text(f"{outdoor_temp}°F", size: large, weight: bold)
                }
            }

            Card(width: flex) {
                VStack(align: center) {
                    Text("Power", size: small, color: muted)
                    Text(f"{total_power}W", size: large, weight: bold)
                }
            }
        }

        Card {
            VStack(spacing: 12) {
                HStack(justify: space_between) {
                    Text("Climate", size: large, weight: bold)
                    
                    if indoor_temp > 75 {
                        Badge("AC Running", color: blue)
                    } else if indoor_temp < 65 {
                        Badge("Heating", color: orange)
                    }
                }

                for group in Groups(in_any: [10, 50]) {
                    ThermostatCard(
                        group: group,
                        show_humidity: true
                    )
                }
            }
        }

        Card {
            VStack(spacing: 12) {
                HStack(justify: space_between) {
                    Text("Lighting", size: large, weight: bold)
                    
                    Button(
                        text: all_lights_on ? "All Off" : "All On",
                        on_click: Set(living_filters, Switch, !all_lights_on)
                    )
                }

                for group in Groups(in_any: [1, 2, 3]) {
                    Collapsible(title: f"{group.name}") {
                        RGBCTLight(
                            filters: FilterSet
                                in_group: group.id,
                                where { with(Light) }
                            >
                        )
                    }
                }
            }
        }

        if motion_detected {
            Card(background: warning) {
                HStack(align: center, spacing: 8) {
                    Icon("alert-circle", color: warning_text)
                    Text("Motion detected", weight: bold)
                }
            }
        }

        Card {
            VStack(spacing: 8) {
                Text("Device Status", size: large, weight: bold)
                
                let offline_devices = Observe<Bool,
                    where {
                        device_last_update > 300  
                    },
                    aggregate: count,
                >;

                if offline_devices > 0 {
                    HStack(spacing: 8) {
                        Icon("wifi-off", color: error)
                        Text(f"{offline_devices} devices offline", color: error)
                    }
                } else {
                    HStack(spacing: 8) {
                        Icon("check-circle", color: success)
                        Text("All devices online", color: success)
                    }
                }
            }
        }
    }
}

element ThermostatCard(group: Group, show_humidity: bool) {
    let temp = Bind<Real,
        in_group: group.id,
        where {
            with(Thermostat) && Unit == "Fahrenheit"
        },
        aggregate: mean,
    >;

    let target = Bind<Real,
        in_group: group.id,
        where {
            with(ThermostatTarget)
        },
        aggregate: mean,
    >;

    let humidity = Observe<Real,
        in_group: group.id,
        where {
            with(Humidity)
        },
        aggregate: mean,
    >;

    VStack(spacing: 8) {
        HStack(justify: space_between) {
            Text(f"{group.name}", weight: medium)
            Text(f"{temp}°F", size: large)
        }
        
        Slider(
            value: target,
            min: 60,
            max: 85,
            step: 0.5
        )

        if show_humidity {
            Text(f"Humidity: {humidity}%", size: small, color: muted)
        }
    }
}

element RGBCTLight(filters: Filter) {
    let dimmer = Bind<Dimmer,
        apply: filters,
        aggregate: mean,
        where {
            with: Light
        }
    >;

    let color = Bind<Color,
        apply: filters,
        aggregate: mean,
        where {
            with: Light
        }
    >;

    let color = Bind<ColorTemperature,
        apply: filters,
        aggregate: mean,
        where {
            with: Light
        }
    >;

    VStack {
        Slider(value: dimmer, min: 0, max: 100)
        ColorPicker(value: color)
    }
}

// this example uses more language features
// all of this runs client-side
dashboard "Complex Dashboard" {
    let a = 2;

    a = 3; // everything is mutable

    let a = 4; // support shadowing

    let b: int = 3; // allow typing

    b *= 2; // b is 6 now

    // fixed loop, using rust range pattern
    for i in 0..2 {
        if i == 1 {
            break;
        }
    }

    let c = 0;

    while c < 10 {
        c += 1;        
        // ++ syntax is not supported
    }
}

fn square(num: int) -> int {
    return num * num;
}

// enums dont store values, just a union
enum Animal {
    Cat,
    Dog,
    Sheep
    // ^ trailing comma optional
}

// rust-like syntax
let my_animal = Animal::Cat;

// simple type replacement
type ZombieID = int;

struct Zombie {
    id: ZombieID,
    health: int,
    walk_speed: float,
    name: string,
}

let my_zombie = Zombie {
    id: 10,
    health: 100,
    walk_speed: 1.5,
    name: "My Zombie",  
};

// field access
my_zombie.health -= 10;


// tuples
let my_tuple = (10, "Hello");

// or typed
let my_tuple: (int, string) = (10, "Hello");

// access
my_tuple.0 = 50; // valid
my_tuple.1 = 1.2; // invalid type
my_tuple.1 = 1.2 as string; // valid because of cast


