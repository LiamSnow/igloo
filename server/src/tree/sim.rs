//! Generate random test DeviceTree
//! NOTE: Generated by Claude
#![allow(dead_code)]

use crate::tree::{arena::Arena, persist::IniWriter};

use super::{COMP_TYPE_ARR_LEN, Device, DeviceTree, Entity, Extension, Group, Presense};
use igloo_interface::{
    AlarmState, ClimateMode, ColorMode, Component, CoverState, FanDirection, FanOscillation,
    FanSpeed, LockState, MediaState, SensorStateClass, Unit, ValveState,
    id::{DeviceID, EntityID, EntityIndex, ExtensionID, ExtensionIndex, GenerationalID, GroupID},
    types::IglooColor,
};
use rand::{Rng, rngs::ThreadRng};
use rustc_hash::{FxHashMap, FxHashSet};
use smallvec::SmallVec;
use std::time::Instant;

const ROOM_NAMES: &[&str] = &[
    "Kitchen",
    "Living Room",
    "Bedroom",
    "Bathroom",
    "Office",
    "Garage",
    "Basement",
    "Attic",
    "Porch",
    "Den",
    "Nursery",
    "Dining Room",
    "Laundry",
    "Hallway",
    "Master Bedroom",
];

const EXT_NAMES: &[&str] = &[
    "ESPHome",
    "Zigbee2MQTT",
    "Tasmota",
    "HomeKit",
    "Shelly",
    "WLED",
    "Matter",
];

#[derive(Clone, Copy, Debug)]
pub enum DeviceArchetype {
    RgbBulb,
    DimmableBulb,
    SmartPlug,
    MotionSensor,
    TempHumiditySensor,
    DoorSensor,
    SmartLock,
    Thermostat,
    CeilingFan,
    MediaPlayer,
    GarageDoor,
    SprinklerValve,
    AlarmPanel,
}

impl DeviceArchetype {
    const ALL: &'static [Self] = &[
        Self::RgbBulb,
        Self::DimmableBulb,
        Self::SmartPlug,
        Self::MotionSensor,
        Self::TempHumiditySensor,
        Self::DoorSensor,
        Self::SmartLock,
        Self::Thermostat,
        Self::CeilingFan,
        Self::MediaPlayer,
        Self::GarageDoor,
        Self::SprinklerValve,
        Self::AlarmPanel,
    ];

    fn name_suffix(&self) -> &'static str {
        match self {
            Self::RgbBulb => "RGB Bulb",
            Self::DimmableBulb => "Lamp",
            Self::SmartPlug => "Plug",
            Self::MotionSensor => "Motion",
            Self::TempHumiditySensor => "Climate Sensor",
            Self::DoorSensor => "Door",
            Self::SmartLock => "Lock",
            Self::Thermostat => "Thermostat",
            Self::CeilingFan => "Fan",
            Self::MediaPlayer => "Speaker",
            Self::GarageDoor => "Garage Door",
            Self::SprinklerValve => "Sprinkler",
            Self::AlarmPanel => "Alarm",
        }
    }

    fn random(rng: &mut ThreadRng) -> Self {
        Self::ALL[rng.random_range(0..Self::ALL.len())]
    }
}

pub fn make_test_tree(num_exts: usize, num_groups: usize, num_devices: usize) -> DeviceTree {
    let mut rng = rand::rng();

    let mut groups: Arena<GroupID, Group> =
        Arena::with_preallocated_slots(num_groups.max(50).saturating_sub(1), 0);

    for i in 0..num_groups {
        let gid = GroupID::from_parts(i as u32, 0);
        let group = Group {
            id: gid,
            name: ROOM_NAMES
                .get(i % ROOM_NAMES.len())
                .unwrap_or(&"Room")
                .to_string(),
            devices: FxHashSet::default(),
        };

        groups
            .insert_at(gid, group)
            .expect("failed to insert group in test tree");
    }

    let ext_ids: Vec<ExtensionID> = (0..num_exts)
        .map(|i| {
            ExtensionID(
                EXT_NAMES
                    .get(i % EXT_NAMES.len())
                    .unwrap_or(&"Extension")
                    .to_string(),
            )
        })
        .collect();

    let mut devices: Arena<DeviceID, Device> =
        Arena::with_preallocated_slots(num_devices.max(200).saturating_sub(1), 0);

    for i in 0..num_devices {
        let owner_idx = i % num_exts.max(1);
        let owner = ext_ids
            .get(owner_idx)
            .cloned()
            .unwrap_or(ExtensionID("Default".into()));

        let archetype = DeviceArchetype::random(&mut rng);
        let room = ROOM_NAMES.get(i % ROOM_NAMES.len()).unwrap_or(&"Room");
        let name = format!("{} {}", room, archetype.name_suffix());

        let did = DeviceID::from_parts(i as u32, 0);
        let entities = make_entities_for_archetype(&mut rng, archetype);

        let mut presense = Presense::default();
        let mut comp_to_entity: [SmallVec<[EntityIndex; 4]>; COMP_TYPE_ARR_LEN] =
            [const { SmallVec::new_const() }; COMP_TYPE_ARR_LEN];

        for entity in entities.iter() {
            for comp in &entity.components {
                let typ = comp.get_type();
                presense.set(typ);
                comp_to_entity[typ as usize].push(entity.index);
            }
        }

        let entity_index_lut = entities
            .iter()
            .map(|entity| (entity.id.clone(), entity.index))
            .collect();

        let mut device_groups = FxHashSet::default();
        if num_groups > 0 {
            device_groups.insert(GroupID::from_parts((i % num_groups) as u32, 0));
        }

        let device = Device {
            id: did,
            name,
            owner,
            owner_ref: Some(ExtensionIndex(owner_idx)),
            groups: device_groups,
            presense,
            comp_to_entity,
            entities,
            entity_index_lut,
            last_updated: Instant::now(),
        };

        devices
            .insert_at(did, device)
            .expect("failed to insert device in test tree");
    }

    // link devices to groups
    for device in devices.iter() {
        for gid in &device.groups {
            if let Some(group) = groups.get_mut(gid) {
                group.devices.insert(device.id);
            }
        }
    }

    // FIXME mock writer
    let exts: Vec<Option<Extension>> = Vec::new();
    let mut ext_ref_lut = FxHashMap::default();
    for (eindex, eid) in ext_ids.iter().enumerate() {
        ext_ref_lut.insert(eid.clone(), ExtensionIndex(eindex));
    }

    DeviceTree {
        groups,
        attached_exts: exts,
        ext_ref_lut,
        devices,
        groups_writer: IniWriter::fake(),
        devices_writer: IniWriter::fake(),
    }
}
fn make_entities_for_archetype(
    rng: &mut ThreadRng,
    archetype: DeviceArchetype,
) -> SmallVec<[Entity; 16]> {
    let mut entities = SmallVec::new();
    let mut idx = 0;

    entities.push(make_entity(
        idx,
        "Status",
        vec![
            Component::Diagnostic,
            Component::DeviceClass("connectivity".into()),
            Component::Sensor,
            Component::Boolean(true),
        ],
    ));
    idx += 1;

    match archetype {
        DeviceArchetype::RgbBulb => {
            entities.push(make_entity(
                idx,
                "Light",
                vec![
                    Component::Light,
                    Component::Color(random_color(rng)),
                    Component::Dimmer(rng.random()),
                    Component::Switch(rng.random_bool(0.7)),
                    Component::ColorTemperature(rng.random_range(2000..6500)),
                    Component::ColorMode(random_color_mode(rng)),
                ],
            ));
            idx += 1;
        }

        DeviceArchetype::DimmableBulb => {
            entities.push(make_entity(
                idx,
                "Light",
                vec![
                    Component::Light,
                    Component::Dimmer(rng.random()),
                    Component::Switch(rng.random_bool(0.7)),
                ],
            ));
            idx += 1;
        }

        DeviceArchetype::SmartPlug => {
            entities.push(make_entity(
                idx,
                "Relay",
                vec![Component::Switch(rng.random_bool(0.5))],
            ));
            idx += 1;

            entities.push(make_entity(
                idx,
                "Power",
                vec![
                    Component::Sensor,
                    Component::Unit(Unit::Watts),
                    Component::SensorStateClass(SensorStateClass::Measurement),
                    Component::Real(rng.random_range(0.0..1500.0)),
                ],
            ));
            idx += 1;

            entities.push(make_entity(
                idx,
                "Energy",
                vec![
                    Component::Sensor,
                    Component::Unit(Unit::KiloWattHours),
                    Component::SensorStateClass(SensorStateClass::TotalIncreasing),
                    Component::Real(rng.random_range(0.0..500.0)),
                ],
            ));
            idx += 1;
        }

        DeviceArchetype::MotionSensor => {
            entities.push(make_entity(
                idx,
                "Motion",
                vec![
                    Component::Sensor,
                    Component::DeviceClass("motion".into()),
                    Component::Boolean(rng.random_bool(0.2)),
                ],
            ));
            idx += 1;

            entities.push(make_entity(
                idx,
                "Illuminance",
                vec![
                    Component::Sensor,
                    Component::Unit(Unit::Lux),
                    Component::SensorStateClass(SensorStateClass::Measurement),
                    Component::Real(rng.random_range(0.0..1000.0)),
                ],
            ));
            idx += 1;
        }

        DeviceArchetype::TempHumiditySensor => {
            entities.push(make_entity(
                idx,
                "Temperature",
                vec![
                    Component::Sensor,
                    Component::DeviceClass("temperature".into()),
                    Component::Unit(Unit::Celsius),
                    Component::SensorStateClass(SensorStateClass::Measurement),
                    Component::AccuracyDecimals(1),
                    Component::Real(rng.random_range(15.0..30.0)),
                ],
            ));
            idx += 1;

            entities.push(make_entity(
                idx,
                "Humidity",
                vec![
                    Component::Sensor,
                    Component::DeviceClass("humidity".into()),
                    Component::Unit(Unit::Percentage),
                    Component::SensorStateClass(SensorStateClass::Measurement),
                    Component::AccuracyDecimals(0),
                    Component::Real(rng.random_range(30.0..70.0)),
                ],
            ));
            idx += 1;
        }

        DeviceArchetype::DoorSensor => {
            entities.push(make_entity(
                idx,
                "Contact",
                vec![
                    Component::Sensor,
                    Component::DeviceClass("door".into()),
                    Component::Boolean(rng.random_bool(0.3)),
                ],
            ));
            idx += 1;
        }

        DeviceArchetype::SmartLock => {
            entities.push(make_entity(
                idx,
                "Lock",
                vec![Component::LockState(if rng.random_bool(0.8) {
                    LockState::Locked
                } else {
                    LockState::Unlocked
                })],
            ));
            idx += 1;
        }

        DeviceArchetype::Thermostat => {
            entities.push(make_entity(
                idx,
                "Climate",
                vec![
                    Component::ClimateMode(random_climate_mode(rng)),
                    Component::Real(rng.random_range(18.0..24.0)),
                ],
            ));
            idx += 1;

            entities.push(make_entity(
                idx,
                "Current Temperature",
                vec![
                    Component::Sensor,
                    Component::DeviceClass("temperature".into()),
                    Component::Unit(Unit::Celsius),
                    Component::Real(rng.random_range(15.0..28.0)),
                ],
            ));
            idx += 1;
        }

        DeviceArchetype::CeilingFan => {
            entities.push(make_entity(
                idx,
                "Fan",
                vec![
                    Component::Switch(rng.random_bool(0.5)),
                    Component::FanSpeed(random_fan_speed(rng)),
                    Component::FanDirection(if rng.random_bool(0.8) {
                        FanDirection::Forward
                    } else {
                        FanDirection::Reverse
                    }),
                    Component::FanOscillation(FanOscillation::Off),
                ],
            ));
            idx += 1;

            if rng.random_bool(0.6) {
                entities.push(make_entity(
                    idx,
                    "Light Kit",
                    vec![
                        Component::Light,
                        Component::Dimmer(rng.random()),
                        Component::Switch(rng.random_bool(0.5)),
                    ],
                ));
                idx += 1;
            }
        }

        DeviceArchetype::MediaPlayer => {
            entities.push(make_entity(
                idx,
                "Player",
                vec![
                    Component::MediaState(random_media_state(rng)),
                    Component::Volume(rng.random()),
                    Component::Muted(rng.random_bool(0.1)),
                ],
            ));
            idx += 1;
        }

        DeviceArchetype::GarageDoor => {
            entities.push(make_entity(
                idx,
                "Door",
                vec![
                    Component::Cover,
                    Component::CoverState(random_cover_state(rng)),
                    Component::Position(rng.random()),
                ],
            ));
            idx += 1;
        }

        DeviceArchetype::SprinklerValve => {
            entities.push(make_entity(
                idx,
                "Valve",
                vec![
                    Component::Valve,
                    Component::ValveState(if rng.random_bool(0.1) {
                        ValveState::Opening
                    } else {
                        ValveState::Idle
                    }),
                    Component::Position(if rng.random_bool(0.9) { 0.0 } else { 1.0 }),
                ],
            ));
            idx += 1;
        }

        DeviceArchetype::AlarmPanel => {
            entities.push(make_entity(
                idx,
                "Alarm",
                vec![Component::AlarmState(random_alarm_state(rng))],
            ));
            idx += 1;
        }
    }

    entities.push(make_entity(
        idx,
        "WiFi Signal",
        vec![
            Component::Diagnostic,
            Component::SensorStateClass(SensorStateClass::Measurement),
            Component::DeviceClass("signal_strength".into()),
            Component::Unit(Unit::DecibelsMilliwatt),
            Component::Sensor,
            Component::Real(rng.random_range(-80.0..-30.0)),
        ],
    ));
    idx += 1;

    entities.push(make_entity(
        idx,
        "IP Address",
        vec![
            Component::Diagnostic,
            Component::Sensor,
            Component::Text(format!("192.168.1.{}", rng.random_range(2..254))),
        ],
    ));

    entities
}

fn make_entity(eindex: usize, eid: &str, components: Vec<Component>) -> Entity {
    let mut indices = [0xFF; COMP_TYPE_ARR_LEN];
    for (cidx, comp) in components.iter().enumerate() {
        indices[comp.get_type() as usize] = cidx as u8;
    }

    Entity {
        id: EntityID(eid.to_string()),
        index: EntityIndex(eindex),
        components: components.into(),
        indices,
        last_updated: Instant::now(),
    }
}

fn random_color(rng: &mut ThreadRng) -> IglooColor {
    IglooColor {
        r: rng.random(),
        g: rng.random(),
        b: rng.random(),
    }
}

fn random_color_mode(rng: &mut ThreadRng) -> ColorMode {
    if rng.random_bool(0.5) {
        ColorMode::RGB
    } else {
        ColorMode::Temperature
    }
}

fn random_climate_mode(rng: &mut ThreadRng) -> ClimateMode {
    [
        ClimateMode::Off,
        ClimateMode::Heat,
        ClimateMode::Cool,
        ClimateMode::Auto,
    ][rng.random_range(0..4)]
    .clone()
}

fn random_fan_speed(rng: &mut ThreadRng) -> FanSpeed {
    [
        FanSpeed::Off,
        FanSpeed::Low,
        FanSpeed::Medium,
        FanSpeed::High,
    ][rng.random_range(0..4)]
    .clone()
}

fn random_media_state(rng: &mut ThreadRng) -> MediaState {
    [MediaState::Idle, MediaState::Playing, MediaState::Paused][rng.random_range(0..3)].clone()
}

fn random_cover_state(rng: &mut ThreadRng) -> CoverState {
    [CoverState::Open, CoverState::Closed, CoverState::Idle][rng.random_range(0..3)].clone()
}

fn random_alarm_state(rng: &mut ThreadRng) -> AlarmState {
    [
        AlarmState::Disarmed,
        AlarmState::ArmedHome,
        AlarmState::ArmedAway,
    ][rng.random_range(0..3)]
    .clone()
}
